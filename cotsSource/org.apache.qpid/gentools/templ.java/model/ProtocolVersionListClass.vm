#set( $filename = "ProtocolVersion.java" )
/*
*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
* 
*   http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*
*/

/*
* This file is auto-generated by $generator - do not modify.
* Supported AMQP versions:
#foreach( $version in $model.getVersionSet() )
* $version.getMajor()-$version.getMinor()
#end
*/

package org.apache.qpid.framing;

import java.util.SortedSet;
import java.util.Collections;
import java.util.TreeSet;


public class ProtocolVersion  implements Comparable
{
    private final byte _majorVersion;
    private final byte _minorVersion;
    private final String _stringFormat;


    public ProtocolVersion(byte majorVersion, byte minorVersion)
    {
        _majorVersion = majorVersion;
        _minorVersion = minorVersion;
        _stringFormat = _majorVersion+"-"+_minorVersion;
    }

    public byte getMajorVersion()
    {
        return _majorVersion;
    }

    public byte getMinorVersion()
    {
        return _minorVersion;
    }

    public String toString()
    {
        return _stringFormat;
    }

    public int compareTo(Object o)
    {
        ProtocolVersion pv = (ProtocolVersion) o;
		
		/* 
		 * 0-8 has it's major and minor numbers the wrong way round (it's actually 8-0)...
		 * so we need to deal with that case specially
		 */
		
        if((_majorVersion == (byte) 8) && (_minorVersion == (byte) 0))
		{
		    ProtocolVersion fixedThis = new ProtocolVersion(_minorVersion, _majorVersion);
			return fixedThis.compareTo(pv);
		}
		
		if((pv.getMajorVersion() == (byte) 8) && (pv.getMinorVersion() == (byte) 0))
		{
			ProtocolVersion fixedOther = new ProtocolVersion(pv.getMinorVersion(), pv.getMajorVersion());
		    return this.compareTo(fixedOther);    
		}
		
        if(_majorVersion > pv.getMajorVersion())
        {
            return 1;
        }
        else if(_majorVersion < pv.getMajorVersion())
        {
            return -1;
        }
        else if(_minorVersion > pv.getMinorVersion())
        {
            return 1;
        }
        else if(getMinorVersion() < pv.getMinorVersion())
        {
            return -1;
        }
        else
        {
            return 0;
        }

    }

    public boolean equals(Object o)
    {
        return o != null && (o == this || (compareTo(o) == 0));
    }

    public int hashCode()
    {
        return (0xFF & (int)_minorVersion) | ((0xFF & (int)_majorVersion) << 8);
    }
    
    
    public boolean isSupported()
    {
        return _supportedVersions.contains(this);
    }
    
    public static ProtocolVersion getLatestSupportedVersion()
    {
        return _supportedVersions.last();
    }
    
    private static final SortedSet<ProtocolVersion> _supportedVersions;

    static
    {
        SortedSet<ProtocolVersion> versions = new TreeSet<ProtocolVersion>();

#foreach( $version in $model.getVersionSet() )
        versions.add(new ProtocolVersion((byte)$version.getMajor(),(byte)$version.getMinor()));
#end
        _supportedVersions = Collections.unmodifiableSortedSet(versions);
    }

    
    public static SortedSet<ProtocolVersion> getSupportedProtocolVersions()
    {
        return _supportedVersions;
    }
    
    
    
    

}
