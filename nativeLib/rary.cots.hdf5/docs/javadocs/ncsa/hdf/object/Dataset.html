<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_10) on Thu Jan 14 18:21:50 CST 2010 -->
<TITLE>
Dataset
</TITLE>

<META NAME="date" CONTENT="2010-01-14">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Dataset";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../ncsa/hdf/object/DataFormat.html" title="interface in ncsa.hdf.object"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../ncsa/hdf/object/Datatype.html" title="class in ncsa.hdf.object"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?ncsa/hdf/object/Dataset.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Dataset.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
ncsa.hdf.object</FONT>
<BR>
Class Dataset</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../ncsa/hdf/object/HObject.html" title="class in ncsa.hdf.object">ncsa.hdf.object.HObject</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>ncsa.hdf.object.Dataset</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable, <A HREF="../../../ncsa/hdf/object/DataFormat.html" title="interface in ncsa.hdf.object">DataFormat</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../ncsa/hdf/object/CompoundDS.html" title="class in ncsa.hdf.object">CompoundDS</A>, <A HREF="../../../ncsa/hdf/object/ScalarDS.html" title="class in ncsa.hdf.object">ScalarDS</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>Dataset</B><DT>extends <A HREF="../../../ncsa/hdf/object/HObject.html" title="class in ncsa.hdf.object">HObject</A></DL>
</PRE>

<P>
The abstract class provides general APIs to create and manipulate dataset objects, 
 and retrieve dataset properties datatype and dimension sizes. 
 <p>
 This class provides two convenient functions, read()/write(), to read/write data values.
 Reading/writing data may take many library calls if we use the library APIs directly.
 The read() and write functions hide all the details of these calls from users.
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>1.1 9/4/2007</DD>
<DT><B>Author:</B></DT>
  <DD>Peter X. Cao</DD>
<DT><B>See Also:</B><DD><A HREF="../../../ncsa/hdf/object/ScalarDS.html" title="class in ncsa.hdf.object"><CODE>ScalarDS</CODE></A>, 
<A HREF="../../../ncsa/hdf/object/CompoundDS.html" title="class in ncsa.hdf.object"><CODE>CompoundDS</CODE></A>, 
<A HREF="../../../serialized-form.html#ncsa.hdf.object.Dataset">Serialized Form</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#chunkSize">chunkSize</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The array of dimension sizes for a chunk.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#compression">compression</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GZIP compression level.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#convertByteToString">convertByteToString</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag to indicate if the byte[] array is converted to strings</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#convertedBuf">convertedBuf</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The array that holds the converted data of unsigned C-type integers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#data">data</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The memory buffer that holds the raw data of the dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../ncsa/hdf/object/Datatype.html" title="class in ncsa.hdf.object">Datatype</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#datatype">datatype</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The datatype object of the dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#dimNames">dimNames</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array of strings that represent the dimension names.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#dims">dims</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The current dimension sizes of the dataset</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#enumConverted">enumConverted</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag to indicate if the enum data is converted to strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#isDataLoaded">isDataLoaded</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag to indicate if data values are loaded into memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#maxDims">maxDims</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The max dimension sizes of the dataset</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#nPoints">nPoints</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of data points in the memory buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#originalBuf">originalBuf</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The data buffer that contains the raw data directly reading from 
 file (before any data conversion).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#rank">rank</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of dimensions of the dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#selectedDims">selectedDims</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array that contains the number of data points selected (for read/write) in each dimension.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#selectedIndex">selectedIndex</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array that contains the indices of the dimensions selected for display.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#selectedStride">selectedStride</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of elements to move from the start location in each dimension.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#startDims">startDims</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The starting position of each dimension of a selected subset.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_ncsa.hdf.object.HObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class ncsa.hdf.object.<A HREF="../../../ncsa/hdf/object/HObject.html" title="class in ncsa.hdf.object">HObject</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../ncsa/hdf/object/HObject.html#oid">oid</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#separator">separator</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#serialVersionUID">serialVersionUID</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#Dataset(ncsa.hdf.object.FileFormat, java.lang.String, java.lang.String)">Dataset</A></B>(<A HREF="../../../ncsa/hdf/object/FileFormat.html" title="class in ncsa.hdf.object">FileFormat</A>&nbsp;theFile,
        java.lang.String&nbsp;name,
        java.lang.String&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a Dataset object with a given file, name and path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#Dataset(ncsa.hdf.object.FileFormat, java.lang.String, java.lang.String, long[])">Dataset</A></B>(<A HREF="../../../ncsa/hdf/object/FileFormat.html" title="class in ncsa.hdf.object">FileFormat</A>&nbsp;theFile,
        java.lang.String&nbsp;name,
        java.lang.String&nbsp;path,
        long[]&nbsp;oid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Not for public use in the future. <br>
 Using <A HREF="../../../ncsa/hdf/object/Dataset.html#Dataset(ncsa.hdf.object.FileFormat, java.lang.String, java.lang.String)"><CODE>Dataset(FileFormat, String, String)</CODE></A></I></TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#byteToString(byte[], int)">byteToString</A></B>(byte[]&nbsp;bytes,
             int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an array of bytes into an array of Strings for a fixed string dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears memory held by the dataset, such as data buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#clearData()">clearData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the data buffer in memory and to force the next read() to load data from file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#convertFromUnsignedC(java.lang.Object)">convertFromUnsignedC</A></B>(java.lang.Object&nbsp;data_in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Not for public use in the future. <br>
 Using <A HREF="../../../ncsa/hdf/object/Dataset.html#convertFromUnsignedC(java.lang.Object, java.lang.Object)"><CODE>convertFromUnsignedC(Object, Object)</CODE></A></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#convertFromUnsignedC(java.lang.Object, java.lang.Object)">convertFromUnsignedC</A></B>(java.lang.Object&nbsp;data_in,
                     java.lang.Object&nbsp;data_out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts one-dimension array of unsigned C-type integers to a new array of appropriate Java integer in memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#convertToUnsignedC(java.lang.Object)">convertToUnsignedC</A></B>(java.lang.Object&nbsp;data_in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Not for public use in the future. <br>
 Using <A HREF="../../../ncsa/hdf/object/Dataset.html#convertToUnsignedC(java.lang.Object, java.lang.Object)"><CODE>convertToUnsignedC(Object, Object)</CODE></A></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#convertToUnsignedC(java.lang.Object, java.lang.Object)">convertToUnsignedC</A></B>(java.lang.Object&nbsp;data_in,
                   java.lang.Object&nbsp;data_out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the array of converted unsigned integer back to unsigned C-type integer data in memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../ncsa/hdf/object/Dataset.html" title="class in ncsa.hdf.object">Dataset</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#copy(ncsa.hdf.object.Group, java.lang.String, long[], java.lang.Object)">copy</A></B>(<A HREF="../../../ncsa/hdf/object/Group.html" title="class in ncsa.hdf.object">Group</A>&nbsp;pgroup,
     java.lang.String&nbsp;name,
     long[]&nbsp;dims,
     java.lang.Object&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new dataset and writes the data buffer to the new dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getChunkSize()">getChunkSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the array that contains the dimension sizes of the chunk of the dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getCompression()">getCompression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the string representation of compression information.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getConvertByteToString()">getConvertByteToString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the flag that indicates if a byte array is converted to a string array..</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getData()">getData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the data buffer of the dataset in memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../ncsa/hdf/object/Datatype.html" title="class in ncsa.hdf.object">Datatype</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getDatatype()">getDatatype</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the datatype object of the dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getDimNames()">getDimNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the array of strings that represent the dimension names.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getDims()">getDims</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the array that contins the dimension sizes of the dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getHeight()">getHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the dimension size of the vertical axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getMaxDims()">getMaxDims</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the array that contins the max dimension sizes of the dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getRank()">getRank</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the rank (number of dimensions) of the dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getSelectedDims()">getSelectedDims</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the dimension sizes of the selected subset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getSelectedIndex()">getSelectedIndex</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the indices of display order.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getSize(int)">getSize</A></B>(int&nbsp;tid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the size in bytes of a given datatype.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getStartDims()">getStartDims</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the starting position of a selected subset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getStride()">getStride</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the selectedStride of the selected dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#getWidth()">getWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the size of dimension of the horizontal axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#init()">init</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves datatype and dataspace information from file and sets the dataset in memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#isEnumConverted()">isEnumConverted</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get flag that indicate if enum data is converted to strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#isString(int)">isString</A></B>(int&nbsp;tid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a given datatype is a string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#read()">read</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the data from file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#readBytes()">readBytes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the raw data of the dataset from file to a byte array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#setConvertByteToString(boolean)">setConvertByteToString</A></B>(boolean&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the flag that indicates if a byte array is converted to a string array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#setData(java.lang.Object)">setData</A></B>(java.lang.Object&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Not for public use in the future.
 <p>
 setData() is not safe to use because it changes memory buffer
 of the dataset object. Dataset operation such as write/read 
 will fail if the buffer type or size is changed.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#setEnumConverted(boolean)">setEnumConverted</A></B>(boolean&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set flag that indicate if enum data is converted to strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#stringToByte(java.lang.String[], int)">stringToByte</A></B>(java.lang.String[]&nbsp;strings,
             int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a string array into an array of bytes for a fixed string dataset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#write()">write</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writes the memory buffer of this dataset to file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ncsa/hdf/object/Dataset.html#write(java.lang.Object)">write</A></B>(java.lang.Object&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Writes a memory buffer to the dataset in file.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_ncsa.hdf.object.HObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class ncsa.hdf.object.<A HREF="../../../ncsa/hdf/object/HObject.html" title="class in ncsa.hdf.object">HObject</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../ncsa/hdf/object/HObject.html#close(int)">close</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#debug(java.lang.Object)">debug</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#equalsOID(long[])">equalsOID</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#getFID()">getFID</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#getFile()">getFile</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#getFileFormat()">getFileFormat</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#getFullName()">getFullName</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#getName()">getName</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#getOID()">getOID</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#getPath()">getPath</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#open()">open</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#setName(java.lang.String)">setName</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#setPath(java.lang.String)">setPath</A>, <A HREF="../../../ncsa/hdf/object/HObject.html#toString()">toString</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_ncsa.hdf.object.DataFormat"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface ncsa.hdf.object.<A HREF="../../../ncsa/hdf/object/DataFormat.html" title="interface in ncsa.hdf.object">DataFormat</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../ncsa/hdf/object/DataFormat.html#getMetadata()">getMetadata</A>, <A HREF="../../../ncsa/hdf/object/DataFormat.html#hasAttribute()">hasAttribute</A>, <A HREF="../../../ncsa/hdf/object/DataFormat.html#removeMetadata(java.lang.Object)">removeMetadata</A>, <A HREF="../../../ncsa/hdf/object/DataFormat.html#writeMetadata(java.lang.Object)">writeMetadata</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="data"><!-- --></A><H3>
data</H3>
<PRE>
protected java.lang.Object <B>data</B></PRE>
<DL>
<DD>The memory buffer that holds the raw data of the dataset.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="rank"><!-- --></A><H3>
rank</H3>
<PRE>
protected int <B>rank</B></PRE>
<DL>
<DD>The number of dimensions of the dataset.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="dims"><!-- --></A><H3>
dims</H3>
<PRE>
protected long[] <B>dims</B></PRE>
<DL>
<DD>The current dimension sizes of the dataset
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxDims"><!-- --></A><H3>
maxDims</H3>
<PRE>
protected long[] <B>maxDims</B></PRE>
<DL>
<DD>The max dimension sizes of the dataset
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectedDims"><!-- --></A><H3>
selectedDims</H3>
<PRE>
protected long[] <B>selectedDims</B></PRE>
<DL>
<DD>Array that contains the number of data points selected (for read/write) in each dimension.
 <p>
 The select size must be less than or equal to the current dimension size.
 A subset of a rectangle selection is defined by the starting position 
 and selected sizes.
 <p>
 For example, a 4 X 5 dataset
 <pre>
     0,  1,  2,  3,  4
    10, 11, 12, 13, 14
    20, 21, 22, 23, 24
    30, 31, 32, 33, 34
 long[] dims = {4, 5};
 long[] startDims = {1, 2};
 long[] selectedDims = {3, 3};

 then the following subset is selected by the startDims and selectedDims above
     12, 13, 14
     22, 23, 24
     32, 33, 34
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="startDims"><!-- --></A><H3>
startDims</H3>
<PRE>
protected long[] <B>startDims</B></PRE>
<DL>
<DD>The starting position of each dimension of a selected subset.
 With both the starting position and selected sizes, the subset of a
 rectangle selection is fully defined.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectedIndex"><!-- --></A><H3>
selectedIndex</H3>
<PRE>
protected final int[] <B>selectedIndex</B></PRE>
<DL>
<DD>Array that contains the indices of the dimensions selected for display.
 <p>
 <B>selectedIndex[] is provied for two purpose:</B>
 <OL>
 <LI>
 selectedIndex[] is used to indicate the order of dimensions for display, i.e.
 selectedIndex[0] = row, selectedIndex[1] = column and selectedIndex[2] = depth.
 For example, for a four dimesion dataset, if selectedIndex[] is {1, 2, 3},
 then dim[1] is selected as row index, dim[2] is selected as column index
 and dim[3] is selected as depth index.
 <LI>
 selectedIndex[] is also used to select dimensions for display for
 datasets with three or more dimensions. We assume that applications such
 as HDFView can only display data up to three dimensions (a 2D spreadsheet/image
 with a third dimension that the 2D spreadsheet/image is cut from). For
 dataset with more than three dimensions, we need selectedIndex[] to store
 which three dimensions are chosen for display.
 For example, for a four dimesion dataset, if selectedIndex[] = {1, 2, 3},
 then dim[1] is selected as row index, dim[2] is selected as column index
 and dim[3] is selected as depth index. dim[0] is not selected. Its location
 is fixed at 0 by default.
 </OL>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectedStride"><!-- --></A><H3>
selectedStride</H3>
<PRE>
protected long[] <B>selectedStride</B></PRE>
<DL>
<DD>The number of elements to move from the start location in each dimension.
  For example, if selectedStride[0] = 2, every other data point is selected
  along dim[0].
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="chunkSize"><!-- --></A><H3>
chunkSize</H3>
<PRE>
protected long[] <B>chunkSize</B></PRE>
<DL>
<DD>The array of dimension sizes for a chunk.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="compression"><!-- --></A><H3>
compression</H3>
<PRE>
protected java.lang.String <B>compression</B></PRE>
<DL>
<DD>The GZIP compression level.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="datatype"><!-- --></A><H3>
datatype</H3>
<PRE>
protected <A HREF="../../../ncsa/hdf/object/Datatype.html" title="class in ncsa.hdf.object">Datatype</A> <B>datatype</B></PRE>
<DL>
<DD>The datatype object of the dataset.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="dimNames"><!-- --></A><H3>
dimNames</H3>
<PRE>
protected java.lang.String[] <B>dimNames</B></PRE>
<DL>
<DD>Array of strings that represent the dimension names.
 It is null if dimension names do not exist.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="convertByteToString"><!-- --></A><H3>
convertByteToString</H3>
<PRE>
protected boolean <B>convertByteToString</B></PRE>
<DL>
<DD>Flag to indicate if the byte[] array is converted to strings
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="isDataLoaded"><!-- --></A><H3>
isDataLoaded</H3>
<PRE>
protected boolean <B>isDataLoaded</B></PRE>
<DL>
<DD>Flag to indicate if data values are loaded into memory.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nPoints"><!-- --></A><H3>
nPoints</H3>
<PRE>
protected long <B>nPoints</B></PRE>
<DL>
<DD>The number of data points in the memory buffer.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="originalBuf"><!-- --></A><H3>
originalBuf</H3>
<PRE>
protected java.lang.Object <B>originalBuf</B></PRE>
<DL>
<DD>The data buffer that contains the raw data directly reading from 
 file (before any data conversion).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="convertedBuf"><!-- --></A><H3>
convertedBuf</H3>
<PRE>
protected java.lang.Object <B>convertedBuf</B></PRE>
<DL>
<DD>The array that holds the converted data of unsigned C-type integers.
 <p>
 For example, Suppose that the original data is an array of unsigned 16-bit 
 short integers. Since Java does not support unsigned integer, the data is
 converted to an array of 32-bit singed integer. In that case, the converted
 buffer is the array of 32-bit singed integer.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="enumConverted"><!-- --></A><H3>
enumConverted</H3>
<PRE>
protected boolean <B>enumConverted</B></PRE>
<DL>
<DD>Flag to indicate if the enum data is converted to strings.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Dataset(ncsa.hdf.object.FileFormat, java.lang.String, java.lang.String)"><!-- --></A><H3>
Dataset</H3>
<PRE>
public <B>Dataset</B>(<A HREF="../../../ncsa/hdf/object/FileFormat.html" title="class in ncsa.hdf.object">FileFormat</A>&nbsp;theFile,
               java.lang.String&nbsp;name,
               java.lang.String&nbsp;path)</PRE>
<DL>
<DD>Constructs a Dataset object with a given file, name and path.
 <p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>theFile</CODE> - the file that contains the dataset.<DD><CODE>name</CODE> - the name of the Dataset, e.g. "dset1".<DD><CODE>path</CODE> - the full group path of this Dataset, e.g. "/arrays/".</DL>
</DL>
<HR>

<A NAME="Dataset(ncsa.hdf.object.FileFormat, java.lang.String, java.lang.String, long[])"><!-- --></A><H3>
Dataset</H3>
<PRE>
public <B>Dataset</B>(<A HREF="../../../ncsa/hdf/object/FileFormat.html" title="class in ncsa.hdf.object">FileFormat</A>&nbsp;theFile,
               java.lang.String&nbsp;name,
               java.lang.String&nbsp;path,
               long[]&nbsp;oid)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Not for public use in the future. <br>
 Using <A HREF="../../../ncsa/hdf/object/Dataset.html#Dataset(ncsa.hdf.object.FileFormat, java.lang.String, java.lang.String)"><CODE>Dataset(FileFormat, String, String)</CODE></A></I>
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>()</PRE>
<DL>
<DD>Clears memory held by the dataset, such as data buffer.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="init()"><!-- --></A><H3>
init</H3>
<PRE>
public abstract void <B>init</B>()</PRE>
<DL>
<DD>Retrieves datatype and dataspace information from file and sets the dataset in memory.
 <p>
 The init() is designed to support lazy operation in dataset object. 
 When a data object is retrieved from file, the datatype, dataspace 
 and raw data are not loaded into memory. When it is asked 
 to read the raw data from file, init() is first called to get the datatype 
 and dataspace information, then load the raw data from file.
 <p>
 init() is also used to reset selection of a dataset (start, stride and count)
 to the default, which is the entire dataset for 1D or 2D datasets. In the
 following example, init() at step 1) retrieve datatype and dataspace information
 from file. getData() at step 3) read only one data point. init() at step 4) reset
 the selection to the whole dataset. getData() at step 4) reads the values of
 whole dataset into memory.
 
 <pre>
            dset = (Dataset)file.get(NAME_DATASET);

            // 1) get datatype and dataspace information from file
            dset.init();
            rank = dset.getRank(); // rank = 2, a 2D dataset
            count = dset.getSelectedDims();
            start = dset.getStartDims();
            dims = dset.getDims();

            // 2) select only one data point
            for (int i=0; i<rank; i++) {
                start[0] = 0;
                count[i] = 1;
            }

            // 3)  read one data point
            data = dset.getData();

            // 4)  reset to select the whole dataset
            dset.init();

            // 5) clean the memory data buffer
            dset.clearData();

            // 6) Read the whole dataset
            data = dset.getData();
        </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRank()"><!-- --></A><H3>
getRank</H3>
<PRE>
public final int <B>getRank</B>()</PRE>
<DL>
<DD>Returns the rank (number of dimensions) of the dataset.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of dimensions of the dataset.</DL>
</DD>
</DL>
<HR>

<A NAME="getDims()"><!-- --></A><H3>
getDims</H3>
<PRE>
public final long[] <B>getDims</B>()</PRE>
<DL>
<DD>Returns the array that contins the dimension sizes of the dataset.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the dimension sizes of the dataset.</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxDims()"><!-- --></A><H3>
getMaxDims</H3>
<PRE>
public final long[] <B>getMaxDims</B>()</PRE>
<DL>
<DD>Returns the array that contins the max dimension sizes of the dataset.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the max dimension sizes of the dataset.</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedDims()"><!-- --></A><H3>
getSelectedDims</H3>
<PRE>
public final long[] <B>getSelectedDims</B>()</PRE>
<DL>
<DD>Returns the dimension sizes of the selected subset.
 <p>
 The SelectedDims is the number of data points of the selected subset. Applications
 can use this array to change the size of selected subset.
  
 The select size must be less than or equal to the current dimension size.
 Combined with the starting position, selected sizes and stride, the subset of a
 rectangle selection is fully defined.
 <p>
 For example, a 4 X 5 dataset
 <pre>
     0,  1,  2,  3,  4
    10, 11, 12, 13, 14
    20, 21, 22, 23, 24
    30, 31, 32, 33, 34
 long[] dims = {4, 5};
 long[] startDims = {1, 2};
 long[] selectedDims = {3, 3};
 long[] selectedStride = {1, 1};

 then the following subset is selected by the startDims and selectedDims
     12, 13, 14
     22, 23, 24
     32, 33, 34
 </pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the dimension sizes of the selected subset.</DL>
</DD>
</DL>
<HR>

<A NAME="getStartDims()"><!-- --></A><H3>
getStartDims</H3>
<PRE>
public final long[] <B>getStartDims</B>()</PRE>
<DL>
<DD>Returns the starting position of a selected subset.
 <p>
 Applications can use this array to change the starting position of a selection. 
 Combined with the selected dimensions, selected sizes and stride, the subset of a
 rectangle selection is fully defined.
 <p>
 For example, a 4 X 5 dataset
 <pre>
     0,  1,  2,  3,  4
    10, 11, 12, 13, 14
    20, 21, 22, 23, 24
    30, 31, 32, 33, 34
 long[] dims = {4, 5};
 long[] startDims = {1, 2};
 long[] selectedDims = {3, 3};
 long[] selectedStride = {1, 1};

 then the following subset is selected by the startDims and selectedDims
     12, 13, 14
     22, 23, 24
     32, 33, 34
 </pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the starting position of a selected subset.</DL>
</DD>
</DL>
<HR>

<A NAME="getStride()"><!-- --></A><H3>
getStride</H3>
<PRE>
public final long[] <B>getStride</B>()</PRE>
<DL>
<DD>Returns the selectedStride of the selected dataset.
 <p>
 Applications can use this array to change how many elements to move in each dimension.
 
 Combined with the starting position and selected sizes, the subset of a
 rectangle selection is defined.
 <p>
 For example, a 4 X 5 dataset
 <pre>
     0,  1,  2,  3,  4
    10, 11, 12, 13, 14
    20, 21, 22, 23, 24
    30, 31, 32, 33, 34
 long[] dims = {4, 5};
 long[] startDims = {0, 0};
 long[] selectedDims = {2, 2};
 long[] selectedStride = {2, 3};

 then the following subset is selected by the startDims and selectedDims
     0,   3
     20, 23
 </pre>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setConvertByteToString(boolean)"><!-- --></A><H3>
setConvertByteToString</H3>
<PRE>
public final void <B>setConvertByteToString</B>(boolean&nbsp;b)</PRE>
<DL>
<DD>Sets the flag that indicates if a byte array is converted to a string array.
 <p>
 In a string dataset, the raw data from file is stored in a byte array.
 By default, this byte array is converted to an array of strings.
 For a large dataset (e.g. more than one million strings), the converson takes 
 a long time and requires a lot of memory space to store the strings. At some 
 applications, such a conversion can be delayed. For example, A GUI application
 may convert only part of the strings that are visible to the users, not the 
 entire data array.
 <p>
 setConvertByteToString(boolean b) allows users to set the flag so that 
 applications can choose to perform the byte-to-string conversion or not. 
 If the flag is set to false, the getData() returns a array of byte instead
 of an array of strings.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - convert bytes to strings if b is true; otherwise,
          if false, do not convert bytes to strings.</DL>
</DD>
</DL>
<HR>

<A NAME="getConvertByteToString()"><!-- --></A><H3>
getConvertByteToString</H3>
<PRE>
public final boolean <B>getConvertByteToString</B>()</PRE>
<DL>
<DD>Returns the flag that indicates if a byte array is converted to a string array..
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if byte array is converted to string; otherwise, returns false if there is no conversion.</DL>
</DD>
</DL>
<HR>

<A NAME="read()"><!-- --></A><H3>
read</H3>
<PRE>
public abstract java.lang.Object <B>read</B>()
                               throws java.lang.Exception,
                                      java.lang.OutOfMemoryError</PRE>
<DL>
<DD>Reads the data from file.
 <p>
 read() reads the data from file to a memory buffer and returns the memory buffer.
 The dataset object does not hold the memobry buffer. To store the memory buffer
 in the dataset object, one must call getData(). 
 <p>
 By default, the whole dataset is read into memory. Users can also 
 select subset to read. Subsetting is done in an implicit way.
 <p>
 <b>How to Select a Subset</b>
 <p>
 A selection is specified by three arrays: start, stride and count.
 <ol>
   <li>start:  offset of a selection
   <li>stride: determining how many elements to move in each dimension
   <li>count:  number of elements to select in each dimension
 </ol>
 getStartDims(), getStartDims() and getSelectedDims() returns the start, 
 stride and count arrays respectively. Applications can make a selection 
 by changing the values of the arrays.
 <p>
 The following example shows how to make a subset. In the example, the 
 dataset is a 4-dimensional array of [200][100][50][10], i.e.
 dims[0]=200; dims[1]=100; dims[2]=50; dims[3]=10; <br>
 We want to select every other data point in dims[1] and dims[2]
 <pre>
         int rank = dataset.getRank();   // number of dimension of the dataset
         long[] dims = dataset.getDims(); // the dimension sizes of the dataset
         long[] selected = dataset.getSelectedDims(); // the selected size of the dataet
         long[] start = dataset.getStartDims(); // the off set of the selection
         long[] stride = dataset.getStride(); // the stride of the dataset
         int[]  selectedIndex = dataset.getSelectedIndex(); // the selected dimensions for display

         // select dim1 and dim2 as 2D data for display,and slice through dim0
         selectedIndex[0] = 1;
         selectedIndex[1] = 2;
         selectedIndex[1] = 0;

         // reset the selection arrays
         for (int i=0; i&lt;rank; i++) {
             start[i] = 0;
             selected[i] = 1;
             stride[i] = 1;
        }

        // set stride to 2 on dim1 and dim2 so that every other data points are selected.
        stride[1] = 2;
        stride[2] = 2;

        // set the selection size of dim1 and dim2
        selected[1] = dims[1]/stride[1];
        selected[2] = dims[1]/stride[2];

        // when dataset.getData() is called, the slection above will be used since
        // the dimension arrays are passed by reference. Changes of these arrays
        // outside the dataset object directly change the values of these array
        // in the dataset object.
 </pre>
 <p>
 For ScalarDS, the memory data buffer is an one-dimensional array of byte,
 short, int, float, double or String type based on the datatype of the 
 dataset. 
 <p>
 For CompoundDS, the meory data object is an java.util.List object. Each
 element of the list is a data array that corresponds to a compound field. 
 <p>
 For example, if compound dataset "comp" has the following nested structure,
 and memeber datatypes
 <pre>
 comp --> m01 (int)
 comp --> m02 (float)
 comp --> nest1 --> m11 (char)
 comp --> nest1 --> m12 (String)
 comp --> nest1 --> nest2 --> m21 (long)
 comp --> nest1 --> nest2 --> m22 (double)
 </pre>
 getData() returns a list of six arrays: {int[], float[], char[], Stirng[], long[] and double[]}.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the data read from file.
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE>
<DD><CODE>java.lang.OutOfMemoryError</CODE><DT><B>See Also:</B><DD><CODE>#getData()}</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="readBytes()"><!-- --></A><H3>
readBytes</H3>
<PRE>
public abstract byte[] <B>readBytes</B>()
                          throws java.lang.Exception</PRE>
<DL>
<DD>Reads the raw data of the dataset from file to a byte array.
 <p>
 readBytes() reads raw data to an array of bytes instead of array of its datatype.
 For example, for an one-dimension 32-bit integer dataset of size 5,
 the readBytes() returns of a byte array of size 20 instead of an int array
 of 5.
 <p>
 readBytes() can be used to copy data from one dataset to another efficiently 
 because the raw data is not converted to its native type, it saves memory 
 space and CPU time.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the byte array of the raw data.
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="write(java.lang.Object)"><!-- --></A><H3>
write</H3>
<PRE>
public abstract void <B>write</B>(java.lang.Object&nbsp;buf)
                    throws java.lang.Exception</PRE>
<DL>
<DD>Writes a memory buffer to the dataset in file.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf</CODE> - the data to write
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="write()"><!-- --></A><H3>
write</H3>
<PRE>
public final void <B>write</B>()
                 throws java.lang.Exception</PRE>
<DL>
<DD>Writes the memory buffer of this dataset to file.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="copy(ncsa.hdf.object.Group, java.lang.String, long[], java.lang.Object)"><!-- --></A><H3>
copy</H3>
<PRE>
public abstract <A HREF="../../../ncsa/hdf/object/Dataset.html" title="class in ncsa.hdf.object">Dataset</A> <B>copy</B>(<A HREF="../../../ncsa/hdf/object/Group.html" title="class in ncsa.hdf.object">Group</A>&nbsp;pgroup,
                             java.lang.String&nbsp;name,
                             long[]&nbsp;dims,
                             java.lang.Object&nbsp;data)
                      throws java.lang.Exception</PRE>
<DL>
<DD>Creates a new dataset and writes the data buffer to the new dataset.
 <p>
 This function allows applications to create a new dataset for a given
 data buffer. For example, users can select a specific interesting part 
 from a large image and create a new image with the selection.
 <p>
 The new dataset retains the datatype and dataset creation properties of
 this dataset.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pgroup</CODE> - the group which the dataset is copied to.<DD><CODE>name</CODE> - the name of the new dataset.<DD><CODE>dims</CODE> - the dimension sizes of the the new dataset.<DD><CODE>data</CODE> - the data values of the subset to be copied.
<DT><B>Returns:</B><DD>the new dataset.
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getDatatype()"><!-- --></A><H3>
getDatatype</H3>
<PRE>
public abstract <A HREF="../../../ncsa/hdf/object/Datatype.html" title="class in ncsa.hdf.object">Datatype</A> <B>getDatatype</B>()</PRE>
<DL>
<DD>Returns the datatype object of the dataset.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the datatype object of the dataset.</DL>
</DD>
</DL>
<HR>

<A NAME="getData()"><!-- --></A><H3>
getData</H3>
<PRE>
public final java.lang.Object <B>getData</B>()
                               throws java.lang.Exception,
                                      java.lang.OutOfMemoryError</PRE>
<DL>
<DD>Returns the data buffer of the dataset in memory.
 <p>
 If data is already loaded into memory, returns the data; otherwise, 
  calls read() to read data from file into a memory buffer and returns
  the memory buffer.
  <p>
 <p>
 By default, the whole dataset is read into memory. Users can also 
 select subset to read. Subsetting is done in an implicit way.
 <p>
 <b>How to Select a Subset</b>
 <p>
 A selection is specified by three arrays: start, stride and count.
 <ol>
   <li>start:  offset of a selection
   <li>stride: determining how many elements to move in each dimension
   <li>count:  number of elements to select in each dimension
 </ol>
 getStartDims(), getStartDims() and getSelectedDims() returns the start, 
 stride and count arrays respectively. Applications can make a selection 
 by changing the values of the arrays.
 <p>
 The following example shows how to make a subset. In the example, the 
 dataset is a 4-dimensional array of [200][100][50][10], i.e.
 dims[0]=200; dims[1]=100; dims[2]=50; dims[3]=10; <br>
 We want to select every other data point in dims[1] and dims[2]
 <pre>
         int rank = dataset.getRank();   // number of dimension of the dataset
         long[] dims = dataset.getDims(); // the dimension sizes of the dataset
         long[] selected = dataset.getSelectedDims(); // the selected size of the dataet
         long[] start = dataset.getStartDims(); // the off set of the selection
         long[] stride = dataset.getStride(); // the stride of the dataset
         int[]  selectedIndex = dataset.getSelectedIndex(); // the selected dimensions for display

         // select dim1 and dim2 as 2D data for display,and slice through dim0
         selectedIndex[0] = 1;
         selectedIndex[1] = 2;
         selectedIndex[1] = 0;

         // reset the selection arrays
         for (int i=0; i&lt;rank; i++) {
             start[i] = 0;
             selected[i] = 1;
             stride[i] = 1;
        }

        // set stride to 2 on dim1 and dim2 so that every other data points are selected.
        stride[1] = 2;
        stride[2] = 2;

        // set the selection size of dim1 and dim2
        selected[1] = dims[1]/stride[1];
        selected[2] = dims[1]/stride[2];

        // when dataset.getData() is called, the slection above will be used since
        // the dimension arrays are passed by reference. Changes of these arrays
        // outside the dataset object directly change the values of these array
        // in the dataset object.
 </pre>
 <p>
 For ScalarDS, the memory data buffer is an one-dimensional array of byte,
 short, int, float, double or String type based on the datatype of the 
 dataset. 
 <p>
 For CompoundDS, the meory data object is an java.util.List object. Each
 element of the list is a data array that corresponds to a compound field. 
 <p>
 For example, if compound dataset "comp" has the following nested structure,
 and memeber datatypes
 <pre>
 comp --> m01 (int)
 comp --> m02 (float)
 comp --> nest1 --> m11 (char)
 comp --> nest1 --> m12 (String)
 comp --> nest1 --> nest2 --> m21 (long)
 comp --> nest1 --> nest2 --> m22 (double)
 </pre>
 getData() returns a list of six arrays: {int[], float[], char[], Stirng[], long[] and double[]}.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the memory buffer of the dataset.
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE>
<DD><CODE>java.lang.OutOfMemoryError</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setData(java.lang.Object)"><!-- --></A><H3>
setData</H3>
<PRE>
public final void <B>setData</B>(java.lang.Object&nbsp;d)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Not for public use in the future.
 <p>
 setData() is not safe to use because it changes memory buffer
 of the dataset object. Dataset operation such as write/read 
 will fail if the buffer type or size is changed.</I>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearData()"><!-- --></A><H3>
clearData</H3>
<PRE>
public void <B>clearData</B>()</PRE>
<DL>
<DD>Clears the data buffer in memory and to force the next read() to load data from file.
 <p>
 The function read() loads data from file into memory only if 
 the data is not read. If data is already in memory, read() just
 returns the memory buffer. Sometimes we want to force read()
 to re-read data from file. For example, when the selection is 
 changed, we need to re-read the data. 
  
 clearData() clears the current memory buffer and force the read()
 to load the data from file.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../ncsa/hdf/object/Dataset.html#getData()"><CODE>getData()</CODE></A>, 
<A HREF="../../../ncsa/hdf/object/Dataset.html#read()"><CODE>read()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getHeight()"><!-- --></A><H3>
getHeight</H3>
<PRE>
public final int <B>getHeight</B>()</PRE>
<DL>
<DD>Returns the dimension size of the vertical axis.
 
 <p> 
  This function is used by GUI applications such as HDFView. GUI applications
  display a dataset in a 2D table or 2D image. The display order is specified 
  by the index array of selectedIndex as follow:
  <dl>
  <dt> selectedIndex[0] -- height</dt>
    <dd> The vertical axis </dd>
  <dt> selectedIndex[1] -- width </dt>
    <dd> The horizontal axis </dd>
  <dt> selectedIndex[2] -- depth </dt>
    <dd> The depth axis is used for 3 or more dimensional datasets. </dd>
  </dl>
  Applications can use getSelectedIndex() to access and change the display
  order. For example, in a 2D dataset of 200x50 (dim0=200, dim1=50), the following
  code will set the height=200 and width=50.
  <pre>
      long[] selectedIndex = dataset.getSelectedIndex();
      selectedIndex[0] = 0;
      selectedIndex[1] = 1;
  </pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the size of dimension of the vertical axis.<DT><B>See Also:</B><DD><A HREF="../../../ncsa/hdf/object/Dataset.html#getSelectedIndex()"><CODE>getSelectedIndex()</CODE></A>, 
<A HREF="../../../ncsa/hdf/object/Dataset.html#getWidth()"><CODE>getWidth()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getWidth()"><!-- --></A><H3>
getWidth</H3>
<PRE>
public final int <B>getWidth</B>()</PRE>
<DL>
<DD>Returns the size of dimension of the horizontal axis.
 
 <p> 
  This function is used by GUI applications such as HDFView. GUI applications
  display dataset a 2D Table or 2D Image. The display order is specified 
  by the index array of selectedIndex as follow:
  <dl>
  <dt> selectedIndex[0] -- height</dt>
    <dd> The vertical axis </dd>
  <dt> selectedIndex[1] -- width </dt>
    <dd> The horizontal axis </dd>
  <dt> selectedIndex[2] -- depth </dt>
    <dd> The depth axis, which is used for 3 or more dimension datasets. </dd>
  </dl>
  Applications can use getSelectedIndex() to access and change the display
  order. For example, in a 2D dataset of 200x50 (dim0=200, dim1=50), the following
  code will set the height=200 and width=100.
  <pre>
      long[] selectedIndex = dataset.getSelectedIndex();
      selectedIndex[0] = 0;
      selectedIndex[1] = 1;
  </pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the size of dimension of the horizontal axis.<DT><B>See Also:</B><DD><A HREF="../../../ncsa/hdf/object/Dataset.html#getSelectedIndex()"><CODE>getSelectedIndex()</CODE></A>, 
<A HREF="../../../ncsa/hdf/object/Dataset.html#getHeight()"><CODE>getHeight()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedIndex()"><!-- --></A><H3>
getSelectedIndex</H3>
<PRE>
public final int[] <B>getSelectedIndex</B>()</PRE>
<DL>
<DD>Returns the indices of display order.
 <p>
 
 selectedIndex[] is provided for two purpose:
 <OL>
 <LI>
 selectedIndex[] is used to indicate the order of dimensions for display.
 selectedIndex[0] is for the row, selectedIndex[1] is for the column and 
 selectedIndex[2] for the depth.
 <p>
 For example, for a four dimesion dataset, if selectedIndex[] = {1, 2, 3},
 then dim[1] is selected as row index, dim[2] is selected as column index
 and dim[3] is selected as depth index.
 <LI>
 selectedIndex[] is also used to select dimensions for display for
 datasets with three or more dimensions. We assume that applications such
 as HDFView can only display data values up to three dimension (2D spreadsheet/image
 with a third dimension which the 2D spreadsheet/image is selected from). For
 dataset with more than three dimensions, we need selectedIndex[] to tell
 applications which three dimensions are chosen for display.
 <br>
 For example, for a four dimesion dataset, if selectedIndex[] = {1, 2, 3},
 then dim[1] is selected as row index, dim[2] is selected as column index
 and dim[3] is selected as depth index. dim[0] is not selected. Its location
 is fixed at 0 by default.
 </OL>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the array of the indices of display order.</DL>
</DD>
</DL>
<HR>

<A NAME="getCompression()"><!-- --></A><H3>
getCompression</H3>
<PRE>
public final java.lang.String <B>getCompression</B>()</PRE>
<DL>
<DD>Returns the string representation of compression information.
 <p>
 For example, "SZIP: Pixels per block = 8: H5Z_FILTER_CONFIG_DECODE_ENABLED".
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the string representation of compression information.</DL>
</DD>
</DL>
<HR>

<A NAME="getChunkSize()"><!-- --></A><H3>
getChunkSize</H3>
<PRE>
public final long[] <B>getChunkSize</B>()</PRE>
<DL>
<DD>Returns the array that contains the dimension sizes of the chunk of the dataset.
  Returns null if the dataset is not chunked.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the array of chunk sizes or returns null if the dataset is not chunked.</DL>
</DD>
</DL>
<HR>

<A NAME="convertFromUnsignedC(java.lang.Object)"><!-- --></A><H3>
convertFromUnsignedC</H3>
<PRE>
public static java.lang.Object <B>convertFromUnsignedC</B>(java.lang.Object&nbsp;data_in)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Not for public use in the future. <br>
 Using <A HREF="../../../ncsa/hdf/object/Dataset.html#convertFromUnsignedC(java.lang.Object, java.lang.Object)"><CODE>convertFromUnsignedC(Object, Object)</CODE></A></I>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="convertFromUnsignedC(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
convertFromUnsignedC</H3>
<PRE>
public static java.lang.Object <B>convertFromUnsignedC</B>(java.lang.Object&nbsp;data_in,
                                                    java.lang.Object&nbsp;data_out)</PRE>
<DL>
<DD>Converts one-dimension array of unsigned C-type integers to a new array of appropriate Java integer in memory.
 <p>
 Since Java does not support unsigned integer, values of unsigned C-type integers must
 be converted into its appropriate Java integer. Otherwise, the data value
 will not displayed correctly. For example, if an unsigned C byte, x = 200,
 is stored into an Java byte y, y will be -56 instead of the correct value of 200.
 <p>
 Unsigned C integers are upgrade to Java integers according to the following table:
 <TABLE CELLSPACING=0 BORDER=1 CELLPADDING=5 WIDTH=400>
     <caption><b>Mapping Unsigned C Integers to Java Integers</b></caption>
     <TR> <TD><B>Unsigned C Integer</B></TD> <TD><B>JAVA Intege</B>r</TD> </TR>
     <TR> <TD>unsigned byte</TD> <TD>signed short</TD> </TR>
     <TR> <TD>unsigned short</TD> <TD>signed int</TD> </TR>
     <TR> <TD>unsigned int</TD> <TD>signed long</TD> </TR>
     <TR> <TD>unsigned long</TD> <TD>signed long</TD> </TR>
 </TABLE>
 <strong>NOTE: this conversion cannot deal with unsigned 64-bit integers. Therefore,
       the values of unsigned 64-bit dataset may be wrong in Java application</strong>.
 <p>
 If memory data of unsigned integers is converted by convertFromUnsignedC(),
 convertToUnsignedC() must be called to convert the data back to unsigned C before
 data is written into file.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data_in</CODE> - the input 1D array of the unsigned C-type integers.<DD><CODE>data_out</CODE> - the output converted (or upgraded) 1D array of Java integers.
<DT><B>Returns:</B><DD>the upgraded 1D array of Java integers.<DT><B>See Also:</B><DD><A HREF="../../../ncsa/hdf/object/Dataset.html#convertToUnsignedC(java.lang.Object, java.lang.Object)"><CODE>convertToUnsignedC(Object, Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="convertToUnsignedC(java.lang.Object)"><!-- --></A><H3>
convertToUnsignedC</H3>
<PRE>
public static java.lang.Object <B>convertToUnsignedC</B>(java.lang.Object&nbsp;data_in)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Not for public use in the future. <br>
 Using <A HREF="../../../ncsa/hdf/object/Dataset.html#convertToUnsignedC(java.lang.Object, java.lang.Object)"><CODE>convertToUnsignedC(Object, Object)</CODE></A></I>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="convertToUnsignedC(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
convertToUnsignedC</H3>
<PRE>
public static java.lang.Object <B>convertToUnsignedC</B>(java.lang.Object&nbsp;data_in,
                                                  java.lang.Object&nbsp;data_out)</PRE>
<DL>
<DD>Converts the array of converted unsigned integer back to unsigned C-type integer data in memory.
 <p>
 If memory data of unsigned integers is converted by convertFromUnsignedC(),
 convertToUnsignedC() must be called to convert the data back to unsigned C before
 data is written into file.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data_in</CODE> - the input array of the Java integer.<DD><CODE>data_out</CODE> - the output array of the unsigned C-type integer.
<DT><B>Returns:</B><DD>the converted data of unsigned C-type integer array.<DT><B>See Also:</B><DD><A HREF="../../../ncsa/hdf/object/Dataset.html#convertFromUnsignedC(java.lang.Object, java.lang.Object)"><CODE>convertFromUnsignedC(Object, Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="byteToString(byte[], int)"><!-- --></A><H3>
byteToString</H3>
<PRE>
public static final java.lang.String[] <B>byteToString</B>(byte[]&nbsp;bytes,
                                                    int&nbsp;length)</PRE>
<DL>
<DD>Converts an array of bytes into an array of Strings for a fixed string dataset.
 <p>
 A C-string is an array of chars while an Java String is an object.
 When a string dataset is read into Java application, the data is
 stored in an array of Java bytes. byteToString() is used to convert
 the array of bytes into array of Java strings so that applications
 can display and modify the data content.
 <p>
 For example, the content of a two element C string dataset is
 {"ABC", "abc"}. Java applications will read the data into an
 byte array of {65, 66, 67, 97, 98, 99). byteToString(bytes, 3)
 returns an array of Java String of strs[0]="ABC", and strs[1]="abc".
 <p>
 If memory data of strings is converted to Java Strings, stringToByte()
 must be called to convert the memory data back to byte array before data
 is written to file.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bytes</CODE> - the array of bytes to convert.<DD><CODE>length</CODE> - the length of string.
<DT><B>Returns:</B><DD>the array of Java String.<DT><B>See Also:</B><DD><A HREF="../../../ncsa/hdf/object/Dataset.html#stringToByte(java.lang.String[], int)"><CODE>stringToByte(String[], int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stringToByte(java.lang.String[], int)"><!-- --></A><H3>
stringToByte</H3>
<PRE>
public static final byte[] <B>stringToByte</B>(java.lang.String[]&nbsp;strings,
                                        int&nbsp;length)</PRE>
<DL>
<DD>Converts a string array into an array of bytes for a fixed string dataset.
 <p>
 If memory data of strings is converted to Java Strings, stringToByte()
 must be called to convert the memory data back to byte array before data
 is written to file.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>strings</CODE> - the array of string.<DD><CODE>length</CODE> - the length of string.
<DT><B>Returns:</B><DD>the array of bytes.<DT><B>See Also:</B><DD><A HREF="../../../ncsa/hdf/object/Dataset.html#byteToString(byte[], int)"><CODE>byteToString(byte[] bytes, int length)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDimNames()"><!-- --></A><H3>
getDimNames</H3>
<PRE>
public final java.lang.String[] <B>getDimNames</B>()</PRE>
<DL>
<DD>Returns the array of strings that represent the dimension names.
 Returns null if there is no dimension name.
 <p>
 Some datasets have pre-defined names for each dimension such as "Latitude"
 and "Longitude". getDimNames() returns these pre-defined names.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the names of dimensions, or null if there is no dimension name.</DL>
</DD>
</DL>
<HR>

<A NAME="isString(int)"><!-- --></A><H3>
isString</H3>
<PRE>
public boolean <B>isString</B>(int&nbsp;tid)</PRE>
<DL>
<DD>Checks if a given datatype is a string. Sub-classes must replace this
 default implementation.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tid</CODE> - The data type identifier.
<DT><B>Returns:</B><DD>true if the datatype is a string; otherwise returns false.</DL>
</DD>
</DL>
<HR>

<A NAME="getSize(int)"><!-- --></A><H3>
getSize</H3>
<PRE>
public int <B>getSize</B>(int&nbsp;tid)</PRE>
<DL>
<DD>Returns the size in bytes of a given datatype. 
 Sub-classes must replace this default implementation.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tid</CODE> - The data type identifier.
<DT><B>Returns:</B><DD>The size of the datatype</DL>
</DD>
</DL>
<HR>

<A NAME="isEnumConverted()"><!-- --></A><H3>
isEnumConverted</H3>
<PRE>
public boolean <B>isEnumConverted</B>()</PRE>
<DL>
<DD>Get flag that indicate if enum data is converted to strings.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the enumConverted</DL>
</DD>
</DL>
<HR>

<A NAME="setEnumConverted(boolean)"><!-- --></A><H3>
setEnumConverted</H3>
<PRE>
public void <B>setEnumConverted</B>(boolean&nbsp;b)</PRE>
<DL>
<DD>Set flag that indicate if enum data is converted to strings.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>b</CODE> - the enumConverted to set</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../ncsa/hdf/object/DataFormat.html" title="interface in ncsa.hdf.object"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../ncsa/hdf/object/Datatype.html" title="class in ncsa.hdf.object"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?ncsa/hdf/object/Dataset.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Dataset.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
