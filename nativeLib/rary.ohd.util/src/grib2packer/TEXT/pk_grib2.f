      SUBROUTINE PK_G2MDL(KFILDO,jmax,jmin,lbit,nov,misslx,a,ia,
     1                    newbox,newboxp,AIN,IAIN,NX,NY,IDAT,NIDAT,
     2                    RDAT,NRDAT,IS0,NS0,IS1,NS1,IS3,NS3,IS4,NS4,
     3                    IS5,NS5,IS6,NS6,IS7,NS7,IB,IBITMAP,IPACK,
     4                    ND5,MISSP,XMISSP,MISSS,XMISSS,NEW,MINPK,
     5                    ICLEAN,L3264B,JER,NDJER,KJER)
C
C        AUGUST   1999   GLAHN/LAWRENCE  GSC/TDL     ORIGINAL CODING
C        FEBRUARY 2001   LAWRENCE    UPDATED THIS ROUTINE'S 
C                                    PROLOGUE.
C        NOVEMBER 2001   GLAHN       ADDED OPTIONAL WRITING OF MESSAGE
C                                    LENGTH TO KFILDO
C        FEBRUARY 2002   GLAHN       ADDED IS6( ), NS6( ) TO CALL TO 
C                                    PK_SECT7; CHANGED CALL METHOD AND
C                                    SEQUENCE FOR PK_SECT3
C
C        PURPOSE
C           THIS UTILITY PACKS A GRIDDED DATA FIELD ACCORDING TO THE
C           RULES AND STRUCTURE PUT FORTH IN THE GRIB VERSION 2 
C           (GRIB2) DOCUMENTATION.  GRIB2 IS A DATA REPRESENTATION
C           FORM FOR GENERAL REGULARLY DISTRIBUTED INFORMATION
C           IN BINARY.  IT PROVIDES A MEANS OF COMPRESSING AND
C           ENCRYPTING DATA SO AS TO MAKE ITS TRANSMISSION MORE
C           EFFICIENT.  IT IS RECOMMENDED THAT THE USER OF THIS
C           ROUTINE REVIEW THE EXTERNAL DOCUMENTATION THAT 
C           EXPLAINS WHAT GRIB2 IS AND HOW TO USE IT.
C
C           THERE ARE EIGHT MANDATORY AND ONE OPTIONAL SECTIONS
C           CONTAINED WITHIN A GRIB2 MESSAGE.  THESE SECTIONS ARE
C
C              SECTION 0 - THE INDICATOR SECTION
C              SECTION 1 - THE IDENTIFICATION SECTION
C              SECTION 2 - THE LOCAL USE SECTION (OPTIONAL)
C              SECTION 3 - THE GRID DEFINITION SECTION
C              SECTION 4 - THE PRODUCT DEFINITION SECTION
C              SECTION 5 - THE DATA REPRESENTATION SECTION
C              SECTION 6 - THE BIT-MAP SECTION
C              SECTION 7 - THE DATA SECTION
C              SECTION 8 - THE END SECTION
C
C           SECTION 0, THE INDICATOR SECTION, CONTAINS GRIB2
C           DISCIPLINE, EDITION, AND MESSAGE LENGTH INFORMATION.
C
C           SECTION 1, THE IDENTIFICATION SECTION, CONTAINS DATA
C           THAT DESCRIBES CHARACTERISTICS THAT APPLY TO ALL OF THE
C           PROCESSED DATA IN THE GRIB2 MESSAGE.
C
C           SECTION 2, THE LOCAL USE SECTION, CONTAINS SUPPLEMENTAL
C           INFORMATION FOR LOCAL USE BY THE ORIGINATING CENTERS.
C           THIS SECTION IS OPTIONAL; IT DOES NOT NEED TO BE INCLUDED
C           IN THE GRIB2 MESSAGE.
C
C           SECTION 3, THE GRID DEFINITION SECTION, DESCRIBES THE
C           GEOMETRY OF THE VALUES WITHIN A PLANE DESCRIBED BY
C           TWO FIXED COORDINATES.
C
C           SECTION 4, THE PRODUCT DEFINITION SECTION, PROVIDES A
C           DESCRIPTION OF THE DATA PACKED WITHIN SECTION 7.
C
C           SECTION 5, THE DATA REPRESENTATION SECTION, DESCRIBES
C           WHAT METHOD IS USED TO COMPRESS THE DATA IN SECTION 7.
C
C           SECTION 6, THE BIT-MAP SECTION, CONTAINS A BIT-MAP WHICH
C           INDICATES THE PRESENCE OR ABSENCE OF DATA AT EACH GRID
C           POINT.  A BIT-MAP IS ONLY APPLICABLE TO THE SIMPLE
C           AND COMPLEX PACKING METHODS.  A BIT-MAP DOES NOT
C           APPLY TO COMPLEX PACKING WITH SPATIAL DIFFERENCES.
C
C           SECTION 7, THE DATA SECTION, CONTAINS THE PACKED DATA
C           VALUES.
C
C           SECTION 8, THE END SECTION, CONTAINS THE STRING "7777"
C           INDICATING THE END OF THE GRIB2 MESSAGE.
C
C           SECTIONS 3, 4, 5, AND 7 PROVIDE A VARIETY OF TEMPLATES
C           THAT DESCRIBE AND DEFINE THE GRIDDED PRODUCT
C           CONTAINED WITHIN THE GRIB2 MESSAGE.  THIS GRIB2 PACKER
C           DOES NOT SUPPORT ALL OF THE TEMPLATES PROVIDED IN GRIB2.
C           THE MORE COMMONLY USED TEMPLATES ARE SUPPORTED, AND
C           THIS SOFTWARE CAN BE EASILY EXTENDED IN THE FUTURE TO
C           ACCOMMODATE ADDITIONAL TEMPLATES AS THE NEED ARISES.
C
C           THE SECTION 3 GRID DEFINITION TEMPLATES CURRENTLY
C           RECOGNIZED BY THIS PACKER ARE:
C              TEMPLATE 3.0   EQUIDISTANT CYLINDRICAL LATITUDE/
C                             LONGITUDE
C              TEMPLATE 3.10  MERCATOR
C              TEMPLATE 3.20  POLAR STEREOGRAPHIC
C              TEMPLATE 3.30  LAMBERT
C              TEMPLATE 3.90  ORTHOGRAPHIC SPACE VIEW
C              TEMPLATE 3.110 EQUATORIAL AZIMUTHAL EQUIDISTANT
C              TEMPLATE 3.120 AZIMUTH-RANGE (RADAR)
C
C           THE SECTION 4 PRODUCT DEFINITION TEMPLATES CURRENTLY
C           RECOGNIZED BY THIS PACKER ARE:
C              TEMPLATE 4.0  ANALYSIS OR FORECAST AT A LEVEL AND POINT
C              TEMPLATE 4.1  INDIVIDUAL EMSEMBLE
C              TEMPLATE 4.2  DERIVED FORECAST BASED ON ENSEMBLES
C              TEMPLATE 4.8  AVERAGE, ACCUMULATION, EXTREMES
C              TEMPLATE 4.20 RADAR
C              TEMPLATE 4.30 SATELLITE
C
C           THE SECTION 5 DATA REPRESENTATION TEMPLATES CURRENTLY
C           RECOGNIZED BY THIS PACKER ARE:
C              TEMPLATE 5.0  SIMPLE PACKING
C              TEMPLATE 5.2  COMPLEX PACKING
C              TEMPLATE 5.3  COMPLEX PACKING WITH SPATIAL DIFFERENCING
C
C           THE SECTION 7 DATA TEMPLATES CURRENTLY RECOGNIZED BY THIS
C           PACKER ARE:
C              TEMPLATE 7.0  SIMPLE PACKING
C              TEMPLATE 7.2  COMPLEX PACKING
C              TEMPLATE 7.3  COMPLEX PACKING AND SPATIAL DIFFERENCING
C
C           THE USER SUPPLIES THE DATA FOR THE SECTIONS OF THE GRIB2
C           MESSAGE THROUGH ARRAYS IS0( ), IS1( ), IS3( ),
C           IS4( ), IS5( ), IS6( ), AND IS7( ) WHICH CORRESPOND
C           TO SECTIONS 0, 1, 2, 3, 4, 5, 6, AND 7, RESPECTIVELY.
C           THE USER SHOULD REFER TO THE EXTERNAL DOCUMENTATION
C           THAT ACCOMPANIES THIS ROUTINE TO DETERMINE WHICH VALUES
C           HE NEEDS TO SUPPLY IN EACH OF THESE ARRAYS.
C
C           THE GRID OF DATA IS PASSED INTO THE PACKER USING EITHER THE
C           AIN( ) OR THE IAIN( ) ARRAYS.  THE DATA IS PASSED INTO THIS 
C           ROUTINE USING AIN( ) IF THE DATA IN THE GRID ARE FLOATING
C           POINT VALUES.  IF THE DATA IN THE GRID CONTAINS INTEGER  
C           VALUES, THEN THE DATA MUST BE PASSED INTO THIS ROUTINE
C           USING THE IAIN( ) ARRAY.
C
C           THE REPRESENTATION OF MISSING VALUES IN THE DATA FIELD
C           PLAYS AN INTEGRAL ROLE IN HOW THE DATA IS PACKED INTO
C           THE GRIB2 MESSAGE.  THE HANDLING OF MISSING VALUES IN 
C           GRIB2 DEPENDS UPON THE PACKING METHOD USED TO COMPRESS
C           THE DATA INTO SECTION 7 OF THE GRIB2 MESSAGE.
C         
C           WHEN USING THE SIMPLE PACKING METHOD, A BIT-MAP MUST BE
C           USED TO INDICATE THE LOCATIONS OF MISSING VALUES IN 
C           THE DATA FIELD.  THIS BIT-MAP IS ULTIMATELY PACKED INTO
C           SECTION 6 OF THE GRIB2 MESSAGE.  THE CORRESPONDING DATA
C           FIELD IS PACKED INTO SECTION 7 OF THE MESSAGE WITH THE
C           MISSING VALUES REMOVED.  WHEN USING THE SIMPLE PACKING
C           METHOD, THE CALLER OF THIS ROUTINE IS THE GIVEN THE 
C           OPTION OF SUPPLYING A BIT-MAP ALONG WITH THE DATA FIELD
C           WITH THE MISSING VALUES REMOVED FROM IT.  THE CALLER 
C           MAY ALSO SUPPLY THE DATA FIELD WITH THE MISSING VALUES
C           IN IT AND REQUEST THAT THE GRIB2 PACKER GENERATE A 
C           BIT-MAP FROM IT.  IF THE USER HAS A DATA FIELD THAT HAS NO
C           MISSING DATA IN IT, THEN A BIT-MAP IS NOT NEEDED AND
C           SHOULD NOT BE PACKED INTO SECTION 6 OF THE GRIB2 MESSAGE.  
C
C           THE COMPLEX AND COMPLEX WITH SPATIAL DIFFERENCING
C           PACKING METHODS ALLOW FOR THE USE OF PRIMARY
C           AND SECONDARY MISSING VALUES.  THESE PACKING METHODS
C           UTILIZE AN EFFICIENT TECHNIQUE OF PACKING THE MISSING
C           VALUES ALONG WITH THE DATA FIELD INTO SECTION 7 OF THE
C           GRIB2 MESSAGE WHICH ELIMINATES THE NEED FOR A BIT-MAP
C           IN SECTION 6.  THE MISSING VALUES ARE LEFT IN THE DATA 
C           FIELD AS IT IS PACKED.  IN ORDER FOR THIS TO WORK, THE
C           USER MUST SPECIFY THE MISSING VALUE MANAGEMENT VALUE
C           IN IS5(23).  A VALUE OF "0" INDICATES THAT THERE ARE NO
C           MISSING VALUES IN THE DATA FIELD.  A VALUE OF "1" INDICATES
C           THAT THERE MAY BE PRIMARY MISSING VALUES.  A VALUE OF "2"
C           INDICATES THAT THERE MAY BE BOTH PRIMARY AND SECONDARY
C           MISSING VALUES.  THE MISSP AND MISSS (SEE BELOW)
C           CALLING ARGUMENTS REPRESENT THE PRIMARY AND SECONDARY
C           MISSING VALUES, RESPECTIVELY, WHEN PACKING AN INTEGER
C           DATA FIELD.  THE XMISSP AND XMISSS (SEE BELOW) CALLING
C           ARGUMENTS REPRESENT THE PRIMARY AND SECONDARY MISSING
C           VALUES WHEN PACKING A FLOATING POINT DATA FIELD.
C           LIKE THE SIMPLE PACKING METHOD, THE USER HAS THE OPTION
C           TO PROVIDE A BIT-MAP AND A DATA FIELD WITH ALL OF THE
C           PRIMARY MISSING VALUES REMOVED.  HOWEVER, INSTEAD OF
C           PACKING THIS BIT-MAP INTO SECTION 6 OF THE GRIB2 MESSAGE,
C           THIS PACKER WILL USE THE BIT-MAP TO PLACE THE PRIMARY
C           MISSING VALUES BACK INTO THE DATA FIELD BEFORE PACKING
C           IT.
C
C           A GRIB2 MESSAGE MAY CONTAIN ONE OR MORE GRIDDED DATA
C           FIELDS.  WHEN PACKING MULTIPLE GRIDS INTO A GRIB2 MESSAGE
C           THE FIRST GRID MUST PROVIDE INFORMATION FOR SECTIONS 0
C           THROUGH 7 (WITH, OF COURSE, SECTION 2 BEING OPTIONAL).
C           SUBSEQUENT GRIDS SHOULD NOT PROVIDE DATA FOR SECTIONS
C           0 AND 1.  THEY NEED ONLY PROVIDE DATA FOR SECTIONS
C           2, 3, 4, 5, 6, 7, OR 3, 4, 5, 6, 7, OR 4, 5, 6, 7.
C           THE FINAL DATA GRID PACKED INTO THE GRIB2 MESSAGE
C           MUST BE FOLLOWED BY A SECTION 8 INDICATING THE END
C           OF THE GRIB2 MESSAGE.  THIS ROUTINE MUST BE CALLED
C           ONCE FOR EACH GRID PACKED IN THE GRIB2 MESSAGE.  THE
C           "NEW" CALLING ARGUMENT (SEE BELOW) IS USED WHEN
C           UNPACKING GRIB2 MESSAGES CONTAINING MULTIPLE
C           DATA GRIDS.
C
C           THERE ARE A NUMBER OF DIFFERENT ERROR CONDITIONS THAT
C           THAT CAN BE GENERATED WHILE PACKING A GRIB2 MESSAGE.
C           ERROR TRACKING IS HANDLED BY THE JER( , ) ARRAY (SEE BELOW).
C           EACH ROW OF THIS ARRAY CAN CONTAIN AN ERROR CODE FOLLOWED
C           BY ITS SEVERITY LEVEL.  THE SEVERITY LEVELS ARE
C           "0" FOR "OK", "1" FOR "WARNING", AND "2" FOR "FATAL".
C           THE PACKER WILL IMMEDIATELY ABORT EXECUTION WHEN
C           IT ENCOUNTERS A FATAL ERROR.  HOWEVER, EXECUTION IS NOT
C           IMPEDED BY A STATUS CODE OF "OK" OR "WARNING".  SEE THE
C           ARGUMENT LIST BELOW FOR A COMPLETE LIST OF THE ERROR
C           CODES THAT CAN BE RETURNED BY THIS ROUTINE.  UNLESS 
C           OTHERWISE STATED, ALL OF THE ERROR CODES ARE FATAL.
C
C        DATA SET USE
C           KFILDO - UNIT NUMBER FOR OUTPUT (PRINT) FILE.  (OUTPUT)
C
C        VARIABLES
C              KFILDO = UNIT NUMBER OF THE OUTPUT (PRINT) FILE.
C                       (INPUT)
C          AIN(IX,JY) = ARRAY USED TO PASS THE GRID OF DATA INTO THE 
C                       PACKER WHEN PACKING A FIELD CONSISTING OF
C                       FLOATING POINT VALUES (IX=1,NX) (JY=1,NY).
C                       (INPUT)
C         IAIN(IX,JY) = ARRAY USED TO PASS THE GRID OF DATA INTO THE
C                       PACKER WHEN PACKING A FIELD CONSISTING OF
C                       INTEGER VALUES (IX=1,NX) (JY=1,NY).  (INPUT)
C               NX,NY = SIZE OF AIN( , ), IAIN( , ), IB( , ).  (INPUT) 
C             IDAT(J) = THE ARRAY CONTAINING THE LOCAL USE GROUPS
C                       CONSISTING OF INTEGER DATA UNPACKED FROM
C                       SECTION 2 (J=1,NIDAT).  (INPUT)
C               NIDAT = THE DIMENSION OF THE IDAT( ) ARRAY.  (INPUT)
C             RDAT(J) = THE ARRAY CONTAINING THE LOCAL USE GROUPS
C                       CONSISTING OF FLOATING POINT DATA UNPACKED
C                       FROM SECTION 2 (J=1,NRDAT).  (INPUT)
C               NRDAT = THE DIMENSION OF THE RDAT( ) ARRAY.  (INPUT)
C              IS0(L) = HOLDS THE VALUES FOR THE GRIB INDICATOR
C                       SECTION, SECTION 0 (L=1,NS0). (INPUT/OUTPUT)
C                 NS0 = SIZE OF IS0( ).  (INPUT)
C              IS1(L) = HOLDS THE VALUES FOR THE GRIB IDENTIFICATION
C                       SECTION, SECTION 1 (L=1,NS1).  (INPUT/OUTPUT)
C                 NS1 = SIZE OF IS1( ).  (INPUT)
C              IS3(L) = HOLDS THE VALUES FOR THE GRIB GRID DEFINITION
C                       SECTION, SECTION 3 (L=1,NS3).  (INPUT/OUTPUT)
C                 NS3 = SIZE OF IS3( ).  (INPUT)
C              IS4(L) = HOLDS THE VALUES FOR THE GRIB PRODUCT 
C                       DEFINITION SECTION, SECTION 4 (L=1,NS4).
C                       (INPUT/OUTPUT)
C                 NS4 = SIZE OF IS4( ).  (INPUT)
C              IS5(L) = HOLDS THE VALUES FOR THE GRIB DATA 
C                       REPRESENTATION SECTION, SECTION 5 (L=1,NS5).
C                       (INPUT/OUTPUT)
C                 NS5 = SIZE OF IS5( ).  (INPUT)
C              IS6(L) = HOLDS THE VALUES FOR THE BIT-MAP SECTION,
C                       SECTION 6. (THIS IS OPTIONAL).
C                       (L=1,NS6). (INPUT/OUTPUT)
C                 NS6 = SIZE OF IS6( ). MUST BE NX*NY + 6 IF A
C                       BIT-MAP IS TO BE USED. (INPUT)
C              IS7(L) = HOLDS THE VALUES FOR THE DATA SECTION,
C                       SECTION 7 (L=1,NS7).  (INPUT/OUTPUT)
C                 NS7 = SIZE OF IS7( ).  (INPUT)
C           IB(IX,JY) = CONTAINS THE PRIMARY BIT-MAP.  THE BIT-MAP
C                       IS USED TO REPRESENT THE LOCATIONS OF MISSING
C                       VALUES IN THE DATA FIELD BEING PACKED INTO THE
C                       GRIB2 MESSAGE.  IT HAS A ONE-TO-ONE
C                       CORRESPONDENCE WITH THE DATA POINTS IN THE
C                       DATA GRID.   A VALUE OF "1" IN THE BIT-MAP
C                       INDICATES THAT THE CORRESPONDING VALUE IN THE
C                       DATA GRID IS VALID.  A VALUE OF "0" IN THE
C                       BIT-MAP INDICATES THAT THE CORRESPONDING VALUE
C                       IN THE DATA GRID IS MISSING.
C
C                       A BIT-MAP ACCOMPANIED BY A DATA FIELD WITH 
C                       THE PRIMARY MISSING VALUES REMOVED FROM IT
C                       MAY BE SUPPLIED TO THIS PACKER WHEN USING
C                       EITHER THE SIMPLE OR COMPLEX PACKING METHODS.
C                       HOWEVER, THE BIT-MAP IS HANDLED DIFFERENTLY
C                       DEPENDING ON WHICH PACKING METHOD IS BEING 
C                       USED.  FOR THE SIMPLE PACKING METHOD, 
C                       THE BIT-MAP IS PACKED INTO SECTION 6 OF THE
C                       GRIB2 MESSAGE.  FOR THE COMPLEX PACKING 
C                       METHOD, THE BIT-MAP IS USED TO INSERT THE
C                       MISSING VALUES INTO THE DATA FIELD WHICH IS
C                       THEN PACKED.  WHEN USING THIS PACKING METHOD
C                       THE BIT-MAP IS NOT PACKED INTO SECTION 6 OF
C                       THE GRIB2 MESSAGE.
C
C                       WITH THE SIMPLE PACKING METHOD, THE USER 
C                       ALSO HAS THE OPTION OF PASSING IN A DATA FIELD
C                       WITH MISSING VALUES EMBEDDED IN IT AND HAVING
C                       THE PACKER CREATE THE BIT-MAP.  CARE MUST
C                       BE EXERCISED IN SETTING THE IBITMAP AND 
C                       ICLEAN CALLING ARGUMENTS (SEE BELOW) AS 
C                       THESE CALLING ARGUMENTS INFORM THE PACKER AS
C                       TO WHETHER OR NOT THE USER IS SUPPLYING A 
C                       BIT-MAP AND WHETHER OR NOT THE DATA IN
C                       THE GRIDDED FIELD CONTAINS MISSING VALUES. 
C
C                       NOTE THAT IF A DATA FIELD HAS NO MISSING VALUES
C                       IN IT, THEN A BIT-MAP DOES NOT NEED TO BE
C                       PACKED INTO SECTION 6 OF THE GRIB2 MESSAGE
C                       WHEN USING THE SIMPLE PACKING METHOD. 
C                       (INPUT/OUTPUT)
C             IBITMAP = FLAG INDICATING WHETHER OR NOT A BIT-MAP
C                       IS BEING PASSED INTO THIS PACKER.  IF
C                       A BIT-MAP IS BEING PASSED INTO THIS 
C                       ROUTINE, THEN THIS ARGUMENT SHOULD BE SET TO
C                       "1".  IF A BIT-MAP IS NOT BEING PASSED
C                       INTO THIS ROUTINE, THEN THIS ARGUMENT SHOULD
C                       BE SET TO "0".  THE USER MUST TAKE CARE
C                       TO SET IS6(6), THE BIT-MAP INDICATOR,
C                       TO THE PROPER VALUE.  IT IS RECOMMENDED THAT
C                       IF THE USER IS PASSING IN A BIT-MAP THEN 
C                       HE SHOULD REMOVE THE MISSING VALUES FROM THE
C                       DATA FIELD AND SET THE ICLEAN FLAG TO "1".
C                       IF THE USER IS USING THE SIMPLE PACKING 
C                       METHOD AND WANTS THE PACKER TO GENERATE 
C                       A BIT-MAP, THEN HE SHOULD PASS IN THE DATA
C                       FIELD WITH THE MISSING VALUES EMBEDDED 
C                       IN IT ALONG WITH THE IBITMAP AND ICLEAN FLAGS
C                       SET TO "0",
C            IPACK(J) = THE ARRAY HOLDING THE ACTUAL PACKED MESSAGE
C                       (J=1,MAX OF ND5).  (OUTPUT)
C                 ND5 = DIMENSION OF IPACK( ).  (INPUT)
C               MISSP = PRIMARY MISSING VALUE, USED WHEN INTEGER
C                       DATA IS BEING PACKED.  (INPUT)
C              XMISSP = PRIMARY MISSING VALUE, USED WHEN FLOATING 
C                       POINT DATA IS BEING PACKED.  (INPUT)
C               MISSS = SECONDARY MISSING VALUE, USED WHEN INTEGER
C                       DATA IS BEING PACKED.  (INPUT)
C              XMISSS = SECONDARY MISSING VALUE, USED WHEN FLOATING 
C                       POINT DATA IS BEING PACKED.  (INPUT)
C                 NEW = FLAG INDICATING WHETHER OR NOT THIS IS THE 
C                       FIRST DATA GRID TO BE PACKED INTO A 
C                       GRIB2 MESSAGE.  A VALUE OF "1" INDICATES
C                       THAT THIS IS THE FIRST GRID TO BE PACKED INTO
C                       THE MESSAGE.  A VALUE OF "0" INDICATES THAT
C                       THIS IS NOT THE FIRST DATA GRID TO BE 
C                       PACKED INTO THE MESSAGE.  (INPUT)
C               MINPK = THIS CALLING ARGUMENT APPLIES ONLY TO THE
C                       COMPLEX PACKING METHOD.  IT DETERMINES
C                       THE MINIMUM SIZE OF THE GROUPS OF VALUES THAT
C                       THE DATA FIELD IS BROKEN DOWN INTO.  (INPUT)  
C              ICLEAN = FLAG INDICATING WHETHER OR NOT THE
C                       DATA FIELD (IN IAIN( , ) OR AIN( , )) CONTAINS
C                       MISSING VALUES.  A VALUE OF "0" MEANS THAT
C                       THE DATA FIELD DOES CONTAIN MISSING VALUES.
C                       A VALUE OF "1" MEANS THAT THE DATA FIELD DOES
C                       NOT CONTAIN ANY MISSING VALUES.  (INPUT)
C              L3264B = INTEGER WORD LENGTH OF MACHINE BEING USED.
C                       VALUES OF 32 AND 64 ARE ACCOMMODATED.  (INPUT)
C            JER(J,K) = RETURN STATUS CODES AND SEVERITY LEVELS
C                       (J=1,NDJER)(K=1,2). VALUES CAN COME FROM
C                       SUBROUTINES; OTHERWISE: 0 = GOOD RETURN.
C                       (OUTPUT)
C               NDJER = THE MAXIMUM NUMBER OF ERROR CODES JER( , )
C                       MAY CONTAIN. (INPUT)
C                KJER = THE ACTUAL NUMBER OF ERROR MESSAGES CONTAINED
C                       IN JER( , ). (OUTPUT)
C
C        LOCAL VARIABLES
C            A(IX,JY) = GRID OF REAL VALUES TO BE PACKED (IX=1,NX)
C                       (JY=1,NY).  (AUTOMATIC ARRAY)
C              EXISTS = BOOLEAN FLAG INDICATING WHETHER OR NOT A
C                       GRIB2 SECTION EXISTS (LOGICAL).
C           IA(IX,JY) = GRID OF INTEGER VALUES TO BE PACKED (IX=1,NX)
C                       (JY=1,NY).  (AUTOMATIC ARRAY)
C                  ID = THE DECIMAL SCALING FACTOR.
C                  IE = THE BINARY SCALING FACTOR.
C            IEDITION = THE VERSION NUMBER OF THE GRIB2 ENCODER.
C                 IER = RETURN CODE FROM MOST SUBROUTINES.  AN ERROR
C                       WILL BE TRANSFERRED TO JER(KJER, ) UPON RETURN.
C                        0 - GOOD RETURN
C                      1-4 - ERROR CODES RETURNED FROM PKBG.
C                      5,6 - ERROR CODES GENERATED BY THE LENGTH
C                            FUNCTION.
C                        8 - IS5(21) CONTAINS AN INVALID DATA TYPE
C                            VALUE. 
C                  101,102 - ERROR CODES GENERATED BY PK_SECT1.
C              301-304,310 - ERROR CODES GENERATED BY PK_SECT3. 
C                  401-403 - ERROR CODES GENERATED BY PK_SECT4. 
C              501,502,508 - ERROR CODES GENERATED BY PK_SECT5.
C                  601,602 - ERROR CODES GENERATED BY PK_SECT6.
C          701-703,711-713 - ERROR CODES GENERATED BY PK_SECT7.
C                      999 - ERROR CODES GENERATED BY PK_TRACE.
C                     1002 - ERROR CODE RETURNED FROM PK_SECT0.
C                 INC = NUMBER OF VALUES TO ADD TO THE GROUP TO BE
C                       PACKED AT A TIME.  SET TO 1 IN DATA STATEMENT.
C              IOCTET = THE LENGTH OF THE MESSAGE IN BYTES (OCTETS).
C             IPOS0_9 = SAVES THE BEGINNING BIT POSITION IN IPACK( )
C                       THAT THE TOTAL MESSAGE LENGTH WILL BE STORED
C                       AT ONCE THE GRIB2 MESSAGE HAS BEEN COMPLETELY
C                       PACKED. 
C             ISEVERE = THE SEVERITY LEVEL OF THE ERROR. ACCEPTABLE
C                       SEVERITY LEVELS ARE:
C                          0 = NOT A PROBLEM ... JUST A DIAGNOSTIC
C                          1 = A WARNING ... SOMETHING THE USER SHOULD
C                              KNOW ABOUT
C                          2 = A FATAL ERROR
C            LOCN0_9  = SAVES THE BEGINNING WORD POSITION IN IPACK( ) 
C                       THAT THE TOTAL MESSAGE LENGTH WILL BE STORED
C                       AT ONCE THE GRIB2 MESSAGE HAS BEEN COMPLETELY
C                       PACKED.
C                MINA = THE REFERENCE VALUE WHEN THE ORIGINAL DATA
C                       ARE INTEGER.
C               XMINA = THE REFERENCE VALUE WHEN THE ORIGINAL DATA
C                       ARE FLOATING POINT.
C        1         2         3         4         5         6         7 X
C
C        NON-SYSTEM SUBROUTINES CALLED
C           PK_SECT0, PK_SECT1, PK_SECT2, PK_SECT3, PK_SECT4,
C           PK_SECT5, PK_SECT6, PK_SECT7, PK_SECT8, PK_TRACE, PKBG,
C           PREPR
C
      LOGICAL EXISTS
C
      DIMENSION A(NX,NY)
      DIMENSION IA(NX,NY)
      DIMENSION AIN(NX,NY)
      DIMENSION IAIN(NX,NY)
      DIMENSION IB(NX,NY)
      DIMENSION IPACK(ND5)
      DIMENSION IS0(NS0),IS1(NS1),IS3(NS3),
     1          IS4(NS4),IS5(NS5),IS6(NS6),IS7(NS7)
      DIMENSION JER(NDJER,2)
      DIMENSION IDAT(NIDAT),RDAT(NRDAT)
C
      DATA EXISTS/.TRUE./
      DATA IEDITION/2/
      DATA INC/1/
C
      SAVE LOCN, IPOS,
     1     LOCN0_9, IPOS0_9
C
C    ================================= RCS keyword statements ==========
      CHARACTER*68     RCSKW1,RCSKW2
      DATA             RCSKW1,RCSKW2 /                                 '
     .$Source: /fs/hseb/ob72/rfc/util/src/grib2packer/RCS/pk_grib2.f,v $
     . $',                                                             '
     .$Id: pk_grib2.f,v 1.1 2004/09/16 16:52:29 dsa Exp $
     . $' /
C    ===================================================================
C
C
      IER=0
      ISEVERE=2
      KJER=0
C
C        INITIALIZE JER( , ).
C
      DO K=1,NDJER
         JER(K,1)=0
         JER(K,2)=0
      ENDDO
C
C        DETERMINE WHAT TYPE OF DATA THE USER IS PACKING.
C        IT IS NECESSARY TO MAKE LOCAL COPIES OF IAIN( , ) FOR
C        INTEGER DATA OR AIN( , ) FOR FLOATING POINT DATA TO
C        PREVENT THE USER-SUPPLIED DATA IN THESE ARRAYS FROM
C        GETTING ALTERED BY THE PACKING ROUTINES.
C
      IF(IS5(21).EQ.0)THEN
C
         DO 20 IY=1,NY
            DO 10 IX=1,NX
               A(IX,IY)=AIN(IX,IY)
  10        CONTINUE
  20     CONTINUE
C
      ELSE IF(IS5(21).EQ.1)THEN
C
         DO 40 IY=1,NY
            DO 30 IX=1,NX
               IA(IX,IY)=IAIN(IX,IY)
  30        CONTINUE
  40     CONTINUE
C
      ELSE
C
C           INVALID OPTION IN IS5(21).
         IER=8
         GOTO 900
      ENDIF
C
C        *************************************
C
C        PACK SECTION 0 OF THE MESSAGE INTO IPACK( ).
C
C        *************************************
C
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,0,0)
      CALL PK_SECT0(KFILDO,IPACK,ND5,IS0,NS0,L3264B,NEW,LOCN,IPOS,
     1              IEDITION,LOCN0_9,IPOS0_9,IER,ISEVERE,*900)
C
C        *************************************
C
C        PACK SECTION 1, IDENTIFICATION.
C
C        *************************************
C
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,100,0)
      CALL PK_SECT1(KFILDO,IPACK,ND5,IS1,NS1,NEW,L3264B,LOCN,IPOS,
     1              IER,ISEVERE,*900)
C
C        ********************************************************
C
C        PACK SECTION 2, THE LOCAL USE SECTION, IF IT IS PRESENT.
C
C        ********************************************************
C
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,200,0)
      CALL PK_SECT2(KFILDO,IPACK,ND5,RDAT,NRDAT,IDAT,NIDAT,
     1              L3264B,LOCN,IPOS,EXISTS,IER,ISEVERE,*900)
C
C        *************************************
C
C        PREPARE IA( ) FOR PACKING AND IB( ) IF NECESSARY.
C        MAKE DECISIONS ABOUT PACKING, ETC. SINCE THESE
C        DECISIONS AFFECT SECTION 3 AND SECTION 5, THE
C        PREPR ROUTINE IS CALLED BEFORE EITHER OF THOSE
C        SECTIONS ARE PROCESSED.
C
C        *************************************
C
      ID=IS5(18)
      IE=IS5(16)
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,900,0)
      CALL PREPR(KFILDO,A,IA,IB,NX,NY,NVAL,ICLEAN,IBITMAP,
     1           IS5,NS5,IS6,NS6,IS7,NS7,ID,IE,MINA,XMINA,
     2           MISSP,MISSS,XMISSP,XMISSS,MINPK,IPKOPT,jmax,
     3           IER,JER,NDJER,KJER,*900)
C
C        *************************************
C
C        PACK SECTION 3, GRID DEFINITION.
C
C        *************************************
C
C        IF THIS GRID IS BEING PACKED INTO AN EXISTING MESSAGE,
C        CHECK TO SEE IF THERE IS A SECTION 3 ... NOTE THAT THERE
C        MUST BE A SECTION 3 IF THERE WAS A SECTION 2.
C
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,300,0)
C
      IF(IS3(5).NE.3)THEN
         IF(EXISTS)THEN
            IER=305
            ISEVERE=2
            GO TO 900
         ENDIF
C
      ENDIF
         CALL PK_SECT3(KFILDO,IPACK,ND5,IS3,NS3,IPKOPT,L3264B,
     1                 LOCN,IPOS,IER,ISEVERE,*900)
C 
C        *************************************
C
C        PACK SECTION 4, PRODUCT DEFINITION.
C
C        *************************************
C
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,400,0)
      CALL PK_SECT4(KFILDO,IPACK,ND5,IS4,NS4,L3264B,LOCN,IPOS,
     1              IER,ISEVERE,*900)
C
C        *********************************************
C
C        PACK SECTION 5, DATA REPRESENTATION.
C
C        *********************************************
C
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,500,0)
      CALL PK_SECT5(KFILDO,IPACK,ND5,IS5,NS5,MINA,XMINA,
     1              MISSP,XMISSP,MISSS,XMISSS,L3264B,
     2              LOCN,IPOS,LOCN5_20,IPOS5_20,LOCN5_32,IPOS5_32,
     3              IER,ISEVERE,*900)
D     CALL TIMPR(KFILDO,KFILDO,'END SECTION 5        ')
C
C        *******************************************
C
C        PACK SECTION 6, BIT MAP.
C
C        *******************************************
C
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,600,0)
      CALL PK_SECT6(KFILDO,IB,NX*NY,IPACK,ND5,LOCN,IPOS,
     1              IS6,NS6,IPKOPT,L3264B,IER,ISEVERE,*900)
D     CALL TIMPR(KFILDO,KFILDO,'END SECTION 6        ')
C
C        ***********************************************
C
C        PACK SECTION 7, BINARY DATA.
C
C        ***********************************************
C
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,700,0)
      CALL PK_SECT7(KFILDO,IA,NX*NY,IPACK,ND5,LOCN,IPOS,
     1              IS5,NS5,IS6,NS6,IS7,NS7,INC,MINPK,MISSP,MISSS,
     2              IPKOPT,LOCN5_20,IPOS5_20,
     3              LOCN5_32,IPOS5_32,L3264B,jmax,jmin,lbit,nov,
     4              misslx,newbox,newboxp,IER,ISEVERE,*900)
C     
      IF(IER.NE.0)THEN
         CALL PK_TRACE(KFILDO,JER,NDJER,KJER,IER,1)
C           THIS CALL TO TRACE IS FOR NON FATAL ERRORS THAT
C           CAN BE CARRIED BACK.  FATAL ERRORS ARE RETURNED
C           TO *900.
      ENDIF
D     CALL TIMPR(KFILDO,KFILDO,'END SECTION 7        ')
C
C        *************************************
C
C        PACK SECTION 8, END OF MESSAGE.
C
C        *************************************
C
      CALL PK_TRACE(KFILDO,JER,NDJER,KJER,800,0)
      CALL PK_SECT8(KFILDO,IPACK,ND5,LOCN,IPOS,L3264B,IER,
     1              ISEVERE,*900)
C
C        FILL BYTES 9-12 WITH THE TOTAL MESSAGE LENGTH IN BYTES.
      IOCTET=LOCN*L3264B/8-(L3264B+1-IPOS)/8
      IS0(9)=IOCTET
C
      CALL PKBG(KFILDO,IPACK,ND5,LOCN0_9+1,IPOS0_9,IS0(9),32,L3264B,
     1          IER,*900)
C        THIS TOTAL LENGTH IS LIMITED TO A 4-BYTE WORD.  THE LENGTH IS
C        PUT INTO IS0(9), BUT IS PACKED INTO OCTETS 13-16, WHICH IS THE
C        RIGHT HALF OF A 64-BIT WORD.
C
C        WRITE THE TOTAL MESSAGE LENGTH.
C
D     WRITE(KFILDO,800)IOCTET
D800  FORMAT(/' TOTAL MESSAGE LENGTH IN BYTES =',I12)
C
      RETURN
C
C        ERROR RETURN SECTION.
C
 900  CALL PK_TRACE(KFILDO,JER,NDJER,KJER,IER,ISEVERE)
C
 901  RETURN
      END
