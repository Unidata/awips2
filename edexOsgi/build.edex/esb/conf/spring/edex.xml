<?xml version="1.0" encoding="UTF-8"?>
<beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:util="http://www.springframework.org/schema/util"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd   
  http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
  http://www.springframework.org/schema/util
  http://www.springframework.org/schema/util/spring-util-3.1.xsd">
  
  	<!-- Separated out database specific beans to seperate file so they can be loaded by themselves if necessary -->
  	<import resource="file:///${edex.home}/conf/spring/edex-db.xml"/>
  
    <!-- specify the connection to the broker (qpid) -->
    <!-- MaxPrefetch set at 0, due to DataPool routers getting messages backed up behind long running tasks -->
    <bean id="amqConnectionFactory" class="org.apache.qpid.client.AMQConnectionFactory">
       <constructor-arg type="java.lang.String" value="amqp://guest:guest@/${JMS_VIRTUALHOST}?brokerlist='tcp://${BROKER_ADDR}?retries='9999'&amp;heartbeat='0'&amp;connecttimeout='5000'&amp;connectdelay='5000''&amp;maxprefetch='0'&amp;sync_publish='all'&amp;sync_ack='true'"/>
    </bean>

    <bean id="jmsPooledConnectionFactory" class="com.raytheon.uf.common.jms.JmsPooledConnectionFactory">
       <constructor-arg ref="amqConnectionFactory"/>
       <property name="provider" value="QPID"/>
       <property name="reconnectInterval" value="5000"/>
       <!-- After resource has been closed by thread keep it allocated for another 2 minutes in case thread needs it again -->
       <property name="resourceRetention" value="120000"/>
    </bean>
 
    <bean id="genericThreadPool"
		class="com.raytheon.uf.edex.esb.camel.spring.JmsThreadPoolTaskExecutor">
		<property name="corePoolSize" value="${JMS_POOL_MIN}" />
		<property name="maxPoolSize" value="${JMS_POOL_MAX}" />
		<property name="queueCapacity" value="0" />
	</bean>

    <bean id="jms-generic" class="org.apache.camel.component.jms.JmsComponent">
       <constructor-arg ref="jmsGenericConfig" />
       <property name="taskExecutor" ref="genericThreadPool" />
	</bean>

    <bean id="jms-durable" class="org.apache.camel.component.jms.JmsComponent">
       <constructor-arg ref="jmsDurableConfig" />
       <property name="taskExecutor" ref="genericThreadPool" />
    </bean>

	<bean id="jmsGenericConfig" class="org.apache.camel.component.jms.JmsConfiguration"
			factory-bean="jmsConfig" factory-method="copy"/>

    <bean id="jmsDurableConfig" class="org.apache.camel.component.jms.JmsConfiguration"
            factory-bean="jmsConfig" factory-method="copy">
        <property name="destinationResolver" ref="qpidDurableResolver" />
        <property name="deliveryPersistent" value="true"/>
    </bean>

	<bean id="qpidNoDurableResolver" class="com.raytheon.uf.edex.esb.camel.spring.QpidDestinationNameResolver">
	    <property name="queueNamePrefix" value="direct://amq.direct/"/>
	    <property name="queueNamePostfix" value="?durable='false'"/>
	</bean>

	<bean id="qpidDurableResolver" class="com.raytheon.uf.edex.esb.camel.spring.QpidDestinationNameResolver">
	    <property name="queueNamePrefix" value="direct://amq.direct/"/>
	    <property name="queueNamePostfix" value="?durable='true'"/>
	</bean>

	<bean id="jmsConfig" class="org.apache.camel.component.jms.JmsConfiguration">
		<property name="cacheLevelName" value="CACHE_NONE"/>
		<property name="recoveryInterval" value="1000"/>
		<property name="requestTimeout" value="5000"/>

		<!-- receiveTimeout is amount of time thread waits to receive a message before recycling -->
		<!-- receiveTimeout also affects how fast a JMSConsumer will shut down, because the
                  thread may be stuck polling for the duration of receiveTimeout before shutting down -->
		<property name="receiveTimeout" value="10000"/>
		<property name="transacted" value="false"/>

		<!-- force maxMessagesPerTask so that the threads don't keep disconnecting and reconnecting.
		     This will keep a data-type attached to the initial thread it starts on -->
		<property name="maxMessagesPerTask" value="-1"/>
		<property name="listenerConnectionFactory" ref="jmsPooledConnectionFactory" />
		<property name="templateConnectionFactory" ref="jmsPooledConnectionFactory" />
		<property name="destinationResolver" ref="qpidNoDurableResolver" />
		<property name="disableReplyTo" value="true" />
		<property name="deliveryPersistent" value="false"/>
		<!--
		<property name="transacted" value="true" />
		<property name="acknowledgementModeName" value="TRANSACTED"/>
		<property name="transactionManager" ref="jmsReceiveTransactionManager" />
		-->
	</bean>

	<!--
	<bean id="jmsReceiveTransactionManager" class="org.springframework.jms.connection.JmsTransactionManager">
		<property name="connectionFactory" ref="amqConnectionFactory" />
	</bean>

	<bean id="PROPAGATION_REQUIRED" class="org.apache.camel.spring.spi.SpringTransactionPolicy">
		<property name="transactionManager" ref="jmsReceiveTransactionManager" />
		<property name="propagationBehaviorName" value="PROPAGATION_REQUIRED"/>
	</bean>
	-->
	
	<bean id="httpClient" class="com.raytheon.uf.common.comm.HttpClient" factory-method="getInstance">
		<property name="maxConnectionsPerHost" value="${PYPIES_MAX_CONN}"/>
		<!-- value in milliseconds to allow socket to timeout, don't allow this to be zero, bad things could happen -->
	   <property name="socketTimeout" value="180000"/>	   	   
	   <property name="compressRequests" value="false"/>
	   <property name="gzipResponseHandling" value="false"/>	   
	</bean>
	
	<bean id="pypiesStoreProps" class="com.raytheon.uf.common.pypies.PypiesProperties">
		<property name="address" value="${PYPIES_SERVER}" />		
	</bean>
	<bean id="pypiesDataStoreFactory" class="com.raytheon.uf.common.pypies.PyPiesDataStoreFactory">
		<constructor-arg ref="pypiesStoreProps" />
	</bean>
	
	<bean id="dataStoreFactory" class="com.raytheon.uf.common.datastorage.DataStoreFactory" factory-method="getInstance">
		<!-- Get instance of DataStoreFactory and set underlying factory to use -->
		<property name="underlyingFactory" ref="pypiesDataStoreFactory"/>
	</bean>
    
  
    <bean id="initialcorePropertyConfigurer"
      class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="systemPropertiesModeName">
           <value>SYSTEM_PROPERTIES_MODE_OVERRIDE</value>
        </property>
        <property name="searchSystemEnvironment">
           <value type="boolean">true</value>
        </property>
        <property name="ignoreUnresolvablePlaceholders" value="true">
        </property>
    </bean>

    <bean id="fileToString" class="com.raytheon.uf.edex.esb.camel.FileToString"/>
    <bean id="processUtil" class="com.raytheon.uf.edex.esb.camel.ProcessUtil"/>
    <bean id="setIngestHeaderFields" class="com.raytheon.uf.edex.esb.camel.SetIngestHeaderFields"/>
    <bean id="uuidGenerator" class="com.raytheon.uf.edex.esb.camel.UUIDGenerator"/>
    <bean id="messageUtil" class="com.raytheon.uf.edex.esb.camel.MessageProducer" />
    <bean id="camelContextAdmin" class="com.raytheon.uf.edex.esb.camel.CamelContextAdmin" />
    
    <bean id="util" class="com.raytheon.uf.edex.core.EDEXUtil">
    	<property name="messageProducer" ref="messageUtil" />
    	<property name="contextAdmin" ref="camelContextAdmin" />
    </bean>
    
    <bean id="initSystem" class="com.raytheon.edex.plugin.InitializerBean" />
    <bean id="defaultPathProvider" class="com.raytheon.uf.common.dataplugin.persist.DefaultPathProvider"/>
    
    <!-- The pluginDefaults are the values that a data plugin will use for
         some plugin properties if they are not specified in the individual
         plugin's Spring XML configuration -->
    <bean id="pluginDefaults" class="com.raytheon.uf.common.dataplugin.defaults.PluginPropertyDefaults">
		<property name="database" value="metadata" />
		<property name="initializer" value="com.raytheon.edex.plugin.DefaultPluginInitializer" />
		<property name="dao" value="com.raytheon.edex.db.dao.DefaultPluginDao" />
		<property name="initialRetentionTime" value="24" />
		<property name="pathProvider" ref="defaultPathProvider"/>
	</bean>  		

	<!--  This causes database tables to be initialized when a db plugin is registered -->
    <bean id="schemaManager" class="com.raytheon.uf.edex.database.schema.SchemaManager"
    	factory-method="getInstance" />
    	
    <bean factory-bean="dbPluginRegistry" factory-method="addListener">
    	<constructor-arg><ref bean="schemaManager"/></constructor-arg>
    </bean>
    <!-- This causes the data plugin's database tables to be created when a plugin is registered -->
    <bean id="dbPluginRegistryListenerAdded" factory-bean="pluginRegistry" factory-method="addListener">
    	<constructor-arg><ref bean="dbPluginRegistry"/></constructor-arg>
    </bean>
    <!-- This causes the data plugin's initializer to get called when a plugin
         is registered -->
    <bean id="pluginSetup" class="com.raytheon.edex.plugin.PluginInitialSetup" />
    <bean factory-bean="pluginRegistry" factory-method="addListener" depends-on="dbPluginRegistryListenerAdded">
    	<constructor-arg><ref bean="pluginSetup"/></constructor-arg>
    </bean>
    
    
    <bean id="stringToFile" class="com.raytheon.uf.edex.esb.camel.StringToFile"/>
    <bean id="extractWMOHeader" class="com.raytheon.uf.common.util.header.WMOHeaderRemover"/>
	<bean id="dataUnzipper" class="com.raytheon.uf.common.util.DataUnzipper"/>       
    
    <bean id="errorHandler" class="org.apache.camel.builder.LoggingErrorHandlerBuilder"/>
    
    <!-- sets default settings of log component across all of edex -->
    <!-- if log component beans are created and the exchangeFormatter property is set, they can't process URI parameters -->
    <!-- this bean needs to be named 'logFormatter' for the log component to find it in the context -->
    <bean id="logFormatter" class="org.apache.camel.component.log.LogFormatter" scope="prototype">
        <property name="maxChars" value="0" />
        <property name="showBody" value="false" />
        <property name="showCaughtException" value="true" />
        <property name="showStackTrace" value="true" />
    </bean>

    <bean id="serializationUtil" class="com.raytheon.uf.common.serialization.SerializationUtil" />    

	<bean id="pluginRegistry" class="com.raytheon.uf.edex.core.dataplugin.PluginRegistry" factory-method="getInstance"/>	
	<bean id="dbPluginRegistry" class="com.raytheon.uf.edex.database.DatabasePluginRegistry" factory-method="getInstance"/>
	
	<bean id="commonDbPluginProperties" class="com.raytheon.uf.edex.database.DatabasePluginProperties">
		<property name="pluginFQN" value="com.raytheon.uf.edex.database" />
		<property name="database" value="metadata" />
		<property name="forceCheck" value="true" />
	</bean>
	<bean id="commonDbRegistered" factory-bean="dbPluginRegistry" factory-method="register"
				depends-on="metadataTxManager">
		<constructor-arg value="com.raytheon.uf.edex.database"/>
		<constructor-arg ref="commonDbPluginProperties"/>
	</bean>
		
	<bean id="CamelBeanParameterMappingStrategy"
          class="com.raytheon.uf.edex.esb.camel.EDEXParameterMappingStrategy" />            

    <!-- ContextManager to start camel context last. Ensures items such as distribution aren't started before all the listening routes are up -->
	<bean id="contextManager"
	    class="com.raytheon.uf.edex.esb.camel.context.ContextManager"
		factory-method="getInstance">
	</bean>

	<!-- Clustered routes will start on a box if there has not been a lock for that route in the last 60 seconds.
	     Anyone using the clustered routes should ensure that timeToLive on jms messages are at least 1 minute -->
	<bean id="clusteredCamelContextMgr"
	    class="com.raytheon.uf.edex.esb.camel.context.ClusteredContextManager"
		factory-method="getInstance">
		<property name="timeOutMillis" value="60000"/>
	</bean>

    <!-- Serialization Pool -->
	<bean id="baosPool" class="com.raytheon.uf.common.util.ByteArrayOutputStreamPool" factory-method="getInstance">
	   <property name="maxPoolSize" value="${SERIALIZE_POOL_MAX_SIZE}"/>
	   <property name="initStreamSize" value="${SERIALIZE_STREAM_INIT_SIZE_MB}"/>
	   <property name="maxStreamSize" value="${SERIALIZE_STREAM_MAX_SIZE_MB}"/>
	</bean>

	<bean id="edexLocalizationObserver" class="com.raytheon.edex.utility.EDEXLocalizationNotificationObserver" factory-method="getInstance"/>

    <!--
    ** Lets deploy some Enterprise Integration Patterns inside Camel
    ** For more details see
    **
    ** http://camel.apache.org/enterprise-integration-patterns.html
    -->
    <camelContext id="camel" xmlns="http://camel.apache.org/schema/spring" errorHandlerRef="errorHandler">                                                                

		<!-- Route for edex to listen for utility updates -->
		<route id="edexUtilityNotify">
			<from uri="jms-generic:topic:edex.alerts.utility" />
			<bean ref="edexLocalizationObserver" method="fileUpdated"/>
		</route>
       
        <!-- Route to send alerts to alertviz -->
		<route id="alertVizNotify">
			<from uri="vm:edex.alertVizNotification" />
			<bean ref="serializationUtil" method="transformToThrift" />
			<to uri="jms-generic:topic:edex.alerts.msg" />
		</route>

		<!-- Route to send text products to alarm/alert -->
		<route id="alarmAlertNotify">
			<from uri="vm:edex.alarmAlertNotification" />
			<bean ref="serializationUtil" method="transformToThrift" />
			<to uri="jms-generic:topic:edex.alarms.msg" />
		</route>

        <!-- Route to periodically close any unused jms resources that have been pooled -->
        <route id="jmsPooledResourceChecker">
		    <from uri="timer://jmsPooledResourceCheck?period=60s" />
			<doTry>
				<bean ref="jmsPooledConnectionFactory" method="checkPooledResources"/>
				<doCatch>
					<exception>java.lang.Throwable</exception>
					<to uri="log:jmsPooledResourceCheck?level=ERROR"/>
				</doCatch>
			</doTry>
		</route>
    </camelContext>    
    <camelContext
        id="clusteredCamel"
        xmlns="http://camel.apache.org/schema/spring"
        errorHandlerRef="errorHandler"
        autoStartup="false">                                                                
        <route id="monitorClusteredContexts">
			<from uri="timer://monitorClusterContexts?fixedRate=true&amp;period=20000"/>
			<doTry>
				<bean ref="clusteredCamelContextMgr" method="checkClusteredContexts" />
				<doCatch>
					<exception>java.lang.Throwable</exception>
					<to uri="log:monitorClusteredContexts?level=ERROR"/>
				</doCatch>
			</doTry>
		</route>
	</camelContext>
	<bean factory-bean="contextManager"
		factory-method="register">
		<constructor-arg ref="clusteredCamel"/>
  	</bean>

   <!-- Redirect geotools log -->
   <bean class="com.raytheon.uf.common.geospatial.LogRedirector" factory-method="setGeotoolsLogFactory">
        <constructor-arg value="org.geotools.util.logging.Log4JLoggerFactory" />
   </bean>

   <!-- Reference properties files -->
   <bean id="projectPropertyConfigurer"
		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	<property name="locations">
		<list>
			<value>file:${edex.home}/conf/spring/cron.properties</value>
			<value>file:${edex.home}/conf/spring/${edex.arch}/architecture.properties</value>
		</list>
	</property>
   </bean>

    <!-- Holds the registry of request routers by server key -->
    <bean id="handlerRegistry" class="com.raytheon.uf.edex.auth.HandlerRegistry"
        factory-method="getInstance" />
    
    <bean id="requestRouterRegistry"
        class="com.raytheon.uf.common.serialization.comm.RequestRouter"
        factory-method="getRouterRegistry" />
    
    <!-- Server Request routers -->
    <bean id="serverPrivilegedRequestHandler"
        class="com.raytheon.uf.edex.auth.req.ServerPrivilegedRequestHandler">
        <constructor-arg ref="handlerRegistry" />
    </bean>

    <bean factory-bean="handlerRegistry" factory-method="register">
        <constructor-arg
            value="com.raytheon.uf.edex.auth.req.ServerPrivilegedRequestHandler.ServerPrivilegedRequest" />
        <constructor-arg ref="serverPrivilegedRequestHandler" />
    </bean>

    <util:constant id="requestServerKey"
        static-field="com.raytheon.uf.common.auth.RequestConstants.REQUEST_SERVER" />
    
    <bean id="requestServiceRouter" class="com.raytheon.uf.edex.auth.ServerRequestRouter">
        <!-- This bean will cause all RequestRouter.route(request) calls 
            to be processed internally to EDEX -->
    </bean>

    <bean id="registerRequestServiceRouter" factory-bean="requestRouterRegistry"
        factory-method="register">
        <constructor-arg ref="requestServerKey" />
        <constructor-arg ref="requestServiceRouter" />
    </bean>

	<!-- needed for camel quartz component workaround when JMX is disabled -->
	<bean id="managementNameLifecycleStrategy"
		class="com.raytheon.uf.edex.esb.camel.quartz.ManagementNameLifecycleStrategy" />

	<!-- quartz component configuration.
		Single scheduler used by all endpoints so there is only one threadpool. 
		Thread pool configured in edex/config/resources/quartz.properties -->
		
	<bean id="quartzSchedulerFactory" class="org.quartz.impl.StdSchedulerFactory">
		<constructor-arg value="quartz.properties" />
	</bean>

	<bean id="quartzScheduler" factory-bean="quartzSchedulerFactory"
		factory-method="getScheduler" />

	<bean id="quartz" class="org.apache.camel.component.quartz.QuartzComponent">
		<property name="scheduler" ref="quartzScheduler" />
	</bean>

	<bean id="clusteredquartz"
		class="com.raytheon.uf.edex.esb.camel.cluster.quartz.ClusteredQuartzComponent">
		<property name="scheduler" ref="quartzScheduler" />
	</bean>
  
</beans>
