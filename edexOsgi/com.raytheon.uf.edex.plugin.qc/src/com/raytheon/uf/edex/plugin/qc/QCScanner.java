/**
 * This software was developed and / or modified by Raytheon Company,
 * pursuant to Contract DG133W-05-CQ-1067 with the US Government.
 * 
 * U.S. EXPORT CONTROLLED TECHNICAL DATA
 * This software product contains export-restricted data whose
 * export/transfer/disclosure is restricted by U.S. law. Dissemination
 * to non-U.S. persons whether in the United States or abroad requires
 * an export license or other authorization.
 * 
 * Contractor Name:        Raytheon Company
 * Contractor Address:     6825 Pine Street, Suite 340
 *                         Mail Stop B8
 *                         Omaha, NE 68106
 *                         402.291.0100
 * 
 * See the AWIPS II Master Rights File ("Master Rights File.pdf") for
 * further licensing information.
 **/

package com.raytheon.uf.edex.plugin.qc;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import com.raytheon.uf.common.dataplugin.PluginDataObject;
import com.raytheon.uf.common.dataplugin.qc.QCRecord;
import com.raytheon.uf.common.pointdata.PointDataContainer;
import com.raytheon.uf.common.pointdata.PointDataDescription;
import com.raytheon.uf.common.pointdata.PointDataView;
import com.raytheon.uf.common.pointdata.spatial.SurfaceObsLocation;
import com.raytheon.uf.common.status.IUFStatusHandler;
import com.raytheon.uf.common.status.UFStatus;
import com.raytheon.uf.common.time.DataTime;
import com.raytheon.uf.edex.database.plugin.PluginFactory;
import com.raytheon.uf.edex.plugin.qc.dao.QCDao;
import com.raytheon.uf.edex.plugin.qc.internal.QCPaths;

import ucar.ma2.Array;
import ucar.ma2.ArrayChar;
import ucar.ma2.DataType;
import ucar.ma2.Section;
import ucar.nc2.Attribute;
import ucar.nc2.NetcdfFile;
import ucar.nc2.Variable;

/**
 * Scans NetCDF files generated by A1 legacy applications and generates QCRecord
 * instances that refer to their records. The scan should only occur on one JVM
 * in a cluster while the decode can occur on multiple JVMs in a cluster.
 * 
 * <pre>
 * 
 * SOFTWARE HISTORY
 * 
 * Date         Ticket#    Engineer    Description
 * ------------ ---------- ----------- --------------------------
 * Dec 03, 2010 4775       D. Friedman Initial version
 * Mar 07, 2013 15842      D. Friedman Use Java NetCDF library instead of
 *                                     pupynere
 * May 16, 2013 1869       bsteffen    Remove DataURI column from qc.
 * Aug 30, 2013 2298       rjpeter     Make getPluginName abstract
 * Feb 20, 2014 DR 17098   D. Friedman Filter out invalid lat/lon values.
 * Jul 23, 2014 3410       bclement    location changed to floats
 * Jan 03, 2018 6861       njensen     Split on files, decode and store results
 *                                      as PointDataView on PluginDataObject[]
 * 
 * </pre>
 * 
 * @author dfriedma
 */
public class QCScanner {

    private static final IUFStatusHandler statusHandler = UFStatus
            .getHandler(QCScanner.class);

    private static final Pattern FILE_PATTERN = Pattern.compile("^\\d+_\\d+$");

    private Integer maxRecordsInChunk;

    /**
     * Map of qcType to filename to last mod time. Used to ensure we don't scan
     * a file again if it hasn't changed.
     */
    private Map<String, Map<String, Long>> fileLastScannedMap = new HashMap<>();

    /**
     * @return the maxRecordsInChunk
     */
    public Integer getMaxRecordsInChunk() {
        return maxRecordsInChunk;
    }

    /**
     * @param maxRecordsInChunk
     *            the maxRecordsInChunk to set
     */
    public void setMaxRecordsInChunk(Integer maxRecordsInChunk) {
        this.maxRecordsInChunk = maxRecordsInChunk;
    }

    /**
     * Information necessary to start a decode. Serialized after the split to
     * take advantage of clustering the decodes.
     */
    public static class QCFile implements Serializable {

        private static final long serialVersionUID = 1L;

        protected String qcType;

        protected File file;

        protected QCFile(String qcType, File file) {
            this.qcType = qcType;
            this.file = file;
        }
    }

    public class QCDirectoryScanner {
        private final String qcType;

        private final File directory;

        public QCDirectoryScanner(String qcType, File directory) {
            this.qcType = qcType;
            this.directory = directory;
        }

        /**
         * Scan all files in the directory that match the pattern and have been
         * modified since we last scanned them. If we did not previously scan
         * them, then scan those too.
         * 
         * @return the list of QCFiles that match the pattern and have been
         *         modified since we last scanned them
         */
        public List<QCFile> getFiles() {
            List<QCFile> results = new ArrayList<>();
            Map<String, Long> updatedScanMap = new HashMap<>();
            Map<String, Long> innerMap = fileLastScannedMap.get(qcType);
            if (innerMap == null) {
                innerMap = new HashMap<>();
            }

            for (String fn : directory.list()) {
                if (FILE_PATTERN.matcher(fn).matches()) {
                    try {
                        File f = new File(directory, fn);
                        String path = f.getPath();
                        Long lastScanned = innerMap.get(path);
                        if (lastScanned == null
                                || f.lastModified() > lastScanned) {
                            QCFile qcf = new QCFile(qcType, f);
                            results.add(qcf);
                            lastScanned = f.lastModified();
                        }
                        updatedScanMap.put(path, lastScanned);
                    } catch (Exception e) {
                        statusHandler
                                .error(String.format("error reading %s/%s: %s",
                                        directory, fn, e.getMessage()), e);
                    }
                }
            }

            fileLastScannedMap.put(qcType, updatedScanMap);
            return results;
        }
    }

    /**
     * Gets an iterator of QC files to process/decode.
     * 
     * @return an iterator of QC files
     * @throws FileNotFoundException
     */
    public Iterator<QCFile> split() throws FileNotFoundException {
        List<QCFile> files = new ArrayList<>();
        Map<String, File> paths = QCPaths.getPaths();
        for (Map.Entry<String, File> entry : paths.entrySet()) {
            String type = entry.getKey();
            File directory = entry.getValue();
            QCDirectoryScanner scanner = new QCDirectoryScanner(type,
                    directory);
            files.addAll(scanner.getFiles());
        }

        return files.iterator();
    }

    /**
     * Scans or "decodes" the QC netcdf file into QCRecords
     * 
     * @param qcFile
     *            the QC file to scan for records
     * @return the PluginDataObjects that were "decoded"
     * @throws Exception
     */
    public PluginDataObject[] scanFile(QCFile qcFile) throws Exception {
        try (NetcdfFile nc = NetcdfFile.open(qcFile.file.getPath())) {
            int index = 0;
            int totalRecordCount = nc.getUnlimitedDimension().getLength();
            int batchSize = Math.min(getMaxRecordsInChunk(), totalRecordCount);

            String[] idVariablesNames = nc.findGlobalAttribute("idVariables")
                    .getStringValue().split(",");
            String[] timeVariableNames = nc.findGlobalAttribute("timeVariables")
                    .getStringValue().split(",");
            Variable[] idVariables = new Variable[idVariablesNames.length];
            for (int i = 0; i < idVariables.length; ++i) {
                idVariables[i] = nc.findVariable(idVariablesNames[i]);
            }
            Variable vObsTime = nc.findVariable(timeVariableNames[0]);
            double vObsTimeFillValue = vObsTime.findAttribute("_FillValue")
                    .getNumericValue().doubleValue();
            Double vObsTimeMissingValue = null;
            Attribute a = vObsTime.findAttribute("missing_value");
            if (a != null) {
                vObsTimeMissingValue = a.getNumericValue().doubleValue();
            }
            Variable vLat = nc.findVariable("latitude");
            Variable vLon = nc.findVariable("longitude");
            Variable vElev = nc.findVariable("elevation");

            /*
             * There's so many variables in the file that we don't need so we
             * pick the ones we do need from the point data description.
             */
            QCDao qcDao = (QCDao) PluginFactory.getInstance()
                    .getPluginDao("qc");
            Map<String, Object> map = new HashMap<>();
            map.put("qcType", qcFile.qcType);
            PointDataDescription pdd = qcDao.getPointDataDescription(map);
            PointDataContainer pdc = PointDataContainer.build(pdd);
            Map<String, Variable> variableMap = new HashMap<>();
            for (String name : pdd.getParameterNames()) {
                /*
                 * do not include id variables, we will read those separately
                 * below because they are 2-dimensional chars (aka Strings)
                 */
                boolean foundId = false;
                for (String idName : idVariablesNames) {
                    if (idName.equals(name)) {
                        foundId = true;
                        break;
                    }
                }
                if (!foundId) {
                    Variable v = nc.findVariable(name);
                    if (v != null) {
                        variableMap.put(name, v);
                    }
                }
            }

            Map<String, PluginDataObject> recordMap = new HashMap<>();
            while (index < totalRecordCount) {
                batchSize = Math.min(batchSize, totalRecordCount - index);
                int[] ofs = new int[] { index };
                int[] len = new int[] { batchSize };
                Array dObsTime = vObsTime.read(ofs, len);
                Array dLat = vLat.read(ofs, len);
                Array dLon = vLon.read(ofs, len);
                Array dElev = vElev.read(ofs, len);

                // get IDs which will become the unique station name
                Section sec = new Section();
                sec.appendRange(index, (index + batchSize) - 1);
                sec.appendRange();
                ArrayChar[] dIDs = new ArrayChar[idVariables.length];
                for (int i = 0; i < dIDs.length; ++i) {
                    dIDs[i] = (ArrayChar) idVariables[i].read(sec);
                }

                Map<String, Array> nameToArrayMap = new HashMap<>();
                for (Variable v : variableMap.values()) {
                    Array arr = v.read(ofs, len);
                    nameToArrayMap.put(v.getName(), arr);
                }

                int ri = 0;
                while (ri < batchSize) {
                    PointDataView pdv = pdc.append();
                    QCRecord pdo = new QCRecord();
                    pdo.setOverwriteAllowed(true);
                    double obsTime = dObsTime.getDouble(ri);
                    float lat = dLat.getFloat(ri);
                    float lon = dLon.getFloat(ri);
                    if ((obsTime != vObsTimeFillValue)
                            && ((vObsTimeMissingValue == null)
                                    || (vObsTimeMissingValue != obsTime))
                            && Math.abs(lon) <= 180 && Math.abs(lat) <= 90) {
                        pdo.setDataTime(new DataTime(
                                new Date((long) (obsTime * 1000))));
                        SurfaceObsLocation loc = new SurfaceObsLocation();
                        loc.assignLocation(lat, lon);
                        loc.setElevation(dElev.getInt(ri));

                        /*
                         * Set up a unique stationId while also setting the id
                         * variable names with point data values
                         */
                        StringBuilder stationId = new StringBuilder();
                        for (ArrayChar idArray : dIDs) {
                            stationId.append(idArray.getString(ri));
                        }
                        loc.setStationId(stationId.toString());
                        for (int i = 0; i < idVariablesNames.length; i++) {
                            pdv.setString(idVariablesNames[i],
                                    dIDs[i].getString(ri));
                        }

                        pdo.setLocation(loc);
                        pdo.setNcSet(qcFile.file.getName());
                        pdo.setQcType(qcFile.qcType);

                        for (String name : nameToArrayMap.keySet()) {
                            Array arr = nameToArrayMap.get(name);
                            DataType dtype = arr.getDataType();
                            switch (dtype) {
                            case CHAR:
                                pdv.setString(name,
                                        String.valueOf(arr.getChar(ri)));
                                break;
                            case INT:
                            case SHORT:
                                pdv.setInt(name, arr.getInt(ri));
                                break;
                            case LONG:
                                pdv.setLong(name, arr.getLong(ri));
                                break;
                            case FLOAT:
                            case DOUBLE:
                                pdv.setFloat(name, arr.getFloat(ri));
                                break;
                            default:
                                throw new IllegalArgumentException(
                                        "QCScanner does not support reading values of type "
                                                + dtype);
                            }

                        }
                        pdo.setPointDataView(pdv);
                        recordMap.put(pdo.getDataURI(), pdo);
                    }
                    ++index;
                    ++ri;

                }

            } // end of outer while

            Collection<PluginDataObject> results = recordMap.values();
            int size = results.size();
            statusHandler.info("Decoded " + size + " QC records from "
                    + qcFile.file.getPath() + ", now storing");
            return results.toArray(new PluginDataObject[size]);
        }
    }
}
