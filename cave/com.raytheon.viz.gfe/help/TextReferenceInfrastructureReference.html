<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR"
 content="Mozilla/4.8 [en] (X11; U; Linux 2.4.18-27.7.xsmp i686) [Netscape]">
  <title>Text Products Reference</title>
<!--link REL="STYLESHEET" HREF="TextFormatter.html"-->
</head>
<body bgcolor="#ffffff">
<center>
<h1><a name="InfrastructureReference"></a>Infrastructure Reference</h1>
</center>
<p>&nbsp;&nbsp; <a href="#ArgumentsintheStandardProductFile">Arguments
in
the Standard File</a> <br>
&nbsp;&nbsp; <a href="#Naming">Naming Conventions</a> <br>
&nbsp;&nbsp; <a href="#SampleAnalysis">Sample Analysis</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#StatisticsByTime">Statistics By Time Range</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#ArgumentstoSampleAnalysis">Arguments to SampleAnalysis methods</a>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#Checking_for_Edit_Areas_Sample">Checking for Edit Areas</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#GLOBALTHRESHOLDSAND">Global Thresholds and Variables</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#SCALARWEATHERElements">Scalar Analysis methods</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#VECTORWEATHERElements">Vector Analysis methods</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#DISCRETEELEMENTS">DiscreteAnalysis
methods</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#WXElement">Weather
Analysis methods</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#dominantWx">Algorithm for rankedWx and dominantWx</a> <br>
&nbsp;&nbsp; <a href="#TextRule">Text Rules Libraries for Narrative
Products</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#SettingDAYandNIGHTtimes">Setting Day and Night Times</a>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#Analysis-DrivenPhrases">Analysis-Driven Phrases</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#ArgumentstoTextRulesClass">Arguments to Narrative methods</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#CheckingforEdit">Checking
for Edit Areas</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#TextGlobals">Global
Thresholds and Variables</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#NARRATIVEPHRASES">Narrative
Phrases</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#SCALARWEATHERELEMENT">Scalar Weather Element Phrases</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#WINDANDWINDGUST">Vector-Related Phrases (Wind and WindGust)</a>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#SeaBreeze">Sea Breeze Identification</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#WEATHER">Weather Phrases</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#Weather_Key_Attributes_Primary_and">Weather Subkey Attributes
"Primary" and "Mention"</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#CustomizingWeatherPhrases">Customizing Weather Phrases</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#PopWx_Consistency">Pop/Wx Consistency</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#COMBINEDELEMENT">Combined Element Phrases</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#MARINE">Marine Phrases</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#AlgorithmforWaveHeightandWindWaveHgt">Algorithm for WaveHeight
and WindWaveHgt Reporting</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#FIREWEATHER">Fire Weather Phrases</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#FIREWEATHER"> Discrete Phrases (Headlines)</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#NARRATIVESTRATEGIES">Narrative Strategies</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#STRATEGYFORNONLINEARTHRESHOLDS">Non-Linear Thresholds</a>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#DATAVALUEEXTRACTIONFROMTHEGRIDS">DataValue
Extraction from the Grids</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#UNITCONVERSION">Unit Conversion</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#STRATEGYFORNONSTANDARDROUNDING">Standard and
Non-Standard Rounding</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#RANGEADJUSTMENT">Range&nbsp; Adjustment</a>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#STRATEGYFORHANDLINGNULLVALUES">Null Values</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#STRATEGYFORLOCALEFFECTSPhraseBuildermodule">Local
Effects</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#LocalEffectsandCompoundPhrases">Local Effects and
Compound Phrases</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#ConsolidationRulesforLocalEffects">Consolidation
Rules for Local Effects</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#LocalEffectExamples">Local Effect Examples</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#NullValuesandLocalEffects">Null Values and Local
Effects</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#ExceptversusOtherwiseWording">"Except" vs. "Otherwise"
wording</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#LocalEffectAreasthatdonotIntersecttheCurrentArea">More
Local Effect Area Features</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#LocalEffectsforSnowAccumulationandTotalSnowAccumulation">Local
Effects for Snow Accumulation and Total Snow Accumulation -- Using a
Method for Checking the Local Effect Threshold</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a
 href="#LocalEffectsfortheCombinedSkyPopWxPhrase">Local
Effects for the Combined SkyPopWx Phrase</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#PERIODCOMBINING">Period Combining</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#STRATEGYFORPHRASECONSOLIDATION">Phrase Consolidation</a>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#PHRASEORDERING">Phrase Ordering</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#UNTILPHRASING">"Until" Phrasing</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#HANDLINGVISIBILITY">Visibility</a> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
 href="#WEATHERKEYFILTERING">Weather Phrasing</a><br>
&nbsp;&nbsp; <a href="#Appendix_A">Appendix A:&nbsp; Local Effects
Design</a><br>
</p>
<hr>
<h2> <a name="ArgumentsintheStandardProductFile"></a>Arguments in
the Standard Product File</h2>
&nbsp;
<center><br>
<table nosave="" border="1" width="75%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>ARGUMENT</td>
      <td>ACCESSING INFORMATION</td>
    </tr>
    <tr>
      <td>argDict</td>
      <td>&nbsp;Dictionary containing system information about the
product being created. In most cases, you will not need to access
information within argDict, but it must be passed for internal system
use.</td>
    </tr>
    <tr>
      <td>fcst</td>
      <td>The text string representing the product. It will
be in a partially completed state as it is passed to each method in
turn. Be sure to "return fcst" at the end of a method that
is passed the fcst.</td>
    </tr>
    <tr>
      <td>editArea</td>
      <td>Contains the name and polygon points that define an edit
area.&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; editAreaName = editArea.id().name()</td>
    </tr>
    <tr>
      <td>areaLabel</td>
      <td>The label given to the current edit area (or current
combination of areas).&nbsp;&nbsp; This label is defined via the
"defaultEditAreas" entries OR within the Combinations file entries.</td>
    </tr>
    <tr>
      <td>timeRange</td>
      <td>Time Range over which statistics are being generated.&nbsp;
This is always in GMT.&nbsp; <br>
&nbsp;&nbsp;&nbsp; timeRange.startTime()&nbsp; <br>
&nbsp;&nbsp;&nbsp; timeRange.startTime().day(),&nbsp;&nbsp;
timeRange.startTime().month(),&nbsp; timeRange.startTime().hour()&nbsp;
      <br>
&nbsp;&nbsp;&nbsp; timeRange.endTime()</td>
    </tr>
  </tbody>
</table>
</center>
<h2> <a name="Naming"></a>Naming conventions</h2>
Throughout the infrastructure, thresholds, variables, and methods are
named with suffixes that indicate the return value
expected.&nbsp;&nbsp;
For example,&nbsp; the method, <i><font color="#993366">pop_lower_threshold</font>,</i>returns
a weather element value for PoP.&nbsp;&nbsp; The table below lists the
suffixes and their meaning (in alphabetical order): <br>
&nbsp; <br>
&nbsp;
<center><br>
<table nosave="" border="1" width="75%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>METHOD SUFFIXES</td>
      <td>METHOD RETURN VALUE</td>
    </tr>
    <tr>
      <td>_dict</td>
      <td>Python dictionary</td>
    </tr>
    <tr>
      <td>_difference</td>
      <td>a difference in weather values e.g. <i><font color="#993366">vector_mag_difference</font></i>is
used to determine if wind magnitudes are significantly different</td>
    </tr>
    <tr>
      <td>_element</td>
      <td>weather element name e.g. "WindWaveHgt" returned as the&nbsp;
      <i><font color="#993366">seasWindWave_element</font></i></td>
    </tr>
    <tr>
      <td>_flag</td>
      <td>0 or 1</td>
    </tr>
    <tr>
      <td>_list</td>
      <td>Python list</td>
    </tr>
    <tr>
      <td>_percentage</td>
      <td>number between 0 and 100</td>
    </tr>
    <tr>
      <td>_phrase</td>
      <td>text string phrase</td>
    </tr>
    <tr>
      <td>_phrase_connector</td>
      <td>text string for connecting phrases e.g. " then " as in
"Mostly cloudy in the morning then clearing."</td>
    </tr>
    <tr>
      <td>_threshold</td>
      <td>weather element value</td>
    </tr>
    <tr>
      <td>_weight</td>
      <td>number between 0 and 1</td>
    </tr>
    <tr>
      <td>_valueStr</td>
      <td>string representing a weather element value</td>
    </tr>
    <tr>
      <td>_valueList</td>
      <td>list of thresholds corresponding to value strings for weather
element values</td>
    </tr>
    <tr>
      <td>_value_connector</td>
      <td>text string for connecting values e.g. " to " as in "25 to 35
mph"</td>
    </tr>
    <tr>
      <td>_nlValue</td>
      <td>This suffix indicates that the method can return either a
single value, a method, OR a dictionary of (lowValue, highValue) :
returnValue&nbsp; entries.&nbsp; See the section on "Non-linear
Thresholds" for more information.</td>
    </tr>
  </tbody>
</table>
</center>
<h2> <a name="SampleAnalysis"></a>Sample Analysis</h2>
The Python methods described in this section can be found in the
SampleAnalysis module which appears in the Utilities window of the
Define Text Products Dialog.&nbsp; Each method is listed with the value
it returns.&nbsp; All methods return "None" if there is no data
available.
<h4><a name="StatisticsByTime"></a>Statistics By Time Range</h4>
&nbsp;Methods that are starred (**) below&nbsp; (e.g. **avg) can be
listed in the analysisList with an optional argument list&nbsp;
indicating how the time range is to be divided in reporting
statistics.&nbsp; A typical analysisList entry might look like this:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "analysisList" : [ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MaxT", self.avg), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
] </p>
<p>The result of the analysis will be a simple average value for the
entire time range being examined.&nbsp;&nbsp; Using the optional
"divide" argument, the analysisList might look like this: </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "analysisList" : [ <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MaxT", self.avg, [6]), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
] </p>
<p>In this instance, the time range will be divided into 6-hour
sub-ranges and an average value for MaxT will be reported for each
sub-range. This information will be reported as a list of tuples. For
example, a 12-hour time range would produce: </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[ (avg1, subRange1), (avg2, subRange2)] </p>
<p>The time range is divided from the endtime backward so that "odd"
sub-ranges occur at the beginning of the time range.&nbsp; For example,
suppose we are dividing an 8 hour time range into 6-hour
sub-ranges.&nbsp; This will result in a 2-hour sub-range followed by a
6-hour sub-range. </p>
<p>The Text Rules methods are built to handle varying types of Sample
Analyis return values. </p>
<p>If the time-divide argument is zero,&nbsp; the statistics will be
reported "byTimeRange" returning a list of (statistics, subRange)
tuples,&nbsp; one for each grid overlapping timeRange being examined. </p>
<p>In summary, the following table shows analysisList methods and their
corresponding results: <br>
&nbsp; <br>
&nbsp; </p>
<center><br>
<table nosave="" border="1" width="75%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr nosave="">
      <td>ANALYSIS LIST SPECIFICATION</td>
      <td nosave="">RESULT</td>
    </tr>
    <tr>
      <td>("MinT", self.avg)</td>
      <td>Average scalar value over the entire time range</td>
    </tr>
    <tr>
      <td>("MinT", self.avg, [0])&nbsp;</td>
      <td>List of (avg, subRange) tuples, one for each grid overlapping
timeRange</td>
    </tr>
    <tr>
      <td>("MinT", self.avg, [3])&nbsp;</td>
      <td>TimeRange is divided into 3-hour sub-ranges and
returns:&nbsp; <br>
&nbsp;List of (avg, subRange) tuples, one for each sub-range</td>
    </tr>
    <tr>
      <td>("MinT", self.avg, [6])&nbsp;</td>
      <td>TimeRange is split into 6-hour sub-ranges and returns:&nbsp; <br>
&nbsp;List of (avg, subRange) tuples, one for each sub-range</td>
    </tr>
  </tbody>
</table>
</center>
<p><b>NOTE</b> that if there is no data for ANY ONE&nbsp; of the
subRanges,&nbsp; None is returned for the entire time range. </p>
<h4><a name="ArgumentstoSampleAnalysis"></a>Arguments to Sample
Analysis Methods</h4>
The SampleAnalysis thresholds and variables take several arguments
which contain useful information allowing you to return values based on
product type, edit area, weather element or time range.&nbsp; The
following table lists the arguments and shows how to access the
information they contain. <br>
&nbsp; <br>
&nbsp;
<center><br>
<table nosave="" border="1" width="75%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>ARGUMENT</td>
      <td>ACCESSING INFORMATION</td>
    </tr>
    <tr>
      <td>parmHisto</td>
      <td>Weather Element:&nbsp;&nbsp;&nbsp; elementName =
parmHisto.parmID().parmName()&nbsp; <br>
Edit
Area:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
editAreaName = parmHisto.area().id().name()</td>
    </tr>
    <tr>
      <td>timeRange</td>
      <td>Time Range over which statistics are being generated.&nbsp;
This is always in GMT.&nbsp; <br>
&nbsp;&nbsp;&nbsp; timeRange.startTime()&nbsp; <br>
&nbsp;&nbsp;&nbsp; timeRange.startTime().day(),&nbsp;&nbsp;
timeRange.startTime().month(),&nbsp; timeRange.startTime().hour()&nbsp;
      <br>
&nbsp;&nbsp;&nbsp; timeRange.endTime()</td>
    </tr>
    <tr>
      <td>componentName</td>
      <td>Current Text Product component being analyzed</td>
    </tr>
  </tbody>
</table>
<br>
&nbsp; <br>
</center>
<h4><a name="Checking_for_Edit_Areas_Sample"></a>Checking for Edit Areas</h4>
Sometimes you might want to check to see if you are processing a
particular edit area or set of edit areas.&nbsp; For example, you might
want to base the analysisMethod on the current Edit Area.&nbsp; To do
this,&nbsp; set up an analysis method in the "analysisList" as follows:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("Wind",
self._wind_analysisMethod), <br>
<br>
Then include this analysis method in your override file:<br>
<br>
&nbsp; &nbsp;&nbsp; def _wind_analysisMethod(self, parmHisto,
timeRange, componentName): <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ChannelZone = ["PHZ130"] <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
argDict = self._argDict <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;
argDict["editArea"] = (parmHisto.area(), "") <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if
self.currentAreaContains(argDict, ChannelZone): <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return self.vectorModeratedMax(parmHisto, timeRange, componentName) <br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; else: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;
&nbsp;&nbsp; return self.vectorModeratedMinMax(parmHisto, timeRange,
componentName) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
<p><a name="GLOBALTHRESHOLDSAND"></a><b>GLOBAL THRESHOLDS AND VARIABLES</b>
</p>
<p>There are four categories of analysis methods: absolute, cumulative,
standard deviation (stdDev) and moderated (percentage).&nbsp; The
absolute and cumulative categories do not filter the sampled data. All
statistics are based on the entire&nbsp; sampled data set.&nbsp; The
standard deviation (stdDev) and moderated methods do filter the sampled
data set, however.&nbsp; The stdDev methods ignore values that lie
outside a configurable number of standard deviations from the
mean.&nbsp; Low and high thresholds are defined independently. The
moderated methods work exactly the same way as stdDev methods, except
that they filter data based on a ranked percentage.&nbsp; Values are
ranked, low to high, and outliers are excluded from the data set (e.g.,
the upper 10%). </p>
<p>Most analysis methods screen grids for temporal coverage of the
given time range before including their data values in the
analysis.&nbsp;&nbsp;&nbsp; The exceptions to this are the methods that
work with accumulative elements. The following table describes the
temporal coverage thresholds you can override for this screening
process.&nbsp; To override a threshold, simply copy the method from the
SampleAnalysis utility into your _Overrides file and change desired
values.&nbsp; Most methods weight grids temporally as well. Each grid
will contribute
proportional to its time duration for the sampled period. <br>
</p>
<center>
<table nosave="" border="1" width="75%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr nosave="">
      <td nosave=""><a name="temporalCoverage_percentage"></a><i><font
 color="#993366">temporalCoverage_percentage</font></i></td>
      <td>This is the
percentage
of the given time range COVERED by the grid in order to include it in
the analysis.&nbsp; This is the value used IF a value is not found in
the
temporalCoverage_dict (see below)&nbsp; <br>
NOTE: The temporalCoverage_hours (see below) must also be met by the
grid for it to be included.<br>
In addition, if a grid is completely contained
within the time range, it will automatically be included.&nbsp; <br>
Default is 20 percent.</td>
    </tr>
    <tr>
      <td><i><font color="#993366">temporalCoverage_dict</font></i></td>
      <td>Temporal Coverage percentage specified by Weather Element.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><i><font color="#993366">temporalCoverage_hours</font></i></td>
      <td style="vertical-align: top;">This is the
hours of the given time range COVERED by the grid in order to include
it in
the analysis.&nbsp; This is the value used IF a value is not found in
the
temporalCoverage_hours_dict (see below)&nbsp; <br>
NOTE: The temporalCoverage_percentage (see above) must also be met by
the grid for it to be included.<br>
In addition, if a grid is completely contained
within the time range, it will automatically be included.&nbsp; <br>
Default is 0 percent.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><i><font color="#993366">temporalCoverage_hours_dict</font></i></td>
      <td style="vertical-align: top;">Temporal Coverage hours
specified by Weather Element.</td>
    </tr>
    <tr>
      <td><i><font color="#993366">moderatedDefault</font></i></td>
      <td>The value used by all "moderated" methods by default if the
weather element does not appear in the moderated_dict. The
moderated_dict value always overrides this default value.&nbsp; This
value is used for the min and max values.</td>
    </tr>
    <tr>
      <td><i><font color="#993366">moderated_dict</font></i></td>
      <td>Returns a dictionary that defines the min and max filter
values for all "moderated" methods. For each weather element, a tuple
defines the minimum threshold and the maximum threshold
respectively.&nbsp; All moderated methods rank all sampled values from
lowest to highest and then exclude values that are below the minimum
threshold and above the maximum threshold.</td>
    </tr>
    <tr>
      <td><i><font color="#993366">stdDevDefault</font></i></td>
      <td>The value used by all "stdDev" methods by default if the
weather element does not appear in the stdDev_dict. The stdDev_dict
value always overrides this default value.&nbsp; This value is used for
the min and max values.</td>
    </tr>
    <tr>
      <td><i><font color="#993366">stdDev_dict</font></i></td>
      <td>Returns a dictionary that defines the low and high limit at
which outliers will be removed when calculating stdDev stats. These
tuples represent the (low, high) number of standard&nbsp; <br>
deviations.&nbsp; Any values falling outside this range will not be
included in the calculated statistic.&nbsp;</td>
    </tr>
    <tr>
      <td><i><font color="#993366">bin_dict</font></i></td>
      <td>Returns a dictionary that defines the bin values for
"binnedPercent". Bin tuples represent (low, high) values for each bin.
Bin values are inclusive.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><i><font color="#993366">maxMode_increment_dict</font></i></td>
      <td style="vertical-align: top;">Returns the increment to be used
for "maxMode" when "binning" values before computing mode.&nbsp; For
example, the default "maxMode_increment" for "PoP" is 10.&nbsp;</td>
    </tr>
  </tbody>
</table>
</center>
<p>Here is how the standard deviation SampleAnalysis methods work: <br>
1) compute the standard deviation of all grid values <br>
2) the <font color="#993399"><i>stdDev_dict</i> </font>contains a
threshold, i.e., number of sigmas for each the min and the max <br>
3) the routine calculates the min and max from the std deviation and
the sigmas <br>
4) in some cases, the result may fall outside of the actual data
range.&nbsp; In this case, the returned values will be the min or max
of
the actual data points. </p>
<p>Here is how the moderated SampleAnalysis methods work: <br>
1) compute the "histogram" of the data values <br>
2) the <i><font color="#993399">moderated_dict </font></i>gives a
percentage for min, and a percentage for max <br>
3) we return values that are % percent from the min and % percent from
the max, not numerically, but from a sorted list.&nbsp; Thus if the
histogram is <br>
4,4,5,6,7,8,9,10,15,19, and your percent is 20% for the min and 10% for
the max, you will pick out the 20% of the number and the 90% of the
number in the <br>
sequence.&nbsp; Since there are exactly 10 samples in my exmaple, the
20% point will be 5, and the 90% point will be 15.&nbsp; It isn't
numerical. </p>
<p>Here is some further explanation (from Bill Schneider) on the
moderated methods: </p>
<p>The moderated methods look at all the points in the grid, then they
throw away highest (for max) or lowest (for min) percentage you have
specified in the moderated dictionary. Then it uses the max or min of
the remaining gridpoints. </p>
<p>So for example if you use moderatedMaximum for temperature and have
defined the moderated percentages fore temperature as (10,15) in the
dictionary, the method will take the grid points that have the highest
values and throw away the top 15 percent of them. The remaining maximum
value will be reported. For moderatedMinimum, the method will take the
grid points that have the lowest values and throw away 15 % of the
lowest values before reporting the minimum. <br>
&nbsp; </p>
<p><a name="SCALARWEATHERElements"></a><b>SCALAR WEATHER ELEMENTS</b> <br>
</p>
<center>
<table nosave="" border="1" width="75%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr nosave="">
      <td nosave=""><font color="#000000">METHOD&nbsp;</font></td>
      <td><font color="#000000">RETURN VALUE:</font></td>
    </tr>
    <tr>
      <td><font color="#000000">**avg&nbsp;</font></td>
      <td><font color="#000000">average value</font></td>
    </tr>
    <tr>
      <td><font color="#000000">**minMax</font></td>
      <td><font color="#000000">&nbsp;(min, max)</font></td>
    </tr>
    <tr>
      <td><font color="#000000">**minimum</font></td>
      <td><font color="#000000">minimum value</font></td>
    </tr>
    <tr>
      <td><font color="#000000">**maximum</font></td>
      <td><font color="#000000">maximum value</font></td>
    </tr>
    <tr>
      <td><font color="#000000">**median&nbsp;</font></td>
      <td><font color="#000000">median value for given time range</font></td>
    </tr>
    <tr nosave="">
      <td><font color="#000000">**medianRange&nbsp;</font></td>
      <td nosave=""><font color="#000000">2-value range around the
median value for given time range</font></td>
    </tr>
    <tr>
      <td><font color="#000000">**mode&nbsp;</font></td>
      <td><font color="#000000">mode value for given time range</font></td>
    </tr>
    <tr nosave="">
      <td><font color="#000000">**modeRange&nbsp;</font></td>
      <td nosave=""><font color="#000000">2-value range around the mode
value for given time range</font></td>
    </tr>
    <tr>
      <td><font color="#000000">firstAvg&nbsp;</font></td>
      <td><font color="#000000">average value for first grid only</font></td>
    </tr>
    <tr>
      <td><font color="#000000">firstMinMax</font></td>
      <td><font color="#000000">minmax value for the first grid only</font></td>
    </tr>
    <tr>
      <td><font color="#000000">minMaxAvg&nbsp;</font></td>
      <td><font color="#000000">&nbsp;(min, max, avg)</font></td>
    </tr>
    <tr>
      <td><font color="#000000">minMaxSum&nbsp;</font></td>
      <td><font color="#000000">&nbsp;( min, max, sum)</font> <br>
      <font color="#000000">Time-weighted min/max/ave of&nbsp; the
multiple grids overlapping the time range. This is used for
rate-dependent weather elements such as QPF.</font></td>
    </tr>
    <tr>
      <td><font color="#000000">accumMinMax</font></td>
      <td><font color="#000000">&nbsp;(min, max,&nbsp; sum)</font> <br>
      <font color="#000000">Returns the min, max, and sum for
rate-dependent weather elements such as QPF.</font></td>
    </tr>
    <tr>
      <td><font color="#000000">accumSum</font></td>
      <td><font color="#000000">sum</font> <br>
      <font color="#000000">Returns the sum for rate-dependent weather
elements such as QPF.</font></td>
    </tr>
    <tr>
      <td><font color="#000000">**maxAvg&nbsp;</font></td>
      <td><font color="#000000">average value.</font> <br>
      <font color="#000000">Calculates the average value&nbsp; in each
of the overlapping grids, and then returns the maximum of the averages.</font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;">**maxMode</td>
      <td style="vertical-align: top;">Calculates the mode value in
each of the overlapping grids, and thern returns the maximum of the
modes.&nbsp; Before calculating the mode, the values are rounded to the
nearest increment as given in the <i><font color="#993399">maxMode_increment_dict</font></i></td>
    </tr>
    <tr>
      <td>**stdDevMaxAvg</td>
      <td>average value.&nbsp; <br>
Calculates the average value after filtering by standard deviation and
then returns the maximum of the averages.</td>
    </tr>
    <tr>
      <td>**moderatedMaxAvg</td>
      <td>average value.&nbsp; <br>
Calculates the average value after filtering by moderated (percentage)
and then returns the maximum of the averages.</td>
    </tr>
    <tr>
      <td>**stdDevAvg</td>
      <td>average value after filtering based on stdDev</td>
    </tr>
    <tr>
      <td>stdDevFirstAvg</td>
      <td>average value for the first grid only</td>
    </tr>
    <tr>
      <td><font color="#000000">**stdDevMinMax</font></td>
      <td><font color="#000000">&nbsp;(min, max)</font> <br>
      <font color="#000000">min, max set at standard deviations around
the mean.</font> <br>
      <font color="#000000">The <i>stdDev_dict</i>, defines the number
of standard deviations to compute min, max around the mean. Default is
1.0 standard deviations. Both min and max can be defined independently
per weather element.</font></td>
    </tr>
    <tr>
      <td>**stdDevMin</td>
      <td>same as stdDevMinMax except just returns the minimum value</td>
    </tr>
    <tr>
      <td>**stdDevMax</td>
      <td>same as stdDevMinMax except just returns the maximum value</td>
    </tr>
    <tr>
      <td><font color="#000000">stdDevFirstMinMax</font></td>
      <td><font color="#000000">(min,max)&nbsp;</font> <br>
      <font color="#000000">stdDevMinMax (see above) for the first grid
only</font></td>
    </tr>
    <tr>
      <td>**moderatedAvg</td>
      <td>Returns the average value after filtering based on percentage
defined in <i><font color="#993399">moderated_dict</font></i></td>
    </tr>
    <tr>
      <td>**moderatedMinMax</td>
      <td>(min, max)&nbsp; <br>
Returns the min and max values after filtering based on the percentage
defined in <i><font color="#993399">moderated_dict.</font></i></td>
    </tr>
    <tr>
      <td>**moderatedMin</td>
      <td>same as moderatedMinMax except just returns the minimum</td>
    </tr>
    <tr>
      <td>**moderatedMax</td>
      <td>same as moderatedMinMax except just returns the maximum</td>
    </tr>
    <tr>
      <td>moderatedFirstAvg</td>
      <td>same as moderatedAvg except only the first grid is sampled</td>
    </tr>
    <tr>
      <td>moderatedFirstMinMax</td>
      <td>same as moderatedMinMax except only the first grid is sampled.</td>
    </tr>
    <tr>
      <td>hourlyTemp&nbsp;</td>
      <td>return hourly T values in tuples;&nbsp; returns a list of
tuples:&nbsp;&nbsp;&nbsp; (avgValue, startHour)</td>
    </tr>
    <tr>
      <td>binnedPercent</td>
      <td>return a list of tuples representing bins and corresponding
percentages of values in each bin. The bins are defined in the <i>bins_dict.</i><font
 color="#000000">NOTE: When using this method, make sure you have grids
covering the entire time range of interest so that the percentages
which
are time-weighted will add up to 100.</font></td>
    </tr>
  </tbody>
</table>
</center>
<br>
&nbsp;
<p><a name="VECTORWEATHERElements"></a><b>VECTOR WEATHER ELEMENTS</b> </p>
<p>Note: all vector directions are returned as numeric.&nbsp;&nbsp; You
can set the <i><font color="#993366">vectorDirection_algorithm </font></i>to
be "Average" or "MostFrequent".&nbsp; It will then apply to all vector
analysis methods.&nbsp;
</p>
<center>
<table nosave="" border="1" width="75%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>**vectorAvg&nbsp;</td>
      <td>(mag, dir)&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorMinMax</td>
      <td>((minMag, maxMag), dir)&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorMin&nbsp;</td>
      <td>(minMag, dir)</td>
    </tr>
    <tr>
      <td>**vectorMax</td>
      <td>(maxMag, dir)</td>
    </tr>
    <tr>
      <td>vectorMagMinMax&nbsp;</td>
      <td>(minMag, maxMag)&nbsp;</td>
    </tr>
    <tr>
      <td>vectorMagMin</td>
      <td>minMag&nbsp;</td>
    </tr>
    <tr>
      <td>vectorMagMax</td>
      <td>maxMag&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorMode&nbsp;</td>
      <td>(mag, dir)</td>
    </tr>
    <tr>
      <td>**vectorMedian&nbsp;</td>
      <td>(mag, dir)&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorModeRange&nbsp;</td>
      <td>((minMag, maxMag), dir)&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorMedianRange</td>
      <td>((minMag, maxMag), dir)&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorStdDevAvg</td>
      <td>(mag, dir)&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorStdDevMinMax</td>
      <td>((minMag, maxMag), dir)&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorStdDevMin&nbsp;</td>
      <td>(minMag, dir)</td>
    </tr>
    <tr>
      <td>**vectorStdDevMax&nbsp;</td>
      <td>(maxMag, dir)</td>
    </tr>
    <tr>
      <td>**vectorModeratedAvg</td>
      <td>(mag, dir)&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorModeratedMinMax</td>
      <td>((minMag, maxMag), dir)&nbsp;</td>
    </tr>
    <tr>
      <td>**vectorModeratedMin&nbsp;</td>
      <td>(minMag, dir)</td>
    </tr>
    <tr>
      <td>**vectorModeratedMax&nbsp;</td>
      <td>(maxMag, dir)</td>
    </tr>
    <tr>
      <td>vectorRange</td>
      <td>(mag1, mag2, dir1, dir2)&nbsp; <br>
returns mag and dir for two specified periods</td>
    </tr>
    <tr>
      <td>vectorBinnedPercent</td>
      <td>return a list of tuples representing bins and corresponding
percentages of magnitude values in each bin. The bins are defined in
the <i>bins_dict.</i><font color="#000000">NOTE: When using this
method, make sure you have grids
covering the entire time range of interest so that the percentages
which
are time-weighted will add up to 100.</font></td>
    </tr>
  </tbody>
</table>
</center>
<p><a name="DISCRETEELEMENTS"></a><b>DISCRETE ELEMENTS</b> <br>
</p>
<center>
<table nosave="" border="1" width="75%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr nosave="">
      <td nosave="">METHOD</td>
      <td>RETURN VALUE</td>
      <td>THRESHOLDS AND VARIABLES&nbsp; <br>
(To override, find in SampleAnalysis and copy to Overrides file)</td>
    </tr>
    <tr>
      <td>discreteTimeRangesByKey&nbsp;</td>
      <td>List of (discreteKey, timeRange) pairs ordered in ascending
order by timeRange and then by priority of discrete keys as defined in
the serverConfig files.</td>
      <td><i><font color="#993366">discreteKey_coverage_percentage</font></i><font
 color="#000000">-- required&nbsp; coverage by discete key</font> <i><font
 color="#993366"><br>
      </font></i><font color="#000000"></font></td>
    </tr>
    <tr>
      <td style="vertical-align: top;">discreteTimeRangesByKey_withAux</td>
      <td style="vertical-align: top;">Same as above, but including the
auxiliary field<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td>**dominantDiscreteValue</td>
      <td>List of most common discrete keys ranked from most frequent
to least frequent.&nbsp;&nbsp;</td>
      <td><i><font color="#993366">discreteKey_coverage_percentage</font></i><font
 color="#000000">--&nbsp; required coverage by discete key</font> <br>
      <i><font color="#993366">dominantDiscreteKeys_threshold-</font></i><font
 color="#000000">- maximum number of discrete keys to be returned from
dominantDiscreteValue<br>
      </font><i><font color="#993366">cleanOutEmptyValues <span
 style="color: rgb(51, 0, 51);"></span></font></i><font color="#993366"><span
 style="color: rgb(51, 0, 51);">-- whether or not to leave &lt;None&gt;
values out of list of keys</span></font><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">**dominantDiscreteValue_withAux</td>
      <td style="vertical-align: top;">Same as above, but including the
auxiliary field</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">**rankedDiscreteValue</td>
      <td style="vertical-align: top;">List of most common (discrete
keys, rank) pairs listed from most frequent
to least frequent.&nbsp;&nbsp;</td>
      <td style="vertical-align: top;"><i><font color="#993366">discreteKey_coverage_percentage</font></i><font
 color="#000000">--&nbsp; required coverage by discete key</font> <br>
      <i><font color="#993366">dominantDiscreteKeys_threshold-</font></i><font
 color="#000000">- maximum number of discrete keys to be returned from
dominantDiscreteValue<br>
      </font><i><font color="#993366">cleanOutEmptyValues <span
 style="color: rgb(51, 0, 51);"></span></font></i><font color="#993366"><span
 style="color: rgb(51, 0, 51);">-- whether or not to leave &lt;None&gt;
values out of list of keys (default 0)</span></font><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">**rankedDiscreteValue_withAux</td>
      <td style="vertical-align: top;">Same as above, but including the
auxiliary field<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td>discrete_percentages</td>
      <td>list of (discrete key, percentage) pairs.&nbsp; Time-weighted
/ areal-weighted percentage is calculated for all overlapping grids</td>
      <td>None</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">discrete_percentages_withAux</td>
      <td style="vertical-align: top;">Same as above, but including the
auxiliary field</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
  </tbody>
</table>
</center>
<br>
&nbsp;
<p><a name="WXElement"></a><b>WX&nbsp; ELEMENT</b> &nbsp; <br>
</p>
<center>
<table nosave="" border="1" width="75%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr nosave="">
      <td nosave="">METHOD</td>
      <td>RETURN VALUE</td>
      <td>THRESHOLDS&nbsp; <br>
AND VARIABLES&nbsp; <br>
(To override, find in SampleAnalysis and copy to Overrides file)</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">**rankedWx<br>
      </td>
      <td style="vertical-align: top;">list of (subkey, rank) pairs
found for a given time range.&nbsp; rank is based on temporal and areal
coverage of the subkey in the time range<br>
      </td>
      <td style="vertical-align: top;"><i><font color="#993366">coverage_weights_dict</font></i><font
 color="#000000"> - weights per coverage term </font><br>
      <i><font color="#993366">wxkey_coverage_percentage</font></i><font
 color="#000000">-- areal coverage over the time period by weather key</font>
      <br>
      <i><font color="#993366">attribute_coverage_percentage</font></i><font
 color="#000000">-- areal coverage over the time period for attributes</font><br>
      <i><font color="#993366">dominantKeys_threshold-</font></i><font
 color="#000000">- maximum number of weather keys to be returned from
dominantWx<br>
      </font><i><font color="#993366">aggregateCov_algorithm </font></i><font
 color="#000000">- can use highest ranked coverage or a weighted scheme<br>
      </font><i><font color="#993366">cleanOutEmptyValues <span
 style="color: rgb(51, 0, 51);"></span></font></i><font color="#993366"><span
 style="color: rgb(51, 0, 51);">-- whether or not to leave &lt;NoWx&gt;
values out of list of keys (default 0)</span></font><br>
      </td>
    </tr>
    <tr>
      <td>**dominantWx&nbsp;</td>
      <td>list of subkeys found for the given time range</td>
      <td>same as rankedWx<font color="#000000"></font></td>
    </tr>
  </tbody>
</table>
</center>
<h4> <a name="dominantWx"></a>Algorithm for rankedWx and dominantWx</h4>
The rankedWx and dominantWx algorithms use configurable thresholds and
weights to give you control over the weather that you choose to submit
to Text Rules for phrase generation.&nbsp; The only difference between
rankedWx and dominantWx is that the rankedWx method returns tuples of
(subkey, rank) pairs while the dominantWx method simply returns the
list of subkeys.&nbsp; The algorithm is as follows:
<ul>
  <li>Throw out any grids that do not cover the <i><font
 color="#993366">temporalCoverage_percentage </font></i>of the given
time range.</li>
  <li>For each weather type in the grids, determine:</li>
  <ul>
    <li>an aggregate subkey</li>
    <ul>
      <li>coverage -- aggregate coverage algorithm can be chosen by
overriding "aggregateCov_algorithm" (SampleAnalysis). There are 2
choices:</li>
      <ul>
        <li>"getAggregateCov" chooses the highest ranked coverage
(default)<br>
        </li>
        <li>"getWeightedAggregateCov" favors stronger coverage
terms. <br>
        </li>
      </ul>
      <li>intensity -- highest ranking OR if ranks are close, dominant</li>
      <li>visibility -- lowest visibility</li>
      <li>attributes -- aggregate of all occurrences</li>
    </ul>
    <li>a rank i.e. the percentage of areal coverage over the time
period.&nbsp; This raw rank is then weighted by the coverage term.<br>
    </li>
  </ul>
  <li>Throw out any weather type that does not meet the <i><font
 color="#993366">wxkey_coverage_percentage</font></i> except:</li>
  <ul>
    <li>If a weather subkey is designated "Primary" it will be the
aggregate subkey and will automatically be the highest ranked.</li>
  </ul>
  <ul>
    <li>If a weather subkey is designated as "Mention", it will be the
aggregate subkey and will not be eliminated.<br>
    </li>
  </ul>
  <li>Return the <i><font color="#993366">dominantKeys threshold</font></i>
number of weather subkeys sorted by rank, wxType, and coverage<br>
  </li>
  <li>For rankedWx, the computed rank is returned with each
subkey&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <br>
  </li>
</ul>
&nbsp;We use the rank when
combining subkeys and in weather phrasing and wording as follows:<br>
<br>
<div style="margin-left: 40px;">&nbsp;&nbsp;&nbsp; def
rankFuzzFactor(self): <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Used when combining
weather subkeys. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If the difference between
the subkey rankings is <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # less than this amount, the
subkeys will be combined and <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the dominant coverage or
intensity will be chosen <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Also used in weather
wording to determine if <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # subkeys have significantly
different ranks. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If so, then wording such
as "possibly mixed with" or <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # "with pockets of" could be
used. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 10 &nbsp; <br>
<div style="text-align: left;"><small><small></small></small><br>
</div>
</div>
For more information, see the section on <a href="#WEATHERKEYFILTERING">Weather
Phrasing.</a><br>
<h2><a name="TextRulesLibrariesforSimpleTableProducts"></a>Text
Rules Libraries for Simple Table Products</h2>
(To be supplied)
<h2><a name="TextRulesLibrariesforSmartTabularProducts"></a>Text
Rules Libraries for Smart Tabular Products</h2>
(To be supplied)
<h2><a name="TextRule"></a>Text Rules Libraries for Narrative Products</h2>
<h4> <a name="NarrativeTreeandPhraseBuilderInfrastructure"></a>Narrative
Tree and Phrase Builder Infrastructure</h4>
(to be supplied) <br>
&nbsp;
<p>The Text Rules and all of it's inherited libraries can be found in
the Utilities window of the Define Text Products Dialog.&nbsp;&nbsp;
This section describes the threshold, variable and phrase methods in
the
TextRules libraries to support Narrative Products.&nbsp; This
information will help you customize your narrative product by looking
up
the phrases that are being generated in the "phraseList" of your
product
components.&nbsp; For each weather element (or combinations of weather
elements), we list Example Phrases, corresponding SampleAnalysis
methods, and Thresholds and variables you can set to customize the
phrase. <br>
&nbsp; </p>
<h4><a name="SettingDAYandNIGHTtimes"></a>Setting DAY and NIGHT
times</h4>
Most formatters work on the assumption that "daytime" is from 6 am to 6
pm local time and "nighttime" is 6 pm to 6 am the next day local
time.&nbsp; If you want to change that assumption, you can override the
following variables simply by including them in your local file:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
def DAY(self): <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 6 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def
NIGHT(self): <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 18 <br>
&nbsp; </p>
<h4><a name="Analysis-DrivenPhrases"></a>Analysis-Driven Phrases</h4>
Most phrase methods accept results from any SampleAnalysis method for
the appropriate data type (Scalar, Vector, Wx), and will report with an
appropriate temporal resolution.&nbsp; Some phrase methods are
expecting
certain statistics.&nbsp; In the tables below, if the statistics method
is starred, any temporal resolution is accepted&nbsp; -- otherwise only
what's shown.
<p>If a threshold or variable appears in <b><font color="#993366">bold</font>,
</b>then
it MUST be set in order for the phrase to appear. </p>
<h4><a name="ArgumentstoTextRulesClass"></a>Arguments to Narrative
Methods</h4>
The TextRules thresholds, variables, and methods take arguments which
contain useful information allowing you to return values based on
product type, edit area, weather element or time range.&nbsp; The
following table lists the arguments and shows how to access the
information they contain. <br>
&nbsp; <br>
&nbsp;
<center><br>
<table nosave="" border="1" width="95%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr nosave="">
      <td nosave="">ARGUMENT</td>
      <td>DESCRIPTION</td>
      <td>ACCESSING INFORMATION</td>
    </tr>
    <tr>
      <td>tree</td>
      <td>Narrative tree contains the structure and information for the
entire narrative product</td>
      <td>tree.stats.get(elementName, timeRange, areaLabel, statLabel,
mergeMethod) -- allows you to get statistics&nbsp; e.g.&nbsp;
      <p>stats = tree.stats.get("Wind", timeRange, "CO_Boulder",
"vectorMinMax", "List") </p>
      <p>productTimeRange = tree.getTimeRange() <br>
productStartTime = productTimeRange.startTime()</p>
      </td>
    </tr>
    <tr>
      <td>node</td>
      <td>The node of the tree at which we are currently executing
methods.</td>
      <td>&nbsp;The current time range:&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nodeTimeRange = node.getTimeRange() <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
nodeStartTime = nodeTimeRange.startTime()
      <p>The current edit area:&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node.getAreaLabel()&nbsp; </p>
      <p>The current product component,&nbsp; name, definition, or
position:&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component
= node.getComponent()&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
componentName = node.getComponentName()&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
componentDef = component.get("definition") <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
componentPosition = node.getComponentPosition() <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# tells it's position (1,2,3...) in the Narrative Definition </p>
      <p>To see if the current edit area (which could be a Combination)
contains any of a list of edit areas:&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inlandWaters =
["TampaBayWaters"]&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
self.currentAreaContains(tree, inlandWaters):&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; do special case for TampaBayWaters&nbsp; </p>
      <p>The current phrase:&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node.getAncestor("name")&nbsp; <br>
Note: This will only work for a node within a "phrase" method.&nbsp; </p>
      <p>The "getAncestor" method finds the first ancestor with the
given attribute and returns the attribute's value.</p>
      </td>
    </tr>
    <tr>
      <td>elementName</td>
      <td>Weather element name -- useful information for returning
threshold or variable values based on weather element</td>
      <td><br>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h4> <a name="CheckingforEdit"></a>Checking for Edit Areas</h4>
Sometimes you might want to check to see if you are processing a
particular edit area or set of edit areas.&nbsp; For example, if you
running a CWF product and setting a threshold for WindWaveHgt, you
might
want to know if you processing an "inland waters area" or
not.&nbsp;&nbsp; There is an EditAreaUtils library method to help you
do
this which is illustrated through the following example:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
inlandWatersAreas = ["TampaBayWaters", "InlandWaters"] <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if self.currentAreaContains(tree, inlandWatersAreas): <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Return a value for the inland waters areas <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Return a value for the&nbsp; other areas </p>
<h4><a name="TextGlobals"></a>GLOBAL THRESHOLDS AND VARIABLES</h4>
To override these thresholds and variables, find them in the designated
library module and copy them into the Overrides product file. <br>
NOTE:&nbsp; There are many more thresholds and variables in the
ConfigVariables module which, to avoid redundancy, are not listed
here.&nbsp; Please refer to that module directly to learn of the many
ways you can customize the formatters.<br>
<center><br>
<table border="1" width="90%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td><font color="#000000">THRESHOLD OR VARIABLE</font></td>
      <td>DESCRIPTION</td>
      <td>LIBRARY</td>
    </tr>
    <tr>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i></td>
      <td>Descriptor words for weather elements in phrases e.g. "North <i>winds</i>
5-10 mph."</td>
      <td>ConfigVariables</td>
    </tr>
    <tr>
      <td><i><font color="#993366">phrase_connector_dict</font></i></td>
      <td>Connecting words in phrases e.g. "North winds 5-10 mph <i>becoming</i>20-25
mph.</td>
      <td>ConfigVariables</td>
    </tr>
    <tr>
      <td><i><font color="#993366">value_connector_dict</font></i></td>
      <td>Connectors for ranges of values e.g. "North winds 5 <i>to</i>
10 mph."</td>
      <td>ConfigVariables</td>
    </tr>
    <tr>
      <td><i><font color="#993366">units_descriptor_dict</font></i></td>
      <td>Words for units used in reporting data values e.g. "North
winds 5-10 <i>knots</i>."</td>
      <td>ConfigVariables</td>
    </tr>
    <tr>
      <td><i><font color="#993366">timePeriod_descriptor_list</font></i></td>
      <td>Phrases for sub-ranges of a time period e.g. "Partly cloudy <i>in
the afternoon</i>."</td>
      <td>TimeDescriptor</td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><i><font color="#993366">scalar_difference_nlValue_dict</font></i></td>
      <td style="vertical-align: top;">If the difference between scalar
values for 2 sub-periods is greater than or equal to this value, the
different values will be noted in the phrase.<br>
      </td>
      <td style="vertical-align: top;">ConfigVariables<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><i><font color="#993366">vector_mag_difference_nlValue_dict<br>
vector_dir_difference_nlValue_dict<br>
      </font></i></td>
      <td style="vertical-align: top;">If the difference between vector
values for 2 sub-periods is greater
than or equal to these values, the different values will be noted in
the
phrase.</td>
      <td style="vertical-align: top;">ConfigVariables<br>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h4> <a name="NARRATIVEPHRASES"></a>NARRATIVE PHRASES</h4>
The following tables list the various phrases definitions found in Text
Rules library modules and used by the standard text narrative text
products.
<h4><a name="SCALARWEATHERELEMENT"></a>SCALAR WEATHER ELEMENT PHRASES
-- ScalarPhrases module</h4>
<center><br>
<table border="1" height="100%" width="95%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>ELEMENT</td>
      <td>TEXT RULES&nbsp; <br>
METHOD</td>
      <td>EXAMPLE PHRASES</td>
      <td>SAMPLE&nbsp; <br>
ANALYSIS</td>
      <td>THRESHOLDS AND VARIABLES&nbsp; <br>
(To override, find in ScalarPhrases or ConfigVariables and copy to
Overrides file)</td>
      <td>ADD'L&nbsp; <br>
INFO</td>
    </tr>
    <tr>
      <td><a name="Highlights"></a>Hazards</td>
      <td><a name="makeHeadlinePhrases"></a>makeHeadlinesPhrases</td>
      <td>.WINTER STORM WARNING IN EFFECT<br>
      </td>
      <td>No sampling by SampleAnalysis<br>
      </td>
      <td>&nbsp;<a href="#AllowedHazards">allowedHazards</a></td>
      <td>Found in DiscretePhrases module</td>
    </tr>
    <tr>
      <td>Sky</td>
      <td>sky_phrase</td>
      <td>"Partly cloudy in the&nbsp; <br>
morning, then clearing."</td>
      <td>Sky:&nbsp; <br>
**Scalar&nbsp; Stats&nbsp; <br>
**binnedPercent&nbsp;
      <p>PoP: (optional)&nbsp; <br>
**Scalar Stats&nbsp;</p>
      </td>
      <td><i><font color="#993366">pop_sky_lower_threshold</font></i> <br>
      <i><font color="#993366">clearing_threshold</font></i> <br>
      <i><font color="#993366">sky_valueList</font></i> <br>
      <i><font color="#993366">sky_value</font></i> <br>
      <i><font color="#993366">areal_sky_flag</font></i> <br>
      <i><font color="#993366">areal_sky_value<br>
areal_skyPercentage<br>
areal_skyRelatedWx<br>
      </font></i> <i><font color="#993366">similarSkyWords_list</font></i>
      <br>
      <i><font color="#993366">reportIncreasingDecreasingSky_flag</font></i>
      <br>
      <i><font color="#993366">reportClearSkyForExtendedPeriod_flag</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>PoP</td>
      <td>popMax_phrase</td>
      <td>"Chance of&nbsp; <br>
snow 40 percent."</td>
      <td>PoP: **maxAvg</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font> </i>for
"PoP"&nbsp; <br>
May use this method in the phrase_descriptor_dict:&nbsp; <br>
      <i>&nbsp;<font color="#993366">areal_or_chance_pop_descriptor</font></i>
      <br>
      <i><font color="#993366">units_descriptor_dict </font></i>for
"percent"&nbsp; <br>
      <i><font color="#993366">pop_lower_threshold</font></i> <br>
      <i><font color="#993366">pop_upper_threshold</font></i> <br>
      <i><font color="#993366">wxQualifiedPoP_flag <br>
matchToWxInfo_dict<br>
      </font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>MaxT&nbsp; <br>
MinT</td>
      <td>reportTrends</td>
      <td>"Warmer."&nbsp; <br>
"Much colder."</td>
      <td>MaxT, MinT&nbsp; <br>
avg, minMax,&nbsp; <br>
stdDevMinMax</td>
      <td><i><font color="#993366">reportTrends_valueStr </font></i><font
 color="#000000">to set up thresholds for trend phrases</font> <br>
      <font color="#000000">Phrases are based on 24 hour prior
statistics</font></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>MaxT&nbsp; <br>
MinT&nbsp; <br>
HeatIndex&nbsp; <br>
WindChill</td>
      <td>extremeTemps_phrase</td>
      <td>"Very hot."&nbsp; <br>
"Hot."&nbsp; <br>
"Bitterly cold."</td>
      <td>MaxT, MinT, HeatIndex, WindChill: **ScalarStats</td>
      <td><i><font color="#993366">heatIndex_threshold</font></i> <br>
      <i><font color="#993366">windChill_threshold</font></i></td>
      <td>This phrase may be used in place of "reportTrends"</td>
    </tr>
    <tr>
      <td>MinT</td>
      <td>lows_phrase</td>
      <td>"Lows in the lower 40s to lower 50s."</td>
      <td>MinT:&nbsp; <br>
minmax&nbsp; stdDevMinMax</td>
      <td><i><font color="#993366">phrase_descriptor_dict </font></i>for
"lows"&nbsp; <br>
      <i><font color="#993366">minimum_range_nlValue_dict</font></i> <br>
      <i><font color="#993366">maximum_range_nlValue_dict</font></i> <br>
      <i><font color="#993366">range_nlValue_dict</font></i> <br>
      <i><font color="#993366">tempPhrase_exceptions</font></i> <br>
      <i><font color="#993366">tempPhrase_boundary_dict</font></i></td>
      <td>Only generated if Night time</td>
    </tr>
    <tr>
      <td>MaxT</td>
      <td>highs_phrase</td>
      <td>"Highs in the upper 70s to lower 80s."</td>
      <td>MaxT:&nbsp; <br>
minMax&nbsp; stdDevMinMax</td>
      <td><i><font color="#993366">phrase_descriptor_dict </font></i>for
"highs"&nbsp; <br>
      <i><font color="#993366">minimum_range_nlValue_dict</font></i> <br>
      <i><font color="#993366">maximum_range_nlValue_dict</font></i> <br>
      <i><font color="#993366">range_nlValue_dict</font></i> <br>
      <i><font color="#993366">tempPhrase_exceptions</font></i> <br>
      <i><font color="#993366">tempPhrase_boundary_dict</font></i></td>
      <td>Only generated if Day time</td>
    </tr>
    <tr>
      <td>MinT</td>
      <td>lows_range_phrase</td>
      <td>"Lows 45 to 50."</td>
      <td>MinT:&nbsp; <br>
minMax&nbsp; stdDevMinMax</td>
      <td><i><font color="#993366">phrase_descriptor_dict </font></i><font
 color="#000000">for "lows"</font> <br>
      <i><font color="#993366">minimum_range_nlValue_dict</font></i> <br>
      <i><font color="#993366">maximum_range_nlValue_dict</font></i> <br>
      <i><font color="#993366">range_nlValue_dict</font></i> <br>
      <i><font color="#993366">value_connector_dict</font></i></td>
      <td>Only generated if Night time</td>
    </tr>
    <tr>
      <td>MaxT</td>
      <td>highs_ range_phrase</td>
      <td>"Highs 70 to 75."</td>
      <td>MaxT:&nbsp; <br>
minmax&nbsp; stdDevMinMax</td>
      <td><i><font color="#993366">phrase_descriptor_dict </font></i><font
 color="#000000">for "highs"</font> <br>
      <i><font color="#993366">minimum_range_nlValue_dict</font></i> <br>
      <i><font color="#993366">maximum_range_nlValue_dict</font></i> <br>
      <i><font color="#993366">range_nlValue_dict&nbsp;</font></i> <br>
      <i><font color="#993366">value_connector_dict</font></i></td>
      <td>Only generated if Day time</td>
    </tr>
    <tr>
      <td>MinT</td>
      <td>extended_lows&nbsp; <br>
_phrase</td>
      <td>"Lows in the 40s."&nbsp; <br>
"Lows 55 to 65."</td>
      <td>MinT:&nbsp; <br>
firstAvg</td>
      <td><i><font color="#993366">extended _temp_range</font></i></td>
      <td>C11 only</td>
    </tr>
    <tr>
      <td>MaxT</td>
      <td>extended_highs&nbsp; <br>
_phrase</td>
      <td>"Highs in the 70s."&nbsp; <br>
"Highs 55 to 65."</td>
      <td>MaxT:&nbsp; <br>
avg</td>
      <td><i><font color="#993366">extended _temp_range</font></i></td>
      <td>C11 only</td>
    </tr>
    <tr>
      <td>T&nbsp; <br>
MinT&nbsp; <br>
MaxT</td>
      <td>temp_trends</td>
      <td>"Temperatures&nbsp; <br>
falling overnight."</td>
      <td>T: hourlyTemp&nbsp; <br>
MinT and MaxT:&nbsp; <br>
avg, minMax, stdDevMinMax</td>
      <td><i><font color="#993366">temp_trend_threshold</font></i></td>
      <td>NOTE: There is an alternate method for "temp_trends_words" in
the ScalarPhrases module.</td>
    </tr>
    <tr>
      <td>SnowAmt&nbsp; <br>
      </td>
      <td>snow_phrase</td>
      <td>"Snow accumulation 2 inches."&nbsp;
      <p>&nbsp;</p>
      </td>
      <td>SnowAmt: accumMinMax <br>
&nbsp;</td>
      <td><i><font color="#993366">phrase_descriptor_dict </font></i>for
"SnowAmt"&nbsp; <br>
      <i><font color="#993366">units_descriptor_dict&nbsp;</font> </i>for
"inches" and "inch"&nbsp; <br>
      <i><font color="#993366">pop_snow_lower_threshold</font></i> <br>
      <i><font color="#993366">increment_dict </font></i><font
 color="#000000">for "SnowAmt"&nbsp; </font><i><font color="#993366"></font></i><br>
      </td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>SnowAmt</td>
      <td>descriptive_snow&nbsp; <br>
_phrase</td>
      <td>"Moderate snow accumulations."</td>
      <td>SnowAmt: accumMinMax</td>
      <td><br>
      </td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">StormTotalSnow<br>
      </td>
      <td style="vertical-align: top;">stormTotalSnow_phrase<br>
      </td>
      <td style="vertical-align: top;">"Storm total snow accumulation
around 9 inches."<br>
      </td>
      <td style="vertical-align: top;">StormTotalSnow:<br>
accumMinMax<br>
      </td>
      <td style="vertical-align: top;"><i><font color="#993366">phrase_descriptor_dict</font></i>for
"TotalSnow"&nbsp; <br>
      <i><font color="#993366">units_descriptor_dict&nbsp;</font> </i>for
"inches" and "inch"&nbsp; <br>
      <i><font color="#993366">pop_snow_lower_threshold</font></i> <br>
      <i><font color="#993366">increment_dict </font></i><font
 color="#000000">for "SnowAmt"&nbsp; </font></td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SnowAmt<br>
      </td>
      <td style="vertical-align: top;">total_snow_phrase<br>
      </td>
      <td style="vertical-align: top;">"Total snow accumulation 6
inches."<br>
      </td>
      <td style="vertical-align: top;">SnowAmt:<br>
accumMinMax<br>
      </td>
      <td style="vertical-align: top;"><i><font color="#993366">phrase_descriptor_dict</font></i>for
"SnowAmt"&nbsp; <br>
      <i><font color="#993366">units_descriptor_dict&nbsp;</font> </i>for
"inches" and "inch"&nbsp; <br>
      <i><font color="#993366">pop_snow_lower_threshold</font></i> <br>
      <i><font color="#993366">getSnowReportEndDay</font></i> <br>
      <i><font color="#993366">increment_dict </font></i><font
 color="#000000">for "SnowAmt"&nbsp; </font></td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td>SnowLevel</td>
      <td>snowLevel_phrase</td>
      <td>"Snow level 7600 feet."</td>
      <td>SnowLevel: **ScalarStats</td>
      <td><i><font color="#993366">phrase_descriptor_dict </font></i>for
"SnowLevel"&nbsp; <br>
      <i><font color="#993366">units_descriptor_dict&nbsp;</font> </i>for
"feet"&nbsp; <br>
      <i><font color="#993366">pop_snowLevel_upper_threshold</font></i>
      <br>
      <i><font color="#993366">snowLevel_maximum_phrase</font></i> <br>
      <i><font color="#993366">snowLevel_upper_topo_percentage</font></i>
      <br>
      <i><font color="#993366">snowLevel_lower_topo_percentage</font></i>
      <br>
      <i><font color="#993366">increment_dict&nbsp; </font></i><font
 color="#000000">for "SnowLevel"</font></td>
      <td>Be sure and set the&nbsp; <i><font color="#993366">snowLevel_maximum_phrase</font></i>for
your local area</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">IceAccum<br>
      </td>
      <td style="vertical-align: top;">iceAccumulation_phrase<br>
      </td>
      <td style="vertical-align: top;">"Ice accumulation of&nbsp; up to
one half inch."<br>
      </td>
      <td style="vertical-align: top;">IceAccum: accumMinMax<br>
      </td>
      <td style="vertical-align: top;"><i><font color="#993366">ice_accumulation_threshold<br>
phrase_descriptor_dict </font></i><font color="#000000">for "IceAccum"</font><br>
      <i><font color="#993366">increment_dict </font></i><font
 color="#000000">for "IceAccum"<br>
      </font></td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td>WindChill</td>
      <td>windChill_phrase</td>
      <td>"Wind chill readings 5 to 10."</td>
      <td>WindChill:&nbsp; <br>
**ScalarStats&nbsp; <br>
T:minMax</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font> </i>for
"WindChill"&nbsp; <br>
      <i><font color="#993366">windChill_threshold</font></i> <br>
      <i><font color="#993366">windChillTemp_difference</font></i> <br>
      <i><font color="#993366">windChill_range</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>WindChill</td>
      <td>windBased_windChill_phrase</td>
      <td>"Wind chill readings 5 to 10."</td>
      <td>WindChill:**ScalarStats&nbsp; <br>
Wind: **VectorStats</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font> </i>for
"WindChill"&nbsp; <br>
      <i><font color="#993366">windChill_threshold</font></i> <br>
      <i><font color="#993366">windChill_wind_threshold</font></i> <br>
      <i><font color="#993366">minimum_range_threshold_dict</font></i> <br>
      <i><font color="#993366">range_threshold_dict</font></i> <br>
      <i><font color="#993366">value_connector_dict</font></i> <br>
      <i><font color="#993366">windChill_range</font></i></td>
      <td>Checks against Wind instead of T</td>
    </tr>
    <tr>
      <td>HeatIndex</td>
      <td>heatIndex_phrase</td>
      <td>"Heat index readings 10 to 15."</td>
      <td>HeatIndex:&nbsp; <br>
**ScalarStats&nbsp; <br>
T: minMax</td>
      <td><i><font color="#993366">phrase_descriptor_dict </font></i>for
"HeatIndex"&nbsp; <br>
      <i><font color="#993366">heatIndex_threshold</font></i> <br>
      <i><font color="#993366">heatIndexTemp_difference</font></i> <br>
      <i><font color="#993366">minimum_range_threshold_dict</font></i> <br>
      <i><font color="#993366">range_threshold_dict</font></i> <br>
      <i><font color="#993366">value_connector_dict</font></i> <i><font
 color="#993366"><br>
      </font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">MinRH<br>
      </td>
      <td style="vertical-align: top;">rh_phrase<br>
      </td>
      <td style="vertical-align: top;">"Minimum RH 30 percent."<br>
      </td>
      <td style="vertical-align: top;">**ScalarStats MinRH<br>
      </td>
      <td style="vertical-align: top;"><i><font color="#993366">rh_threshold</font></i></td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h4> <a name="WINDANDWINDGUST"></a>WIND AND WINDGUST PHRASES --
VectorRelatedPhrases module</h4>
<center><br>
<table border="1" width="95%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>ELEMENT</td>
      <td>TEXT RULES&nbsp; <br>
METHOD</td>
      <td>EXAMPLE&nbsp; <br>
PHRASES</td>
      <td>SAMPLE&nbsp; <br>
ANALYSIS</td>
      <td>THRESHOLDS AND VARIABLES&nbsp; <br>
(To override, find in VectorRelatedPhrases or ConfigVariables and copy
to Overrides file)</td>
      <td>ADD'L&nbsp; <br>
INFO</td>
    </tr>
    <tr>
      <td>Wind</td>
      <td>wind_phrase</td>
      <td>"Northeast winds 5 to 15 mph in the afternoon."&nbsp;
      <p>"Southwest winds 5-15 mph."&nbsp; </p>
      <p>&nbsp;</p>
      </td>
      <td>Wind: **Vector Stats</td>
      <td><i><font color="#993366">phrase_descriptor_dict </font></i>for
"Wind"&nbsp; <br>
      <i><font color="#993366">units_descriptor_dict </font></i>for
"mph"&nbsp; <br>
      <i><font color="#993366">value_connector_dict </font></i>for
"Wind" e.g. 5 to 10 mph&nbsp; <br>
      <i><font color="#993366">increment</font></i> for "Wind" e.g.
round wind magnitudes to nearest 5&nbsp; <br>
      <i><font color="#993366">null_nlValue_dict</font></i> <br>
      <i><font color="#993366">first_null_phrase_dict</font></i> <br>
      <i><font color="#993366">null_phrase_dict</font></i>
      <p><i><font color="#993366">maximum_range_nlValue</font></i>for
"Wind" e.g. do not report winds with more than a 5 mph range e.g. 5 to
10 mph&nbsp; <br>
      <font color="#993366"><i>minimum_range_nlValue</i> </font>for
"Wind" e.g. report winds with at least this range e.g. 5 to 10
mph&nbsp; </p>
      <p>Differences used for reporting Wind in different time
periods:&nbsp; <br>
"Wind NE 20 to 35 mph in the morning becoming S 10 to 15 mph in the
afternoon."&nbsp; <br>
      <i><font color="#993366">vector_mag_difference_nlValue_dict</font></i>
e.g. 10 mph&nbsp; <br>
      <i><font color="#993366">vector_dir_difference_nlValue_dict </font></i>e.g.
60 degrees&nbsp; </p>
      <p><i><font color="#993366">phrase_connector_dict </font></i>for
"becoming", "increasing to", "decreasing to", "shifting to the"&nbsp; </p>
      <p><i><font color="#993366">embedded_vector_descriptor_flag_dict </font></i><font
 color="#000000">-- default is 1 -- if 0, descriptor is first e.g. "<i>Winds</i>
east 5 to 10 mph."</font> </p>
      <p><i><font color="#993366">include_timePeriod_descriptor_flag&nbsp;</font></i><font
 color="#000000"> -- moderates the time qualification on the phrase
e.g.
"in the afternoon"</font> <br>
      <i><font color="#993366">marine_wind_flag</font></i></p>
      </td>
      <td>mph</td>
    </tr>
    <tr>
      <td>Wind</td>
      <td>wind_withGust_phrase</td>
      <td>"East winds 10 to 20 mph with gusts to around 70 mph in the
night becoming southwest 5 to 10 mph in the early morning."</td>
      <td>Wind: **Vector&nbsp; Stats&nbsp; for Wind&nbsp; <br>
Wind: **Vector MinMax (must be there as a secondary analysis method for
comparison in the gust_phrase)&nbsp; <br>
WindGust:&nbsp; <br>
**Scalar Stats&nbsp;</td>
      <td>Same as above PLUS:&nbsp; <br>
      <i><font color="#993366">phrase_descriptor_dict&nbsp;</font></i>
for "WindGust"&nbsp; <br>
      <i><font color="#993366">gust_threshold </font></i><font
 color="#000000">-- gusts reported if above this threshold</font> <br>
      <i><font color="#993366">gust_wind_difference_threshold </font></i><font
 color="#000000">-- gust reported if difference between max Wind and
WindGust is greater than this threshold</font> <br>
      <i><font color="#993366">useWindsForGusts_flag </font></i><font
 color="#000000">-- if a WindGust grid is not found, the absolute max
wind will be used for gusts</font></td>
      <td>mph</td>
    </tr>
    <tr>
      <td>Wind</td>
      <td>marine_wind_phrase</td>
      <td>"West winds 10 to 20 knots in the morning shifting to the
southwest in the afternoon."</td>
      <td>**Vector&nbsp; Stats</td>
      <td>Same as for public_windRange_phrase except <i><font
 color="#993366">units_descriptor_dict </font></i>for "kt"&nbsp; <br>
      <i><font color="#993366">marine_wind_flag</font> </i>set to 1
for
marine descriptors e.g. gales, storm force winds&nbsp; <br>
      <b><i><font color="#993366">seaBreeze_thresholds </font></i></b><font
 color="#000000">and local effects areas (see below)</font> <br>
      <i><font color="#993366">marine_wind_descriptor</font> </i>for
"Wind"&nbsp; <br>
      <i><font color="#993366">phrase_connector_dict&nbsp; </font></i>for
"becoming", "rising&nbsp; to", "easing to", "veering", "backing",
"becoming onshore"&nbsp; <br>
      <i><font color="#993366">useWindsForGusts_flag </font></i><font
 color="#000000">-- if a WindGust grid is not found, the absolute max
wind will be used for gusts</font></td>
      <td>knots&nbsp;
      <p>See description for SeaBreeze below</p>
      </td>
    </tr>
    <tr>
      <td>Wind</td>
      <td>marine_wind&nbsp; <br>
_withGusts_phrase</td>
      <td>"East winds 10 to 20 knots with gusts to around 70 knots in
the night veering southwest 5 to 10 knots in the early morning."</td>
      <td>Wind: **Vector&nbsp; Stats&nbsp; <br>
Wind: **Vector MinMax (must be there for comparision in the Gust
phrase)&nbsp; <br>
WindGust:&nbsp; <br>
**ScalarStats&nbsp;</td>
      <td>Same as above PLUS&nbsp; <br>
      <i><font color="#993366">phrase_descriptor_dict&nbsp; </font></i>for
"WindGust"&nbsp; <br>
      <i><font color="#993366">gust_threshold </font></i><font
 color="#000000">-- gust reported if above this threshold</font> <br>
      <i><font color="#993366">gust_wind_difference_threshold</font></i><font
 color="#000000">-- gust reported if difference between max Wind and
WindGust is greater than this threshold</font></td>
      <td>knots</td>
    </tr>
    <tr>
      <td>Wind</td>
      <td>lake_wind_phrase</td>
      <td>"Caution advised on area lakes."</td>
      <td>Wind: **Vector&nbsp; Stats</td>
      <td><b><i><font color="#993366">lake_wind_areaNames</font></i></b>
      <br>
      <i><font color="#993366">phrase_descriptor _dict </font></i>for
"lakeWinds"&nbsp; <br>
      <i><font color="#993366">lake_wind_thresholds</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>Wind</td>
      <td>wind_summary</td>
      <td>"Breezy"&nbsp; "Windy"</td>
      <td>Wind: **Vector&nbsp; Stats</td>
      <td><i><font color="#993366">vector_summary_valueStr</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>WindGust</td>
      <td>gust_phrase</td>
      <td>"Gusts up to 70 mph."</td>
      <td>WindGust: **Scalar Stats</td>
      <td><i><font color="#993366">phrase_descriptor_dict&nbsp; </font></i>for
"WindGust"&nbsp; <br>
      <i><font color="#993366">gust_threshold</font></i> <br>
      <i><font color="#993366">null_nlValue_dict</font></i> <br>
      <i><font color="#993366">first_null_phrase_dict</font></i> <br>
      <i><font color="#993366">null_phrase_dict</font></i>
      <p><i><font color="#993366">gust_wind_difference_nlValue </font></i><font
 color="#000000">-- gust reported if difference between max Wind and
WindGust is greater than this threshold</font> <br>
      <i><font color="#993366">scalar_difference_nlValue_dict</font></i><font
 color="#000000"> -- for "WindGust": if gusts for 2 consecutive
sub-ranges differ by more than this amount, they will be reported
separately.</font> <br>
      <i><font color="#993366">include_timePeriod_descriptor_flag&nbsp;</font></i><font
 color="#000000"> -- moderates the time qualification on the phrase
e.g.
"in the afternoon"</font></p>
      </td>
      <td><br>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h4> <a name="SeaBreeze"></a>Sea Breeze Identification</h4>
Sea breezes can be identified to produce phrases such as the following:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NW winds 15 to 25
knots <i>becoming onshore</i> 10 to 15 knots. </p>
<p>To set up sea breeze indentification, you need to: </p>
<ul>
  <li>Create the following named edit areas from the GFE GUI:</li>
  <ul>
    <li>OffShoreArea -- offshore area</li>
    <li>OnShoreArea -- onshore area</li>
&nbsp;
  </ul>
  <li>&nbsp;Override the product component definition to include the
"intersectAreas" for Wind.&nbsp;&nbsp; For example:</li>
</ul>
&nbsp;<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
def CWFPeriod(self):</font>
<ul>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return {</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"type": "component",</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"methodList": [</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.assemblePhrases,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.wordWrap,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"analysisList": [</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Split time range in quarters for Wind and WindGust</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wind", self.vectorModeratedMinMax, [3]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wind", self.vectorMinMax, [12]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("WindGust", self.maximum, [3]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("WaveHeight", self.minMax, [6]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("WindWaveHgt", self.minMax, [6]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Split time range in half for Wx and Swell</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wx", self.rankedWx, [6]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Swell", self.vectorMinMax, [6]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Swell2", self.vectorMinMax, [6]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Period", self.avg, [6]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Period2", self.avg, [6]),</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font>
  <p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"phraseList":[</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# WINDS</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.marine_wind_withGusts_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Alternative:</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.marine_wind_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.gust_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# WAVES</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.wave_withPeriods_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Alternative:</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.wave_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Optional:</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.chop_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# WEATHER</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.weather_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# SWELLS AND PERIODS</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.swell_withPeriods_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Alternative:</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.swell_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.period_phrase,</font> <br>
  <font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> </p>
  <p><font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"intersectAreas" :[</font> <br>
  <font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wind", ["OffShoreArea", "OnShoreArea"]),</font> <br>
  <font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> </p>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font
 color="#006600"> }</font> <br>
&nbsp; </p>
  <li>Override the <i><font color="#993366">seaBreeze_thresholds</font></i>&nbsp;
(found in ConfigVariables) appropriately for your areas to identify the
offshore and onshore wind directions that indicate a sea breeze.&nbsp;
If the magnitude is constant throughout the period AND if the offshore
winds are between offshoreDirection1 and
offshoreDirection2 during the first part of the period AND the onshore
winds are between onshoreDirection1 and onshoreDirection2 during the
next part of the period, the <i>becoming onshore</i> wording is used.
For example, if you set OffShoreArea for Hours 1-6 to 1020 and
OnShoreArea for Hours 7-12 to 2420, you will get the desired wording.<br>
  </li>
</ul>
<h4> <a name="WEATHER"></a>WEATHER PHRASES -- WxPhrases module</h4>
<center><br>
<table border="1" width="95%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>ELEMENT</td>
      <td>TEXT RULES&nbsp; <br>
METHOD</td>
      <td>EXAMPLE&nbsp; <br>
PHRASES</td>
      <td>SAMPLE&nbsp; <br>
ANALYSIS</td>
      <td>THRESHOLDS AND VARIABLES&nbsp; <br>
(To override, find in WxPhrases, PhraseBuilder,&nbsp; or
ConfigVariables and copy to
Overrides
file)</td>
      <td>ADD'L&nbsp; <br>
INFO</td>
    </tr>
    <tr>
      <td>Wx</td>
      <td>weather_phrase</td>
      <td><br>
      </td>
      <td>Wx: **rankedWx</td>
      <td>Pop/Wx Consistency<br>
      <i><font color="#993366">coveragePoP_value<br>
      </font></i><i><font color="#993366">pop_related_flag</font></i> <br>
      <i><font color="#993366">pop_wx_lower_threshold </font></i>pop-related
Wx types are not reported if PoP is below this threshold&nbsp; <br>
      <br>
Combining and consolidating<br>
      <p><i><font color="#993366">filter_subkeys_flag </font></i><font
 color="#000000">set to filter subkeys by combining duplicates and
similar Wx types as specified in:</font> <br>
      <font color="#993366"><i>wxCombinations</i> </font>Wx types
WITHIN sub-phrases can
be combined to prevent redundant reporting e.g. combine "R" and "RW" to
prevent:&nbsp;&nbsp; "Scattered rain showers and rain."&nbsp;<br>
      <font color="#993366"><i>similarWxTypes, similarIntensities,
similarCoverages, similarCoverageLists</i></font>
&nbsp;Used when combining weather subkeys ACROSS sub-phrases for
weather phrases and for
determining local effects.<br>
      <i><font color="#993366">wxHierarchies</font>&nbsp; </i>Used
when sorting weather subkeys into dominant coverage or weather type
order.</p>
      <p>Wording<i><font color="#993366"><br>
      </font></i><i><font color="#993366">useSimple<br>
subPhrase_limit<br>
      </font></i></p>
      <p><i><font color="#993366">rankFuzzFactor &nbsp;</font></i>(CommonUtils)<br>
      <i><font color="#993366">precip_related_flag</font></i> <br>
      <i><font color="#993366">wxTypeDescriptors</font></i> <br>
      <i><font color="#993366">wxIntensityDescriptors<br>
wxAttributeDescriptors<br>
      </font></i></p>
      <p><i><font color="#993366">rankWordingFuzzFactor<br>
possiblyMixedWith<br>
mixedWith<br>
withPocketsOf<br>
wxConjunction<br>
      </font></i><br>
Visibility<br>
      <i><font color="#993366">null_nlValue </font></i><font
 color="#000000">for "Visibility"</font> <br>
      <i><font color="#993366">embedded_visibility_flag</font></i> <br>
      <i><font color="#993366">visibility_weather_phrase_nlValue</font></i>
      <br>
      <i><font color="#993366">element_outUnits_dict</font></i><font
 color="#000000"> for "Visibility"</font><br>
      <i><font color="#993366">visibility_wx_threshold</font></i> <br>
      <i><font color="#993366">significant_wx_visibility_subkeys</font></i>
      </p>
      <p><i><font color="#993366">include_timePeriod_descriptor_flag&nbsp;</font></i><font
 color="#000000"> -- moderates the time qualification on the phrase
e.g.
"in the afternoon"</font></p>
      </td>
      <td>See section below on the meaning of <a
 href="#Weather_Key_Attributes_Primary_and">Weather Subkey Attributes
"Primary" and "Mention."</a><br>
      <br>
See section below on <a href="#CustomizingWeatherPhrases">Customizing
Weather Phrases</a>
      <p>See the section on <a href="#HANDLINGVISIBILITY">Handling
Visibility</a></p>
      </td>
    </tr>
    <tr>
      <td>Wx</td>
      <td>severeWeather_phrase</td>
      <td>"Some thunderstorms may be severe."<br>
"Some storms could be severe with damaging hail."<br>
"Some storms could be severe with large hail and damaging winds
possible."<br>
      <br>
      </td>
      <td>Wx:**rankedWx</td>
      <td> <br>
      </td>
      <td>Reports if there is T+ in the time period. <br>
Also reports large hail and damaging winds.<br>
      </td>
    </tr>
    <tr>
      <td>Wx</td>
      <td>heavyPrecip_phrase</td>
      <td>"Rain may be heavy at times."&nbsp; <br>
"Locally heavy rainfall possible."&nbsp; <br>
"Snow may be heavy at times."</td>
      <td>Wx: **rankedWx</td>
      <td><i><font color="#993366">phrase_descriptor_dict&nbsp; </font></i>for
"heavyRainfall", "heavyRain", "heavySnow", "heavyPrecip"<br>
      <i><font color="#993366">heavySnowTypes<br>
heavyOtherTypes </font></i><br>
      </td>
      <td>Reports if intensity is + for R, RW, S, SW,<br>
IP, ZR, ZL, L<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Wx<br>
      </td>
      <td style="vertical-align: top;">heavyRain_phrase<br>
      </td>
      <td style="vertical-align: top;">"Locally heavy rain possible."<br>
      </td>
      <td style="vertical-align: top;">Wx: **rankedWx</td>
      <td style="vertical-align: top;"><i><font color="#993366">phrase_descriptor_dict&nbsp;</font></i>for
"heavyRains"</td>
      <td style="vertical-align: top;">Reports if T has attribute HvyRn<br>
      </td>
    </tr>
    <tr>
      <td>Wx</td>
      <td>visibility_phrase</td>
      <td>"Visibility less than 1 nautical mile."</td>
      <td>Wx: **rankedWx</td>
      <td><i><font color="#993366">null_nlValue </font></i><font
 color="#000000">for "Visibility" below which visibility is not reported</font>
      <br>
      <i><font color="#993366">phrase_descriptor </font></i><font
 color="#000000">for "Visibility"</font> <br>
      <i><font color="#993366">increment_nlValue </font></i><font
 color="#000000">for "Visibility"</font> <br>
      <i><font color="#993366">visibility_phrase_nlValue</font></i> <br>
      <i><font color="#993366">element_outUnits_dict</font></i><font
 color="#000000"> for "Visibility"</font></td>
      <td>See the section on <a href="#HANDLINGVISIBILITY">Handling
Visibility</a></td>
    </tr>
  </tbody>
</table>
</center>
<br>
<h4><a name="Weather_Key_Attributes_Primary_and"></a>Weather Subkey
Attributes "Primary" and "Mention"</h4>
Many weather subkeys can have attributes of "Primary" and "Mention"
which allow the forecaster to influence the resulting words as follows:<br>
<ul>
  <li>"Primary":&nbsp; If a subkey is marked as "Primary," it will
appear as the dominant weather subkey in the weather wording. </li>
  <li>"Mention":&nbsp; If a subkey is marked as "Mention," it will
appear in the weather wording regardless of its temporal/areal
coverage.&nbsp; Otherwise, subkeys that do not meet the coverage
requirements (as defined by the "wxkey_coverage_percent") are
eliminated from the wording.&nbsp; So, for example, the
wxkey_coverage_percent for IP is 15% so that if we have just 1 hour of
IP in a 12-hour period, it will not be mentioned in the wording.&nbsp;
However, if this subkey is given an attribute of "Mention," it will not
be eliminated and will appear in the wording. This gives the forecaster
the ability to supercede the coverage thresholds. </li>
</ul>
<h4><a name="CustomizingWeatherPhrases"></a>Customizing Weather
Phrases
</h4>
You can override the "wxCoverageDescriptors", "wxTypeDescriptors" ,
"wxIntensityDescriptors" , and "wxAttributeDescriptors" in your
Overrides
file to customize the wording for weather types, coverages,&nbsp;
intensities, and attributes.&nbsp; For example, the following default
settings express very light rain and snow showers as "sprinkles" and
"flurries", respectively.
<p>&nbsp;<font color="#006600">&nbsp;&nbsp; def wxTypeDescriptors(self):</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # This
is the list of coverages, wxTypes, intensities, attributes for which
special</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
weather type wording is desired.&nbsp; Wildcards (*) can be used to
match any value.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If a
weather subkey is not found in this list, default wording</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # will
be used from the Weather Definition in the server.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # The
format of each tuple is:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp; (coverage, wxType, intensity, attribute,
weatherType
descriptor)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "RW", "--", "*", "sprinkles"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "SW", "--", "*", "flurries"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
]</font> </p>
<p>In many cases, more than one of these methods will have to be
overridden to accomplish the desired result.&nbsp; We might have to
"turn on" one kind of wording and "turn off" other default wording. In
the above example, we have to "turn off" the default descriptor for
"very light" using the wxIntensityDescriptors: </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
wxIntensityDescriptors(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # This
is the list of coverages, wxTypes, intensities, attribute for which
special</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
weather intensity wording is desired.&nbsp; Wildcards (*) can be used
to
match any value.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If a
weather subkey is not found in this list, default wording</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # will
be used from the Weather Definition in the server.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # The
format of each tuple is:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp; (coverage, wxType, intensity, attribute, intensity
descriptor)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[</font> <br>
<font color="#330033">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "RW", "--", "*", ""),</font> <br>
<font color="#330033">&nbsp;</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "RW", "-", "*", ""),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "R", "--", "*", "very light"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "R", "-", "*", "light"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "R", "+", "*", "heavy"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "RW", "+", "*", "heavy"),</font> <br>
<font color="#663366">&nbsp;</font><font color="#330033">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "SW", "--", "*", ""),</font> <br>
<font color="#330033">&nbsp;</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "SW", "-", "*", ""),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "SW", "+", "*", "heavy"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "S", "--", "*", "very light"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "S", "-", "*", "light"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "S", "+", "*", "heavy"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "ZR", "--", "*", "light"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "ZR", "+", "*", "heavy"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "L", "*", "*", ""),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "F", "+", "*", "dense"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
]</font> </p>
<p>Suppose we want to report "heavy snow" as "snow...heavy at times",
we would include the following in our Overrides file: </p>
<p>&nbsp;<font color="#006600">&nbsp;&nbsp; def wxTypeDescriptors(self):</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list = TextRules.TextRules.wxTypeDescriptors(self)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list.append( </font><font color="#663366">("*", "S", "+", "*",
"snow...heavy at times") </font><font color="#006600">)</font> <br>
<font color="#009900">&nbsp;</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return list</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
wxIntensityDescriptors(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list = TextRules.TextRules.wxIntensityDescriptors(self)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list.append( </font><font color="#663366">("*", "S", "+", "")</font> <br>
<font color="#009900">&nbsp;</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return list</font> </p>
<p>As another example, suppose we want to describe thunderstorms with
an attribute of "dry" as "dry thunderstorms."&nbsp; Including the
following in our Overrides file could accomplish this: </p>
<p>&nbsp;<font color="#006600">&nbsp;&nbsp; def wxTypeDescriptors(self):</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list = TextRules.TextRules.wxTypeDescriptors(self)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list.append( </font><font color="#663366">("*", "T", "*", "Dry", "dry
thunderstorms") </font><font color="#006600">)</font> <br>
<font color="#009900">&nbsp;</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return list</font> </p>
<p>&nbsp;<font color="#006600">&nbsp;&nbsp; def
wxAttributeDescriptors(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list = TextRules.TextRules.wxAttributeDescriptors(self)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list.append( </font><font color="#663366">("*", "T", "*", "Dry", "") </font><font
 color="#006600">)</font> <br>
<font color="#009900">&nbsp;</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return list</font> </p>
<p>It is possible to specify a method instead of text string for the
descriptor.&nbsp; For example, the default wxTypeDescriptor for rain
showers uses a method as follows: </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def wxTypeDescriptors(self):</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "SW", "--", "*", "flurries"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("*", "RW", "*", "*", self.rainShowersDescriptor),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
]</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
rainShowersDescriptor(self, tree, node, subkey):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
subkey.intensity() == "--":</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return "sprinkles"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
tree is None:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return "showers"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t =
tree.stats.get(</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"T", node.getTimeRange(),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node.getAreaLabel(), statLabel="minMax",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mergeMethod="Min")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if t
is None:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return "showers"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if t
&lt; 40:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return "rain showers"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return "showers"</font> </p>
<p>These methods are&nbsp; used in Table products as well as
Narratives.&nbsp; NOTE:&nbsp; IF you are working with a narrative
product, you can include the "tree, node" arguments and use them to
qualify your customizations.&nbsp; For example, we could check the node
time range and qualify fog as "morning fog" as in the example below: </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def wxTypeDescriptors(self,
tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list = TextRules.TextRules.wxTypeDescriptors(self)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Find out what time range we are working with</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
timeRange = node.getTimeRange()</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# See if this time range is for the Morning</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# First, shift to Local time from GMT</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
timeRange = self.shiftedTimeRange(timeRange)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
startHour = timeRange.startTime().hour()</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
endHour = timeRange.endTime().hour()</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if startHour &gt;= 6 and endHour &lt;= 12:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
list.append( ("*", "F", "*", "*", "morning fog") )</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return list</font> </p>
<p>For more information on customizing Weather Phrases, see the
sections on <a href="#WEATHERKEYFILTERING">Weather
Phrasing&nbsp; </a>and<a href="#STRATEGYFORPHRASECONSOLIDATION">
Phrase
Consolidation.<br>
</a></p>
<a href="#STRATEGYFORPHRASECONSOLIDATION"> </a>
<h4><a name="PopWx_Consistency"></a>Pop/Wx Consistency</h4>
By default, PoP (as well as LAL) is matched to the highest ranking
weather subkey.&nbsp; The default algorithm ensures that the reported
PoP matches
the reported Wx. &nbsp;This algorithm assumes that the grids have been
made consistent between PoP and Wx, perhaps via a Smart Tool. Thus, for
each weather subkey, there is a corresponding PoP in the grid.&nbsp;
The
algorithm reports the PoP that matches the highest ranked
weather.&nbsp;
So you might have a large area of SChc T with PoP of 20 and a very
small area of Lkly T with a PoP of 60.&nbsp; This will get reported as <br>
<br>
&nbsp;&nbsp;&nbsp; SLIGHT CHANCE OF THUNDERSTORMS.&nbsp; CHANCE OF
THUNDERSTORMS 20 PERCENT.<br>
<br>
since SChc T is computed to be the highest ranking subkey. The
algorithm
does not report values that are not in the grids.&nbsp; Instead, the
PoP
value in the grids that gives the closest match to the Wx coverage is
used. &nbsp;The configurable&nbsp;<i><font color="#993366">coveragePoP_table</font></i>
(CommonUtils)
defines the PoP ranges associated with each weather coverage.<span
 style="font-weight: bold;"><br>
<br>
</span>The algorithm and matching can be controlled by adjusting the
"matchToWxInfo_dict" (ConfigVariables) in various ways shown and
described below:<br>
<br>
&nbsp;&nbsp;&nbsp; def matchToWxInfo_dict(self, tree, node):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # The system will
automatically match the following elements to<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the highest ranking
weather subkey coverage.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Each entry is a tuple of
(increment, algorithm, noPrecipValue, percentThreshold, wxTypes filter)
where<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; increment: This is
the increment from the low "bin" value<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; to be
added.&nbsp; For example, PoP has a bin of 55-65, so<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; its
increment is 5 to end up with values as multiples of 10.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; algorithm: Can be<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;
Max:&nbsp; The MAXIMUM value that falls within the coverage range<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for the highest
ranking subkey will be chosen.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; Mode:
The MOST FREQUENT (over space and time) value that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; falls within
the coverage range for the highest ranking<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subkey will be
chosen.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; MaxMode:
This is the MAXIMUM value over time of the MOST<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FREQUENT values over
area for each of the grids in the timeRange.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In other words, for
each grid, we find the Mode i.e. MOST FREQUENT<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value that falls
within the coverage range for the highest<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ranking subkey.&nbsp;
Then we find the MAXIMUM of these values<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; over the grids again
falling within the coverage values.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;
AnalysisMethod: This will simply use whatever analysis method<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is specified as the
first entry in the product component<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for the element. For
example, if you have<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("PoP",
self.stdDevMaxAvg, [3]),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ("PoP",
self.binnedPercent, [3]),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the "stdDevMaxAvg"
method will be used.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; noPrecipValue: The
value that should be returned if there is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no precipitating
weather.&nbsp; Can be:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp; an
actual data value<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
"Max": The maximum value found that has a greater &gt; 0% occurrence.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
"AnalysisMethod": As above, will return the result of the product<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; component analysis
method e.g. stdDevMaxAvg or maximum.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; percentThreshold:
(optional) Percent of areal coverage a value must have in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
order to be considered for the element value returned. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Default is 0.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; wxTypes filter:
(optional) Match only to weather keys of these wxTypes e.g.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
match LAL only to "T"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; EXAMPLE 1:&nbsp;
Suppose we have:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wx&nbsp; Hours 1-12:&nbsp; Chc
R&nbsp; (coverage range is 30-60)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PoP Hours 1-3:&nbsp;&nbsp; 40%
(over 70% of area), 50% (over 30% of area)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hours
4-12:&nbsp; 30<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # For the 12-hour PoP,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; If set
to Max, we will get PoP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; If set
to Mode, we will get PoP:&nbsp;&nbsp;&nbsp;&nbsp; 30<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; If set
to MaxMode, we will get PoP:&nbsp; 40<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # For the Hours 1-3 PoP:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; If set
to Max, we will get PoP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; If set
to Mode, we will get PoP:&nbsp;&nbsp;&nbsp;&nbsp; 40<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; If set
to MaxMode, we will get PoP:&nbsp; 40<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; NOTE: IF you add a
new element to this list, you MUST include<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; a coverage table
named "coverage&lt;elementName&gt;_value".&nbsp; Follow<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; the example for
"coveragePoP_value" in CommonUtils.&nbsp; You can<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; then access the
element value by calling "matchToWx" (WxPhrases).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"PoP": (5, "Max", None, 0),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If
there's no precipitating weather, return LAL 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"LAL": (0, "Max", 1, 0, ["T"]),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
<h4><a name="COMBINEDELEMENT"></a>COMBINED ELEMENT PHRASES --
CombinedPhrases module<br>
</h4>
<center>
<table border="1" width="95%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>ELEMENT</td>
      <td>TEXT RULES&nbsp; <br>
METHOD</td>
      <td>EXAMPLE&nbsp; <br>
PHRASES</td>
      <td>SAMPLE&nbsp; <br>
ANALYSIS</td>
      <td>THRESHOLDS AND VARIABLES&nbsp; <br>
(To override, find in ConfigVariables, WxPhrases, or CombinedPhrases
and copy to Overrides file)</td>
      <td>ADD'L&nbsp; <br>
INFO</td>
    </tr>
    <tr>
      <td>Sky, PoP, Wx</td>
      <td>skyPopWx_phrase</td>
      <td>"Partly cloudy with a 20 percent chance of showers and
thunderstorms." <br>
      <br>
"Sunny in the morning then partly cloudy with a 20 percent chance of
rain showers in
the afternoon."</td>
      <td>Wx:**rankedWx&nbsp; <br>
(See add'l info).&nbsp; <br>
Sky: **median&nbsp; <br>
PoP: **binnedPercent,&nbsp;</td>
      <td>The same thresholds and variables described for the <a
 href="#WEATHER">weather_phrase</a> apply to this combined phrase.<br>
      <br>
In addition:<br>
      <i><font color="#993366">useCombinedSkyPopWx<br>
useSkyPopWx_consolidation<br>
      </font></i><br>
      <i><font color="#993366">sky_valueList</font></i> <br>
      <i><font color="#993366">matchToWxInfo_dict</font></i><br>
      <br>
      </td>
      <td><font color="#ff0000">NOTE: You should also include the
sky_phrase, weather_phrase, and popMax_phrase in your phraseList when
you are using the skyPopWx_phrase.</font>
      <p><font color="#000000">For more information on the algorithm
used and examples, see the documentation in the CombinedPhrases module.</font></p>
      </td>
    </tr>
    <tr>
      <td>Wx, Sky</td>
      <td>weather_orSky_phrase</td>
      <td>If no weather, then return sky phrase</td>
      <td>Sky: **median&nbsp; <br>
Wx: **rankedWx</td>
      <td>same as for weather_phrase and sky_phrase</td>
      <td><br>
      </td>
    </tr>
  </tbody>
</table>
</center>
<br>
&nbsp;
<h4><a name="MARINE"></a>MARINE PHRASES -- MarinePhrases module<br>
</h4>
<center>
<table border="1" width="95%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>ELEMENT</td>
      <td>TEXT RULES&nbsp; <br>
METHOD</td>
      <td>EXAMPLE&nbsp; <br>
PHRASES</td>
      <td>SAMPLE&nbsp; <br>
ANALYSIS</td>
      <td>THRESHOLDS AND VARIABLES&nbsp; <br>
(To override, find in ConfigVariables or MarinePhrases and copy to
Overrides file)</td>
      <td>ADD'L&nbsp; <br>
INFO</td>
    </tr>
    <tr>
      <td>WaveHeight&nbsp; <br>
WindWaveHgt</td>
      <td>wave_phrase</td>
      <td>"Combined seas 15 to 25 feet."&nbsp; <br>
"Wind waves 5 feet."</td>
      <td>WaveHeight or WindWaveHeight:&nbsp; <br>
** Scalar Stats</td>
      <td> <br>
      <i><font color="#993366">maximum_range_nlValue</font></i> <br>
      <i><font color="#993366">inlandWatersAreas</font></i> <br>
      <i><font color="#993366">inlandWatersWave_element</font></i>l&nbsp;<br>
      <i><font color="#993366">waveHeight_wind_threshold</font></i> <br>
      <i><font color="#993366">combinedSeas_threshold</font></i> <br>
      <i><font color="#993366">seasWaveHeight_element&nbsp;</font></i> <br>
      <i><font color="#993366">seasWindWave_element&nbsp;</font></i> <br>
      <i><font color="#993366">noWaveHeight_phrase</font></i> <br>
      <i><font color="#993366">null_nlValue_dict</font></i> <br>
      <i><font color="#993366">first_null_phrase_dict</font></i> <br>
      <i><font color="#993366">null_phrase_dict</font></i> <br>
      <i><font color="#993366">include_timePeriod_descriptor_flag&nbsp;</font></i><font
 color="#000000"> -- moderates the time qualification on the phrase
e.g.
"in the afternoon"</font></td>
      <td>See algorithm&nbsp; <br>
below&nbsp;</td>
    </tr>
    <tr>
      <td>WaveHeight&nbsp; <br>
WindWaveHgt</td>
      <td>wave_withPeriod&nbsp; <br>
_phrase</td>
      <td>"Combined seas 15 to 25 feet dominant period 11 seconds."</td>
      <td>Same as above PLUS:&nbsp; <br>
Period: **Scalar Stats&nbsp; <br>
Period2: **Scalar Stats</td>
      <td>same as above PLUS&nbsp; <br>
      <i><font color="#993366">phrase_descriptor_dict&nbsp; </font></i>for
"dominant period"&nbsp; <br>
      <i><font color="#993366">units_descriptor_dict </font></i>for
"ft"</td>
      <td>See algorithm&nbsp; <br>
below</td>
    </tr>
    <tr>
      <td>Wind</td>
      <td><i>see <a href="#WINDANDWINDGUST">Wind and WindGust Phrases</a>
above</i></td>
      <td><br>
      </td>
      <td><br>
      </td>
      <td><br>
      </td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>Wind</td>
      <td>chop_phrase</td>
      <td>"Bay and inland waters a light chop."</td>
      <td>Wind: **Vector&nbsp; Stats</td>
      <td><i><font color="#993366">phrase_descriptor_dict&nbsp; </font></i>for
"chop"&nbsp; <br>
      <i><font color="#993366">include_timePeriod_descriptor_flag&nbsp;</font></i><font
 color="#000000"> -- moderates the time qualification on the phrase
e.g.
"in the afternoon"</font></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>Swell</td>
      <td>swell_phrase</td>
      <td>"Northeast swells 5 to 10 feet and 10 to 15 feet."</td>
      <td>Swell: **Vector Stats&nbsp; <br>
Swell2: **Vector Stats&nbsp; <br>
Wind: **Vector Stats</td>
      <td><i><font color="#993366">phrase_descriptor_dict </font></i>for
"Swell"&nbsp; <br>
      <i><font color="#993366">units_descriptor_dict </font></i>for
"ft"&nbsp; <br>
      <i><font color="#993366">units_descriptor_dict </font></i>for
"foot"&nbsp; <br>
      <i><font color="#993366">value_connector_dict </font></i>for
"Swell" e.g. 5 to 10 feet&nbsp; <br>
      <i><font color="#993366">increment</font></i> for "Swell" e.g.
round swell magnitudes to nearest 1&nbsp;
      <p><i><font color="#993366">null_nlValue_dict</font></i> <br>
      <i><font color="#993366">first_null_phrase_dict</font></i> <br>
      <i><font color="#993366">null_phrase_dict</font></i> </p>
      <p><i><font color="#993366">maximum_range_nlValue_dict</font></i>
      <br>
      <i><font color="#993366">minimum_range_nlValue_dict</font></i> </p>
      <p><i><font color="#993366">waveHeight_wind_threshold</font></i> <br>
      <i><font color="#993366">combinedSeas_threshold</font></i> </p>
      <p><i><font color="#993366">vector_mag_difference_nlValue_dict</font></i>
e.g. 2 feet&nbsp; <br>
      <i><font color="#993366">vector_dir_difference_nlValue_dict </font></i>e.g.
60 degrees&nbsp; </p>
      <p><i><font color="#993366">phrase_connector_dict </font></i>for
"becoming", "increasing to", "decreasing to", "shifting to the"&nbsp; </p>
      <p><i><font color="#993366">embedded_vector_descriptor_flag_dict </font></i><font
 color="#000000">-- default is 1 -- if 0, descriptor is first e.g. "<i>Swells</i>
east 5 to 10 feet."</font> </p>
      <p><i><font color="#993366">include_timePeriod_descriptor_flag&nbsp;</font></i><font
 color="#000000"> -- moderates the time qualification on the phrase
e.g.
"in the afternoon"</font></p>
      </td>
      <td>Note: The Swell phrase will not be produced for InlandWaters
areas OR if a "seas" wave phrase is produced (See algorithm below.)</td>
    </tr>
    <tr>
      <td>Swell</td>
      <td>swell_withPeriod&nbsp; <br>
_phrase</td>
      <td>"Northeast swells 5 to 10 feet at 9 seconds and 10 to 15 feet
at 12 seconds."</td>
      <td>Swell: **Vector Stats&nbsp; <br>
Swell2: **Vector Stats&nbsp; <br>
Period: **Scalar Stats&nbsp; <br>
Period2: **Scalar Stats&nbsp; <br>
Wind: **Vector&nbsp; Stats</td>
      <td>Same as above PLUS:&nbsp; <br>
      <i><font color="#993366">phrase_descriptor_dict&nbsp;</font></i>
for "Period"&nbsp; <br>
      <i><font color="#993366">units_descriptor&nbsp; </font></i><font
 color="#000000">for "seconds"&nbsp;</font></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>Period</td>
      <td>period_phrase</td>
      <td>"Period 15 seconds."</td>
      <td>Period: **Scalar Stats</td>
      <td><i><font color="#993366">phrase_descriptor_dict&nbsp;</font></i>
for "Period"&nbsp; <br>
      <i><font color="#993366">units_descriptor&nbsp; </font></i><font
 color="#000000">for "seconds"</font> <br>
      <i><font color="#993366">include_timePeriod_descriptor_flag&nbsp;</font></i><font
 color="#000000"> -- moderates the time qualification on the phrase
e.g.
"in the afternoon"</font></td>
      <td><br>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h4> <a name="AlgorithmforWaveHeightandWindWaveHgt"></a>Algorithm for
WaveHeight and/or WindWaveHgt Reporting</h4>
<ul>
  <li>If the edit area is in the <i><font color="#993366">inlandWatersAreas</font></i>
list, report from the&nbsp; <i><font color="#993366">inlandWatersWave_element</font></i>(default
"WaveHeight".&nbsp; If not available, report on second choice (default
WindWaveHgt).&nbsp; For this phrase, use the <i><font color="#993366">phrase_descriptor_dict&nbsp;</font></i>
entry for "inland waters".</li>
  <li>If the edit area is not inland waters:</li>
  <ul>
    <ul>
      <li>If maximum Wind &gt; <i><font color="#993366">waveHeight_wind_threshold</font></i>&nbsp;
OR if maximum WindWaveHgt and maximum Swell &gt; <i><font
 color="#993366">combinedSeas_threshold</font></i>:</li>
      <ul>
        <ul>
          <li>report from <i><font color="#993366">seasWaveHeight_element</font></i>(default
WaveHeight).</li>
          <li>if "_withPeriod" report average of Period and
Period2&nbsp; embedded in phrase.</li>
        </ul>
        <li>For this phrase, use the phrase_descriptor entry for "seas".</li>
      </ul>
      <li>Otherwise, report <i><font color="#993366">seasWindWave_element</font></i>(default
WindWaveHgt).&nbsp; For this phrase, use the <i><font color="#993366">phrase_descriptor_dict</font></i>for
"waves".</li>
    </ul>
  </ul>
  <li>If no data available, return the <i><font color="#993366">noWaveHeight_phrase</font></i>.</li>
</ul>
NOTE:&nbsp; The Swell phrase will not be produced for inland waters OR
if a "seas" phrase is reported.
<h4><a name="FIREWEATHER"></a>FIRE WEATHER PHRASES<br>
</h4>
<center>
<table border="1" width="95%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>ELEMENT</td>
      <td>TEXT RULES&nbsp; <br>
METHOD</td>
      <td>EXAMPLE&nbsp; <br>
PHRASES</td>
      <td>SAMPLE&nbsp; <br>
ANALYSIS</td>
      <td>THRESHOLDS AND VARIABLES&nbsp; <br>
(To override, find in ConfigVariables orFirePhrases and copy to
Overrides
file)</td>
      <td>ADD'L&nbsp; <br>
INFO</td>
    </tr>
    <tr>
      <td>CWR</td>
      <td>cwr_phrase</td>
      <td>CHC OF WETTING RAIN....20 percent</td>
      <td>CWR: **ScalarStats&nbsp;</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>Dispersion</td>
      <td>smokeDispersal_phrase</td>
      <td>SMOKE DISPERSAL....</td>
      <td>Dispersion: **ScalarStats</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i> <br>
      <i><font color="#993366">smokeDispersal_valueStr</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>Haines</td>
      <td>haines_phrase</td>
      <td>HAINES INDEX...3 Very low potential for large plume dominated
fire growth.</td>
      <td>Haines: **ScalarStats</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i> <br>
      <i><font color="#993366">hainesDict</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>LAL</td>
      <td>lal_phrase</td>
      <td>LAL...2.</td>
      <td>LAL:&nbsp; avg [0]&nbsp;</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>MaxRH</td>
      <td>humidity_recovery_phrase</td>
      <td>HUMIDITY RECOVERY...POOR</td>
      <td>MaxRH: mode</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i> <br>
      <i><font color="#993366">humidityRecovery_percentage</font></i> <br>
      <i><font color="#993366">humidityRecovery_valueList</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>MixHgt</td>
      <td>mixingHgt_phrase</td>
      <td>&nbsp;&nbsp;&nbsp; MIXING HEIGHT...600-1000 FT AGL</td>
      <td>MixHgt: **ScalarStats</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>Sky/Wx</td>
      <td>skyWeather_byTimeRange_compoundPhrase</td>
      <td>SKY/WEATHER...Mostly sunny until 1100...then partly
cloudy.&nbsp; Chance of showers.</td>
      <td>Sky: **Scalar Stats&nbsp; <br>
Wx:&nbsp; **dominantWx</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i> <br>
      <i><font color="#993366">includeSkyRanges_flag</font></i> <br>
      <font color="#000000">All the thresholds and varables from the
weather_phrase and the fireSky_phrase apply</font></td>
      <td>To change the format of the sky ranges, override the <font
 color="#006600">addSkyRange</font> method from FirePhrases</td>
    </tr>
    <tr>
      <td>TransWind</td>
      <td>transportWind_phrase</td>
      <td>&nbsp;&nbsp; TRANSPORT WINDS...West 3-10 mph.</td>
      <td>TransWind: **Vector Stats</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>Wind</td>
      <td>fireWind_compoundPhrase</td>
      <td>20-FT WINDS...Winds northeast around 10 mph in the evening
becoming light after midnight.</td>
      <td>Wind20ft OR Wind: **VectorStats</td>
      <td><i><font color="#993366">phrase_descriptor_dict</font></i> <br>
      <font color="#000000">All the threhsolds and variables from the
wind_summary and wind_phrase apply.</font></td>
      <td>If the Wind20ft grid is available, it is reported. Otherwise,
the Wind grid values are multiplied by the <font color="#006600">windAdjustmentFactor</font>(set
in the Overrides file) and reported.</td>
    </tr>
    <tr>
      <td>Variable</td>
      <td>trend_DayOrNight_phrase</td>
      <td>"24-HOUR TREND...2 degrees warmer."&nbsp; <br>
"24-HOUR TREND...10 percent wetter."</td>
      <td>MinT, MaxT: mode&nbsp; <br>
MinRH, MaxRH: mode&nbsp;
      <p>Optional:&nbsp; <br>
Ttrend: self.avg&nbsp; <br>
RHtrend: self.avg&nbsp; </p>
      <p>IF the trend grids are present, they are used, otherwise, the
MinT or MaxRH (nighttime) or MaxT or MinRH (daytime) grids are used.</p>
      </td>
      <td><i><font color="#993366">phrase_descriptor</font></i> for
"higher", "lower", "missing", "unchanged"&nbsp; <br>
      <i><font color="#993366">trend_threshold_dict</font></i> <br>
      <i><font color="#993366">un</font><font color="#993399">its_d</font><font
 color="#993366">escriptor</font></i></td>
      <td>Arguments: dayElement, nightElement,&nbsp; <br>
trendElement,&nbsp; <br>
indent_flag,&nbsp; <br>
endWithPeriod_flag&nbsp; <br>
The flags are set to 1 for FWF-type phrases.</td>
    </tr>
    <tr>
      <td>Variable</td>
      <td>dayOrNight_phrase</td>
      <td>"MAX TEMPERATURE....45-55."&nbsp; <br>
"MIN HUMIDITY...........20-25."</td>
      <td>avg, minmax, stdDevMinMax, median, mode</td>
      <td><i><font color="#993366">minimum_range_threshold_dict</font></i>
      <br>
      <i><font color="#993366">range_threshold_dict</font></i> <br>
      <i><font color="#993366">value_connector_dict</font></i></td>
      <td>Arguments: dayElement, nightElement, indent_flag,
endWithPeriod_flag&nbsp; <br>
These flags are set to 1 for FWF-type phrases.</td>
    </tr>
  </tbody>
</table>
</center>
<h4> <a name="RidgeversusValleyWinds"></a>Ridge versus Valley Winds</h4>
For some edit areas, you may want to break out&nbsp; the 20-foot winds
into Ridges and Valleys. To do so, in the FWF_&lt;site&gt;_Overrides
file, set up the
names of areas for which you want this break-out:
<p>&nbsp;&nbsp;&nbsp; def ridgeValleyAreas(self, tree, node): <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # List of edit area names
for which we want <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # ridge/valley winds
reported: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 20-FOOT WINDS... <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
VALLEYS/LWR SLOPES... <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
RIDGES/UPR SLOPES.... <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # e.g. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # return ["Area1"] <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [] </p>
<p>Next, make sure you have edit areas defined for "Ridges" and
"Valleys" to intersect with the current area.&nbsp; If you want to use
different edit area names, you can include the following override (from
the FirePhrases module) in your Overrides file: </p>
<p>&nbsp;&nbsp;&nbsp; def valleyRidgeAreaNames(self, tree, node): <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # These are the areas for
valleys and ridges, respectively, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # to be intersected with the
current edit area for <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # reporting valley winds and
ridge winds, respectively. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # NOTE: If you change these
area names, you will also <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # need to change the names
in the FirePeriod "intersectAreas" <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # section. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "Valleys", "Ridges" <br>
&nbsp; </p>
<h4>&nbsp;<a name="DISCRETEPHRASESHeadlines"></a>DISCRETE PHRASES
(DiscretePhrases module)<br>
</h4>
<center>
<table nosave="" border="1" width="95%">
  <caption>
  <center></center>
  <br>
  </caption><tbody>
  </tbody> <tbody>
    <tr nosave="">
      <td nosave="">ELEMENT</td>
      <td>TEXT RULES&nbsp; <br>
METHOD</td>
      <td>EXAMPLE PHRASES</td>
      <td>SAMPLE&nbsp; <br>
ANALYSIS</td>
      <td>THRESHOLDS AND VARIABLES&nbsp; <br>
(To override, find in designated module and copy to Overrides file)</td>
      <td>ADD'L&nbsp; <br>
INFO</td>
    </tr>
    <tr>
      <td>Hazards</td>
      <td>makeHeadlinePhrases<br>
      </td>
      <td>.WINTER STORM WARNING IN EFFECT<br>
      </td>
      <td>Not sampled by SampleAnalysis</td>
      <td><i><font color="#993399">&nbsp;<a href="#AllowedHazards">allowedHazards</a><br>
      </font></i><i><font color="#993399"></font></i></td>
      <td>Found in DiscretePhrases module</td>
    </tr>
  </tbody>
</table>
</center>
<h4> <a name="NARRATIVESTRATEGIES"></a>NARRATIVE STRATEGIES</h4>
Narrative Tree methods coordinate to produce a desired result.&nbsp;
The strategy behind this coordination is not obvious from looking at
the
individual methods, so we provide documentation for this coordination
in
the following "Strategy" sections. <br>
&nbsp;
<h4><a name="STRATEGYFORNONLINEARTHRESHOLDS"></a>NON-LINEAR
THRESHOLDS</h4>
We support non-linear thresholds and variables by allowing a method to
return a dictionary of ranges and values. The code applying the
threshold is responsible for applying it to each value using the
nlValue method:<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <font color="#006600">threshold =
self.nlValue(threshold, value)</font> </p>
<p>Any variable that is named with the suffix <font color="#006600">_nlValue</font>
can operate in this way returning EITHER a single value or a dictionary
of values.&nbsp; If a dictionary is returned, it is of the form: </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#006600">{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'default':
&lt;default value&gt;,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lowVal, highVal)
:&nbsp; &lt;value&gt;,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font> <br>
where lowVal and highVal consitute a range for applying the given
value.&nbsp; The lowVal is inclusive while the highVal is exclusive.
&nbsp;For example: </p>
<p>&nbsp;&nbsp;&nbsp; <font color="#006600">def
scalar_difference_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Scalar difference.&nbsp; If the difference between scalar values</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # for
2 sub-periods is greater than this value,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the
different values will be noted in the phrase.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"WindGust": {</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'default': 10,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(0, 30):&nbsp;&nbsp; 10,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(30, 50):&nbsp; 15,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(50, 200): 20,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
},</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p>In this case, if the WindGust is greater or equal to 0 and less than
30, the scalar_difference will be 10; if WindGust is greater or equal
to
30&nbsp; and less that 50, the scalar_difference will be 15; etc. </p>
<p>You always have the additional option of basing the return value on
the current edit area.&nbsp; For example: </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
scalar_difference_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Scalar difference.&nbsp; If the difference between scalar values</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # for
2 sub-periods is greater than this value,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the
different values will be noted in the phrase.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"WindGust": self.windGust_scalar_nlValue_difference,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp; def
windGust_scalar_nlValue_difference(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mountains = ["Area1", "Area2"]</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if self.currentAreaContains(tree, mountains):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 15</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return {</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
'default': 10,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(0, 30):&nbsp;&nbsp; 10,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(31, 50):&nbsp; 15,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(51, 200): 20,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p>The method applying the threshold must do the following before using
it: </p>
<p>&nbsp;&nbsp;<font color="#006600"> threshold =
self.scalar_difference_threshold(</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tree, node, element, element)</font> <br>
&nbsp;&nbsp; for each value to check: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#006600">
curThreshold = self.nlValue(threshold, value)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Use
curThreshold for the given value</font> <br>
&nbsp; </p>
<h4><a name="DATAVALUEEXTRACTIONFROMTHEGRIDS"></a>DATA VALUE
EXTRACTION FROM THE GRIDS</h4>
<font color="#000000">The following steps are taken to extract the raw
data values from the grids for reporting in narrative products:</font>
<ul>
  <li> <font color="#000000">Sampling -- simple histogram of raw data</font></li>
  <li> <font color="#000000">Sample Analysis -- statistical methods
specified in the product component definition (e.g. avg, mininum,
maximum, vectorModeratedMinMax)</font></li>
  <li> <font color="#000000">Unit Conversion</font></li>
  <li> <font color="#000000">Standard and Non-Standard Rounding</font></li>
  <li> <font color="#000000">Range Adjustment</font></li>
</ul>
<font color="#000000">All of this is done prior to generating
phrases.&nbsp; In addition, if sub-phrases or components are combined,
Range Adjustment is re-done if necessary.&nbsp; There are
user-configurable thresholds and variables to control this processing,
and it is very important to understand the relationships between them
to
produce acceptable results.</font>
<h4><a name="UNITCONVERSION"></a>Unit Conversion</h4>
<font color="#000000">The input and output units are specified in the
following dictionaries.&nbsp; Unit conversion is done automatically</font>
<p><font color="#000000">&nbsp;</font><font color="#006600">&nbsp;&nbsp;
def element_inUnits_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Dictionary of descriptors for various units</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
element_outUnits_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Dictionary of descriptors for various units</font> </p>
<h4><font color="#000000">&nbsp;<a name="STRATEGYFORNONSTANDARDROUNDING"></a>Standard
and
Non-Standard rounding</font></h4>
The system does automatic unit conversion and rounding when statistics
are generated for the narrative product.&nbsp; Rounding is normally
done
using a simple increment value (which can be non-linear as described
above).&nbsp; In lieu of that, a non-standard rounding method may be
specified per weather element.
<p>Example of standard rounding increment (from
ZFP_&lt;site&gt;_Overrides file,
overriding increment_nlValue_dict in ConfigVariables module): </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
increment_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Increment for rounding values</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Units depend on the product</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict =
TextRules.TextRules.increment_nlValue_dict(self, tree, node)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["Wind"] = 5</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
dict</font> </p>
<p>Example of non-standard rounding method (found in ConfigVariables
module): </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
rounding_method_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Special rounding methods</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wind": self.marineRounding,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def marineRounding(self,
value, mode, increment, maxFlag):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Rounding for marine winds</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode =
"Nearest"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
maxFlag:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if value &gt; 30 and value &lt; 34:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mode = "RoundDown"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
elif value &gt; 45 and value &lt; 48:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mode = "RoundDown"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mode = "Nearest"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
self.round(value, mode, increment)</font> </p>
<h4><a name="RANGEADJUSTMENT"></a>Range Adjustment</h4>
<font color="#000000">Range adjustment is a feature that allows you to
set required ranges on data values coming from the grids.&nbsp; For
example, if you would always like to see at least a 5 mph range in the
wind phrases, you can set the "minimum_range_nlValue_dict" for "Wind"
to
5.&nbsp; Then you will see phrases such as "Winds 5 to 10 mph" instead
of "Winds 10 mph." Range adjustment is rather complicated logically and
this leads to some confusion.&nbsp; Purists would argue against using
range adjustment as it is not 100% true to the grids -- however, with
the current suite of zone-based products, it is sometimes
desirable.&nbsp; For a discussion, see the FAQ <a
 href="#RANGE_ADJUSTMENT_QUESTIONSANSWERS">Range Adjustment
Questions/Answers</a> section.</font>
<p><font color="#000000">The basic premise of range adjustment is that
you have to commit to the ranges you choose (and rounding increments as
well) from the beginning of processing.&nbsp; In other words, we can't
just slap on a range at the very end when we are building the phrase;
ranges need to be applied from the moment the grids are analyzed so
that
phrase combining and period combining are comparing pre-adjusted
values.&nbsp; Then, if we do combine two sub-phrases or two periods, we
have to combine their statistics and, then re-apply the range
adjustments to the new values. The system is set up to recognize these
cases when you set the range values listed below.</font> </p>
<p><font color="#000000">The following variables are used to adjust the
range reported for the data value:</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
range_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If
the range of values less than this amount, return as a single value</font>
</p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
minimum_range_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # This
threshold is the "smallest" min/max difference allowed between values
reported.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # For
example, if threshold is set to 5 for "MaxT", and the min value is 45</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # and
the max value is 46, the range will be adjusted to at least a 5 degree</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
range e.g. 43-48.&nbsp; These are the values that are then submitted
for
phrasing</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # such
as:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; HIGHS IN THE MID 40S</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
maximum_range_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Maximum range to be reported within a phrase</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; e.g. 5 to 10 mph</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Units depend on the product</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
range_bias_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
"Min", "Average", "Max"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; Should the range be taken from the "min" "average" or "max"
value of the current range?</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{'default': "Average"}</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
maximum_range_bias_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
"Min", "Average", "Max"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; Should the maximum_range be taken from the "min" "average" or
"max" value of the current range?</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"default": "Average",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wind": "Max"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp; def
minimum_range_bias_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
"Min", "Average", "Max"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; Should the minimum_range be taken from the "min" "average" or
"max" value of the current range?</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"default": "Average",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wind": "Max"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><span style="color: rgb(0, 0, 0);"><font color="#006600">NOTE:
The&nbsp;<span style="font-style: italic; color: rgb(153, 51, 153);">range_nlValue</span>
is&nbsp; applied first and thus supercedes range adjustments
(minimum/maximum ranges).&nbsp; So if your minimum or maximum ranges
are
not taking effect, check to make sure there is not a&nbsp;<span
 style="font-style: italic; color: rgb(153, 51, 153);">range_nlValue&nbsp;</span>set
for the weather element in question.</font> <br>
</span></p>
<p><font color="#000000">Ranges are adjusted at several points in the
processing of phrases:</font> </p>
<ul>
  <li> <font color="#000000">When statistics are initially calculated
and entered into the StatisticsDictionary by the ForecastNarrative
module.</font></li>
  <li> <font color="#000000">When statistics are gathered over
multiple
time ranges from the StatisticsDictionary by the "tree.stats.get"
command.</font></li>
  <li> <font color="#000000">When statistics are combined (e.g.
combining sub-phrases)</font></li>
</ul>
<h4> <font color="#000000">Example: Using Maximum Range and Bias</font></h4>
<font color="#000000">Fire weather users are most concerned with the
minimum RH/maximum Temp during the day, and the maximum RH/minimum Temp
at night. So, rather than give them the full range of values for a
particular zone, we'd like to be able to weight the output range of
values to the lower end of MinRH and MinT, and the higher end of MaxRH
and MaxT.&nbsp; Sampling could be manipulated to do this through the
moderated_dict, but then we would want those results turned into a 5
degree range (rounded to the nearest 5, if possible) returned for
non-mountain zones and a 10 degree range (rounded to the nearest 5) for
mountain zones.</font>
<p><font color="#000000">To accomplish this, include the following in
the&nbsp; Overrides file:</font> </p>
<p><font color="#000000">&nbsp;</font><font color="#006600">&nbsp;&nbsp;
def maximum_range_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Maximum range to be reported within a vector phrase</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp; e.g. 5 to 10 mph</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Units depend on the product</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict =
TextRules.TextRules.maximum_range_nlValue_dict(self, tree, node)</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mountainZones = ["area3"]</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
self.currentAreaContains(tree, mountainZones):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
range = 10</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
range = 5</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MaxT"] = range</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MinT"] = range</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MaxRH"] = range</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MinRH"] = range</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
dict</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
maximum_range_bias_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
"Min", "Average", "Max"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; Should the maximum_range be taken from the "min" "average" or
"max"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; value of the current range?</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict =
TextRules.TextRules.maximum_range_bias_nlValue_dict(self, tree, node)</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MaxT"] = "Max"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MinT"] = "Min"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MaxRH"] = "Max"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MinRH"] = "Min"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
dict</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
increment_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Increment for rounding values</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Units depend on the product</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict =
TextRules.TextRules.increment_nlValue_dict(self, tree, node)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MaxT"] = 5</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MinT"] = 5</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MaxRH"] = 5</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["MinRH"] = 5</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
dict</font> </p>
<h4><a name="DataValueExtractionandCombining"></a><font color="#000000">Data
Value Extraction and Combining</font></h4>
<font color="#000000">It is very important that the combining criteria
be consistent with the data value extraction thresholds and
variables.&nbsp; Combining for scalar and vector magnitudes is based
upon the following thresholds:</font>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
scalar_difference_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Scalar difference.&nbsp; If the difference between scalar values</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # for
2 sub-periods is greater than this value,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the
different values will be noted in the phrase.</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
vector_mag_difference_nlValue_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Replaces WIND_THRESHOLD</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Magnitude difference.&nbsp; If the difference between magnitudes</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # for
sub-ranges is greater than this value,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the
different magnitudes will be noted in the phrase.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Units can vary depending on the element and product</font> </p>
<h4><a name="DataValueExtractionConsistency"></a><font color="#000000">Data
Value Extraction Consistency</font></h4>
<font color="#000000">Certain relationships must hold among the
thresholds and variables used for Data Extraction. In particular:</font>
<ul>
  <li> <font color="#000000">the minimum_range and maximum_range must
be multiples of the increment</font></li>
  <li> <font color="#000000">minimum_range must be less or equal to
the
maximum_range</font></li>
</ul>
<font color="#000000">If this is not the case, the system will
automatically set the differences accordingly.</font>
<h4><a name="STRATEGYFORHANDLINGNULLVALUES"></a>NULL VALUES</h4>
"Null" values are those that are below the&nbsp; "null_nlValue" or, in
the case of Wx, &lt;"NoWx"&gt;.&nbsp; Here area the default thresholds
from the ConfigVariables module:
<p>&nbsp;<font color="#006600">&nbsp;&nbsp; def null_nlValue_dict(self,
tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Magnitude threshold below which values are considered "null" and&nbsp;
not reported.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wind": 5,&nbsp; # mph</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"TransWind": 0,&nbsp; # mph</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"FreeWind": 0,&nbsp; # mph</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Swell": 5,&nbsp; # ft</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Swell2": 5,&nbsp; # ft</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"WaveHeight": 3,&nbsp; # ft</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#000000">You may specify the phrases that will be used
to report Null values.&nbsp; These phrases may be the empty phrase,
"".&nbsp;&nbsp; You may want to specify a different phrase if the the
null value occurs for the entire time period or the for the first
sub-phrase versus in subsequent sub-phrases.&nbsp; Here are the default
null phrase dictionaries from the ConfigVariables module:</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
first_null_phrase_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Phrase to use if values THROUGHOUT the period or</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # in
the first period are Null (i.e. below threshold OR NoWx)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
E.g.&nbsp; LIGHT WINDS.&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp; LIGHT
WINDS BECOMING N 5 MPH.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wind": "light winds",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"TransWind": "",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"FreeWind": "",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Swell": "light swells",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Swell2": "",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wx": "",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"WindGust": "",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wave": "2 feet or less",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def null_phrase_dict(self,
tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Phrase to use for null values in subPhrases other than the first</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Can
be an empty string</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; E.g.&nbsp; "NORTH WINDS 20 to 25 KNOTS BECOMING LIGHT"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wind": "light",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"TransWind": "light",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"FreeWind": "light",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Swell": "light",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Swell2": "",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wx":"",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"WindGust": "",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wave": "2 feet or less",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<h4><a name="STRATEGYFORLOCALEFFECTSPhraseBuildermodule"></a>LOCAL
EFFECTS</h4>
Local effects are set up on a per-Product Component, per-phrase basis.
When you set up a phrase to look for local effects, the system checks
for significant differences in weather element values between
contrasting edit areas. If differences are found, they will be reported
in the phrase.&nbsp; For example, through the GFE GUI we can define
contrasting edit areas, "AboveElev" e.g. above 6000 feet and
"BelowElev"
e.g. below 6000 feet.&nbsp; Then we can set up local effects for a
particular phrase within our Component Product definition by doing the
following:
<ul>
  <li> <b>Define contrasting edit areas</b>. Determine what areas
might
exhibit results that are significantly different.&nbsp; Create edit
areas for them through the GFESuite GUI.&nbsp; For example, we might
expect that elevations above 10,000 feet will have temperatures
significantly different from those below 10,000 feet so we create an
edit area through the GFE for each.</li>
  <li> <b>Specify the areas that need to be intersected with the
current area to examine for local effects</b>.&nbsp; List these by
weather element in the "intersectAreas"&nbsp; of the Component Product
definition.</li>
  <li> <b>Specify the areas that do not need to be intersected with
the
current area to examine for local effects.</b>&nbsp; You might want to
list areas for local effect comparison "as is" i.e. without
intersecting
them with the current area.&nbsp; If so, list these in the
"additionalAreas" section of the Product Component definition.</li>
  <li> <b>Set up a "localEffectsList" </b>for the phrase(s)<b> </b>for
which you want local effects to be generated.&nbsp; The local effects
list consists of 1 or more LocalEffects.&nbsp; If&nbsp;<font
 color="#663366"> </font><font color="#000000">you have more than one
LocalEffect, each is examined in order. The first local effect to fire
will be reported.&nbsp;</font><font color="#990000"> NOTE: The List of
Local Effects may be specified as a Python method which will be given
arguments (tree, node) and should return a list of Local Effects.</font><font
 color="#000000">A Local Effect consists of the following information:</font></li>
  <ul>
    <li>List of Local Effect Areas.&nbsp; You may list 2 or more areas
for comparison.&nbsp; When there are more than 2 areas, the system
determines "groupings" of areas with similar statistics and reports
them
together.&nbsp; <font color="#990000">NOTE: The List of Local Effects
may be specified as a Python method which will be given arguments
(tree,
node) and should return a list of Local Effect Areas.</font>&nbsp; Each
Local Effect Area consists of the following:</li>
    <ul>
      <li>Edit Area Name.&nbsp;&nbsp; This can be a special string
"__Current__" to denote the current edit area.</li>
      <li>Description String: This is the string to be used in the
resulting phrase e.g. "in the mountains", "on the coast".&nbsp; <font
 color="#990000">NOTE: the Description String can be specified as a
Python method which will be given arguments (tree, node, leArea) and
should return a description string.&nbsp; In this way, you can
determine
the description string on-the-fly perhaps dependent on the current edit
area.</font></li>
    </ul>
    <li>Difference Threshold: This is a scalar difference value to be
used in comparing the local effect areas.&nbsp;&nbsp; <font
 color="#990000">NOTE: the Difference Threshold can be specified as a
Python method which will be given arguments (tree, node, localEffect,
leArea1Label, leArea2Label) and should return 1 if there is a local
effect difference detected between the two areas.&nbsp;&nbsp; This will
allow more flexibility in drawing comparisons between local effect
areas.</font></li>
    <li>Local Effect Connecting Words:&nbsp; This is a word string to
connect local effects that are reported within one phrase.&nbsp;
E.g.&nbsp;<font color="#993300"> "Highs 45-55</font><font
 color="#006600">...except</font><font color="#993300">35-45 above
timberline."</font></li>
  </ul>
</ul>
The following Component definition sets up local effects for the
highs_phrase, lows_phrase, and wind_withGusts_phrase:
<p>&nbsp;<font color="#33cc00">&nbsp;</font><font color="#006600"> def
Period_1(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"type": "component",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"methodList": [</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.orderPhrases,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.assemblePhrases,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.wordWrap,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"analysisList": [</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MinT", self.stdDevMinMax),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MaxT", self.stdDevMinMax),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("T", self.hourlyTemp),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wind", self.vectorMedianRange, [6]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wind", self.vectorMinMax, [6]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("WindGust", self.avg, [6]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"phraseList":[</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.wind_summary,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.reportTrends,</font> <br>
<font color="#993399">&nbsp;</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.highs_phrase,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.lows_phrase,</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.highs_phrase, self._tempLocalEffects_list()),</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.lows_phrase, self._tempLocalEffects_list()),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.highs_range_phrase,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.lows_range_phrase,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.wind_withGusts_phrase,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font
 color="#663366"> (self.wind_withGusts_phrase,
self._windLocalEffects_list()),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"intersectAreas": [</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Areas listed by weather element that will be</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# intersected with the current area then</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# sampled and analysed.</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# E.g. used in local effects methods.</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MaxT", ["Mountains", "Valleys"]),</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MinT", ["Mountains", "Valleys"]),</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wind", ["Coast", "Inland"]),</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("WindGust", ["Coast", "Inland"]),</font> <br>
<font color="#006600">&nbsp;]</font> </p>
<p><font color="#663366">&nbsp;&nbsp;&nbsp; def
_windLocalEffects_list(self):</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea("Coast", "near the coast")</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("Inland", "inland")</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[self.LocalEffect([leArea1, leArea2], 10, " and ")]</font> </p>
<p><font color="#663366">&nbsp;&nbsp;&nbsp; def
_tempLocalEffects_list(self):</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea("Valleys", "")</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("Mountains", "in the mountains")</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[self.LocalEffect([leArea1, leArea2], 8, "...except ")]</font> </p>
<p>As a result,&nbsp;&nbsp; the system will automatically calculate the
intersection of the Mountains, Valleys, (for MaxT, MinT) and Coast,
Inland (for Wind and WindGust) areas with each edit area as it
processes
it.&nbsp;&nbsp; Sampling and Analysis statistics will be calculated for
both intersection areas for the appropriate weather elements. Then, the
local effects phrase can examine the statistics for differences and
report according to the methods and words given in the local effects
definition. For example, the following phrases could be generated
depending on the data: </p>
<p>&nbsp;&nbsp;&nbsp; <font color="#993300">"Highs 45-55."</font> <br>
<font color="#993300">&nbsp;&nbsp;&nbsp; "Highs 45-55...except 35-45
above timberline."</font> <br>
<font color="#993300">&nbsp;&nbsp;&nbsp; "North winds 20 mph."</font> <br>
<font color="#993300">&nbsp;&nbsp;&nbsp; "North winds 20 mph near the
coast and&nbsp; west winds 10 mph inland."</font> <br>
<font color="#993300">&nbsp;&nbsp;&nbsp; "Near the coast...North winds
20 mph becoming 10 mph in the afternoon. Inland...North winds 10 mph
becoming light in the afternoon."</font> </p>
<h4><a name="LocalEffectsandCompoundPhrases"></a><font color="#000000">Local
Effects and Compound Phrases</font></h4>
<font color="#000000">Some phrases are "compound" i.e. they are
composed of other phrases. In this case, you must specify the Local
Effect per phrase within the compound phrase definition as in the
following example:</font>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
skyWeather_byTimeRange_compoundPhrase(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"phraseList": [</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.fireSky_phrase</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#self.weather_phrase,</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.weather_phrase, self._generalLocalEffects_list()),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"phraseMethods": [</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.assembleSentences,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.skyWeather_finishUp,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp; def
_generalLocalEffects_list(self):</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea("Coast",&nbsp; "on the coast")</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("Inland", "inland")</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea3 = self.LocalEffectArea("City", "in the city")</font> <br>
<font color="#663366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[self.LocalEffect([leArea1, leArea2, leArea3], 5, " ")]</font> </p>
<p><font color="#000000">Remember, as always, to include the local
effect areas in the "intersectAreas" list within the component
definition:</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp; def
getFirePeriod_intersectAreas(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MinT", ["BelowElev", "AboveElev"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MaxT", ["BelowElev", "AboveElev"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MinRH", ["BelowElev", "AboveElev"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MaxRH", ["BelowElev", "AboveElev"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("RH", ["BelowElev", "AboveElev"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wx", ["BelowElev", "AboveElev"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
]</font> <br>
&nbsp; </p>
<h4><a name="ConsolidationRulesforLocalEffects"></a>Consolidation
Rules for Local Effects</h4>
Local effect phrases with multiple weather elements and time periods
could become complicated and unduly wordy.&nbsp; To avoid this, we
implement the following consolidation rules for local effect phrases:
<ul>
  <li> <b>Embedded Local Effects</b> for the simple case of no
sub-phrases simply use the words supplied in the Local Effect
definition:</li>
  <ul>
    <li> <font color="#993300">"Highs 45 except 25 above timberline."</font></li>
    <li> <font color="#993300">"North winds 20 to 25 mph near the
coast
and west winds 10 mph inland."</font></li>
  </ul>
</ul>
<ul>
  <li> <b>Conjunctive Local Effects for multiple sub-phrases</b>: If
any sub-phrase has a local effect, separate into two phrases, one for
each local effect area.&nbsp; Qualify each phrase with the descriptive
words for the local effect area.</li>
  <ul>
    <li>Instead of: <font color="#993300">"North winds 20 to 25 mph
near the coast and west winds 10 mph inland becoming 10 mph near the
coast and light inland in the afternoon."</font></li>
    <br>
Produce: <font color="#993300">"Near the coast...North winds 20 to 25
mph becoming 10 mph in the afternoon.&nbsp; Inland...North winds 20 to
25 mph becoming light in the</font> <li><font color="#993300">afternoon."</font></li>
    <li>Instead of: <font color="#993300">"North winds 20 to 25 mph
except west winds 10 mph in the valleys becoming 10 mph except light in
the valleys in the afternoon."</font></li>
    <br>
    <font color="#000000">Produce:</font><font color="#993300"> "North
winds 20 to 25 mph becoming 10 mph. In the valleys...west winds 10 mph
becoming light in the afternoon."</font>
  </ul>
</ul>
<font color="#cc0000">NOTE: </font><font color="#000000">If you are
setting up a local effect for a multiple-element phrase, you MUST
include all the weather elements in the "intersectAreas" and/or
"additionalAreas" lists.</font>
<h4><a name="LocalEffectExamples"></a>Local Effect Examples</h4>
<h4> <a name="NullValuesandLocalEffects"></a><b>Null Values and
Local Effects</b></h4>
Below area local Effect phrases where one area has a null (below
threshold) value so that only one local effect area is mentioned.
<p>Set Up: </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
_windLocalEffects_list(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
srnInland = self.LocalEffectArea("Inland","")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
srnBeaches = self.LocalEffectArea("Beaches","at the beaches")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[self.LocalEffect([srnInland, srnBeaches], 5, "...except ")]</font> </p>
<p>The local effect descriptor will appear at the end of the sentence
IF there is only one subphrase. </p>
<p><span style="color: rgb(153, 51, 0);">SOUTHWEST WINDS 25 TO 35 MPH
AT THE BEACHES.</span> </p>
<p>Otherwise, the sentence would be&nbsp; ambiguous: </p>
<p><span style="color: rgb(153, 51, 0);">SOUTHWEST WINDS 25 TO 35 MPH
INCREASING TO 40 TO 50</span> <br>
<span style="color: rgb(153, 51, 0);">MPH IN THE AFTERNOON AT THE
BEACHES.</span> </p>
<p>So the system&nbsp; produces: </p>
<p><span style="color: rgb(153, 51, 0);">AT THE BEACHES...SOUTHWEST
WINDS 25 TO 35 MPH INCREASING TO 40 TO 50</span> <br>
<span style="color: rgb(153, 51, 0);">MPH IN THE AFTERNOON.</span> </p>
<p><span style="font-weight: bold;">Null values and Wx:</span> For
periods in which you have Local Effects for Wx, you might want to
specify a<span style="color: rgb(102, 51, 102);"></span><span
 style="font-style: italic; color: rgb(102, 51, 102);">first_null_nlValue</span>
and&nbsp;<span style="font-style: italic; color: rgb(102, 51, 102);">null_nlValue</span>
of "dry" so that the local effect can be correctly reported.&nbsp; For
example: </p>
<p><span style="color: rgb(0, 102, 0);">def null_nlValue_dict(self,
tree, node):</span> <br>
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Descriptors for phrases</span> <br>
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict = TextRules.TextRules.null_nlValue_dict(self, tree, node)</span> <br>
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
componentName = node.getComponentName()</span> <br>
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if componentName == "Period_1":</span> <br>
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict[Wx"] = "dry"</span> <br>
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return dict</span> </p>
<p>Then you will get phrases like: </p>
<p style="color: rgb(102, 51, 51);">SCATTERED SHOWERS...EXCEPT DRY IN
THE BLUE MOUNTAINS. </p>
<p>instead of just: </p>
<p style="color: rgb(102, 51, 51);">SCATTERED SHOWERS. </p>
<h4><a name="ExceptversusOtherwiseWording"></a>"Except" versus
"Otherwise" Wording</h4>
Below area examples of how to set up "except" types wording versus
"otherwise" wording in a local effect phrase. <br>
Set-up:
<p>&nbsp;<font color="#006600">&nbsp;&nbsp; def
_windLocalEffects_list(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
srnInland = self.LocalEffectArea("BelowElev","")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
srnBeaches = self.LocalEffectArea("AboveElev","at the beaches")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[self.LocalEffect([srnInland, srnBeaches], 5, "...except ")]</font> </p>
<p>SOUTHWEST WINDS 5 TO 15 MPH...EXCEPT SOUTHWEST 25 TO 35 MPH AT THE
BEACHES. </p>
<p>SOUTHWEST WINDS 5 TO 15 MPH. AT THE BEACHES...SOUTHWEST WINDS 25 TO <br>
35 MPH INCREASING TO 40 TO 50 MPH IN THE AFTERNOON. </p>
<p>Set-up: </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
_windLocalEffects_list(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
srnInland = self.LocalEffectArea("BelowElev","", "inland" )</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
srnBeaches = self.LocalEffectArea("AboveElev","at the beaches")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[self.LocalEffect([srnBeaches, srnInland,], 5, "...otherwise ")]</font>
</p>
<p>SOUTHWEST WINDS 25 TO 35 MPH AT THE BEACHES...OTHERWISE SOUTHWEST 5
TO <br>
15 MPH. </p>
<p>AT THE BEACHES...SOUTHWEST WINDS 25 TO 35 MPH INCREASING TO 40 TO 50
<br>
MPH IN THE AFTERNOON. INLAND...SOUTHWEST WINDS 5 TO 15 MPH. </p>
<h4><a name="LocalEffectAreasthatdonotIntersecttheCurrentArea"></a>More
Local Effect Features</h4>
The following example shows several features of the Local Effects
capability:
<ul>
  <li>using "additional" (not "intersect") areas for Local Effects</li>
  <li>using a method for defining the LocalEffect list based on the
current edit area</li>
  <li>using the __Current__ area for comparison</li>
  <li>checking for multiple Local Effects in order of precedence</li>
</ul>
In the following set-up, we have a small area (area1) which is a subset
of the larger zone.&nbsp; This area is used instead of the larger zone
for phrase reporting.&nbsp; However, in the case of temperature, we
want
to identify if certain regions (the Rush Valley or the Benches) within
the zone exhibit temperatures significantly different from the small
area.&nbsp;&nbsp; This applies to only one area (area1) .&nbsp; For
other areas in the product , we do not want to identify any Local
Effects.&nbsp; Since the comparison areas (Rush_Valley and Benches) do
not intersect area1, we specify them in the product component as
"additionalAreas" instead of "intersectAreas" AND we set the
"intersectFlag" to zero when defining them as LocalEffectAreas.
<p>Set-up: </p>
<p>In the product component definition, we specify the local effects
list as a method rather returning a list.&nbsp; This is necessary since
we want to define the list "on-the-fly" based on the current edit area:
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
 color="#006600">(self.highs_phrase, self._tempLocalEffects_list),</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.lows_phrase, self._tempLocalEffects_list),</font> </p>
<p><font color="#000000">Then we add in the additonal areas to be
sampled and analyzed:</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"additionalAreas": [</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Areas listed by weather element that will be</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# intersected with the current area then</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# sampled and analyzed.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# E.g. used in local effects methods.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MaxT", ["Benches", "Rush_Valley"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("MinT", ["Benches", "Rush_Valley"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> </p>
<p><font color="#000000">Finally, we provide the method for defining
the local effects list "on-the-fly."</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
_tempLocalEffects_list(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
self.currentAreaContains(tree, ["area1"]):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea(</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"__Current__","",intersectFlag=0)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("Rush_Valley",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"in the rush valley", intersectFlag=0)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea3 = self.LocalEffectArea(</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Benches", "in the benches",intersectFlag=0)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return [</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.LocalEffect([leArea1,leArea2],5,"...except "),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.LocalEffect([leArea1,leArea3],5,"...except "),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
]</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return []</font> </p>
<p><font color="#000000">Note that the Rush Valley will be checked
first.&nbsp; If a local effect is found, it will be reported:</font> </p>
<p><font color="#993500">HIGHS IN THE UPPER 50S...EXCEPT IN THE UPPER
20S TO UPPER 40S IN THE RUSH VALLEY.</font> </p>
<p><font color="#000000">If not, the Benches will be checked and if a
local effect is found, it will be reported:</font> </p>
<p><font color="#973500">HIGHS IN THE UPPER 50S...EXCEPT IN THE UPPER
20S TO UPPER 40S IN THE BENCHES.</font> </p>
<p><font color="#000000">Finally, if neither area triggers a local
effect, a simple phrase will be reported:</font> </p>
<p><font color="#973500">HIGHS IN THE UPPER 50S.</font> <br>
&nbsp; </p>
<h4><a name="LocalEffectsforSnowAccumulationandTotalSnowAccumulation"></a>Local
Effects for Snow Accumulation and Total Snow Accumulation -- Using a
Method for the Checking the Local Effect Threshold</h4>
This section outlines how to produce local effect phrases such as the
following:
<p><font color="#993300">SNOW ACCUMULATION 4 INCHES...EXCEPT 7 INCHES
ABOVE</font> <br>
<font color="#993300">TIMBERLINE. TOTAL SNOW ACCUMULATION 9
INCHES...EXCEPT 18 INCHES</font> <br>
<font color="#993300">ABOVE TIMBERLINE.</font> </p>
<p>In your overrides file, you must override the product component(s)
for
which you want to report local effects for the snow_phrase and/or
total_snow_phrase. In these component definitions, specify the local
effect as follows: </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.snow_phrase,self._snowAmtLocalEffects_list()),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.total_snow_phrase,self._totalSnowAmtLocalEffects_list()),</font> </p>
<p>Next, add the "intersectAreas" to these components for SnowAmt and
IceAmt (note that IceAmt is handled by the SnowAmt phrase): </p>
<p>&nbsp;<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"intersectAreas": [</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Areas listed by weather element that will be</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# intersected with the current area then</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# sampled and analysed.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# E.g. used in local effects methods.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("SnowAmt", ["BelowElev", "AboveElev"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("IceAmt", ["BelowElev", "AboveElev"]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> </p>
<p><font color="#000000">IMPORTANT NOTE:&nbsp; The total_snow_phrase
looks AHEAD one period for information about snow ending (SnowAmt = 0).
Therefore, you must include the "intersectAreas" in the component
FOLLOWING the ones in which you are specifying a local effect for the
total_snow_phrase. For example, in the ZFP_&lt;site&gt;_Overrides file
using the 10-503
directive, if I set up a total_snow_phrase local effect for Period_1
and
Period_2_3, I must also include the "intersectAreas" for Period_4_5.</font>
</p>
<p><font color="#000000">Finally,&nbsp; include the following local
effect lists in your Overrides file:</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
_snowAmtLocalEffects_list(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea("BelowElev", "")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("AboveElev", "above timberline")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[self.LocalEffect([leArea1, leArea2], 2, "...except ")]</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
_totalSnowAmtLocalEffects_list(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea("BelowElev", "")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("AboveElev", "above timberline")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[self.LocalEffect(</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[leArea1, leArea2], self._checkTotalSnow, "...except ")]</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def _checkTotalSnow(self,
tree, node, localEffect, leArea1Label, leArea2Label):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
totalSnow1 = self.getTotalSnow(tree, node, leArea1Label)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
totalSnow2 = self.getTotalSnow(tree, node, leArea2Label)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
totalSnow1 is None or totalSnow2 is None:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 0</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
abs(totalSnow1 - totalSnow2) &gt; 3:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 1</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
0</font> </p>
<h4><a name="LocalEffectsfortheCombinedSkyPopWxPhrase"></a>Local
Effects for the Combined SkyPopWx Phrase</h4>
You can set up Local Effects for the combined skyPopWx_phrase just like
any other phrase.&nbsp; This phrase has&nbsp; primary element of Wx
with
Sky and PoP as secondary elements.&nbsp; So local effects (as well as
sub-phrase combining) is based upon Wx.&nbsp; If&nbsp; you are
using the skyPopWx_phrase, you must also include the independent Sky,
PoP, and Wx phrases in your phraseList and then
include local effects for these phrases as well.&nbsp; It is
recommended that you use the following Local Effect
Lists.&nbsp;&nbsp;&nbsp; So, you would have: <br>
&nbsp;
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp; "phraseList":[</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.sky_phrase, self._skyLocalEffects_list()),<br>
</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.skyPopWx_phrase, self._skyPopWxLocalEffects_list()),<br>
</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.weather_phrase,self._wxLocalEffects_list()),<br>
</font><font color="#006600">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(self.popMax_phrase, self._popLocalEffects_list()),<br>
</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
</p>
<p>And also within the product component definition: </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"intersectAreas": [</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Sky", ["AboveElev", "BelowElev"]),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wx",&nbsp; ["AboveElev", "BelowElev"]),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("PoP", ["AboveElev", "BelowElev"]),<br>
</font><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font>&nbsp;</p>
Set up the Local Effects lists as follows:<br>
<br>
&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 102, 0);">def
_skyLocalEffects_list(self):</span><br style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea("AboveElev", "windward")</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("BelowElev", "leeward")</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return [self.LocalEffect([leArea1, leArea2], self.checkSkyDifference,
"...")]</span><br style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp; def
_wxLocalEffects_list(self):</span><br style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea("AboveElev", "windward")</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("BelowElev", "leeward")</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return [self.LocalEffect([leArea1, leArea2], 0, "...")]</span><br
 style="color: rgb(0, 102, 0);">
<br style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp; def
_popLocalEffects_list(self):</span><br style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea("AboveElev", "windward")</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("BelowElev", "leeward")</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return [self.LocalEffect([leArea1, leArea2], 20, "...")]</span><br
 style="color: rgb(0, 102, 0);">
<br style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp; def
_skyPopWxLocalEffects_list(self):</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea1 = self.LocalEffectArea("AboveElev", "windward")</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
leArea2 = self.LocalEffectArea("BelowElev", "leeward")</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Set threshold to be used by checkSkyWxDifference</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self._skyLocalEffectThreshold = 38</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return [self.LocalEffect([leArea1, leArea2],</span><br
 style="color: rgb(0, 102, 0);">
<span style="color: rgb(0, 102, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.checkSkyWxDifference, "...")]</span><br
 style="color: rgb(0, 102, 0);">
<br>
<h4>&nbsp;<a name="PERIODCOMBINING"></a>PERIOD COMBINING</h4>
Narrative products include a period combining capability that attempts
to combine periods with similar weather forecast values. To activate
period combining uncomment the following line in your Overrides file.
<p>&nbsp;&nbsp;&nbsp; <font color="#006600">Definition["periodCombining"]
= 1&nbsp;&nbsp;&nbsp;&nbsp; # If 1, do period combining</font> <br>
&nbsp; </p>
<p>Period combining is set up by methods found in the PhraseBuilder
module: </p>
<p>1) If the periodCombining flag is set to 1 in the product, we add a
method to the product narrative tree top level node called&nbsp;
"combineComponents" (in PhraseBuilder module). <br>
2) The "combineComponents" method is called at the top of the tree and
compares all consecutive components for similarity.&nbsp; Also, we are
only combining components that begin 36 hours after the issuance time
of the product. <br>
3) If two components are deemed similar (according to the "<i><font
 color="#993399">periodCombining_elementList</font></i>" (in
ConfigVariables)), then the component nodes are collapsed into one
node with the time range spanning the original nodes. <br>
4) From here all phrases and processing pretty much the same as it
would have been for the original nodes.&nbsp; To simplify combined
period
phrasing, there is a threshold "<i><font color="#993399">collapsedSubPhrase_hours</font></i>"
(in ConfigVariables) which is set to 12 hours as the default. If the
period is longer than these hours, subphrases will automatically be
collapsed. &nbsp; <br>
</p>
<p>Periods can be combined providing the differences between the
adjacent periods are small.&nbsp; There is one method per weather
element that determines whether two periods should be combined or
not.&nbsp; These methods are found in the PhraseBuilder module.&nbsp;
Each of them begin with "similar" followed by the weather element
name.&nbsp; The table below shows the methods that have been
implemented
thus far and their thresholds. <br>
&nbsp; <br>
<table nosave="" border="1" cols="3" width="100%">
  <caption><br>
  </caption><tbody>
  </tbody> <tbody>
    <tr>
      <td>&nbsp; Element Name as listed in the <i><font color="#993399">periodCombining_elementList</font></i></td>
      <td>&nbsp; Method Name (in PhraseBuilder module)</td>
      <td>&nbsp; Thresholds</td>
    </tr>
    <tr>
      <td>&nbsp; Sky</td>
      <td>&nbsp; <i><font color="#993399">similarSky</font></i></td>
      <td>&nbsp; Sky words are similar<br>
      </td>
    </tr>
    <tr>
      <td>&nbsp; Wind</td>
      <td>&nbsp; <i><font color="#993399">similarWind</font></i></td>
      <td>&nbsp; mag within 10 knots&nbsp; <br>
&nbsp; dir within 45 degrees</td>
    </tr>
    <tr>
      <td>&nbsp; Wx</td>
      <td>&nbsp; <i><font color="#993399">similarWx</font></i></td>
      <td>&nbsp; Identical wx keys per each analyzed sub-range<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;PoP<br>
      </td>
      <td style="vertical-align: top;">&nbsp; <i><font color="#993399">similarPoP</font></i><br>
      </td>
      <td style="vertical-align: top;">PoPs are equal or both below<i><font
 color="#993399"> pop_lower_threshold </font></i>or both above<i><font
 color="#993399"> pop_upper_threshold<br>
      </font></i></td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;MaxT<br>
      </td>
      <td style="vertical-align: top;"><i><font color="#993399">similarMaxT</font></i></td>
      <td style="vertical-align: top;">MaxT within 5 degrees<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;MinT</td>
      <td style="vertical-align: top;"><i><font color="#993399">similarMinT</font></i></td>
      <td style="vertical-align: top;">MinT within 5 degrees<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">WaveHeight<br>
      </td>
      <td style="vertical-align: top;"><i><font color="#993399">similarWaveHeight</font></i></td>
      <td style="vertical-align: top;">WaveHeights within 4 feet<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">DiurnalSkyWx</td>
      <td style="vertical-align: top;"><i><font color="#993399">similarDiurnalSkyWx</font></i></td>
      <td style="vertical-align: top;">DiurnalSkyWx will combine if
there is a diurnal pattern of sky and wx. For example,&nbsp; "CLOUDY IN
THE NIGHT AND MORNING...OTHERWISE CLEAR." or "LOW CLOUDS AND FOG IN THE
NIGHT AND MORNING...OTHERWISE CLEAR."<br>
Note that it will also combine if the sky and wx are similar without a
diurnal pattern.&nbsp; <br>
      </td>
    </tr>
  </tbody>
</table>
</p>
<p>Each of these methods can be overridden in your Overrides
file.&nbsp; In
general, the threshold values are defined near the top of the method,
so
you won't need to hunt for them or change them in several places.&nbsp;
If you desire to change the thresholds, copy the method into your
Overrides
file and modify the threshold value.&nbsp; You can also modify the
algorithm, if you like.&nbsp; The default method retrieves the
statistics and examines them to see if the values between each
component
are close enough to combine.&nbsp; You will likely want to leave the
code that retrieves the statistics unmodified.&nbsp; But you can choose
to change the logic that decides if the values are "similar". </p>
<p>When components are collapsed, we do not want phrases to have
detailed sub-phrases as we would in a normal 12-hour period.&nbsp;
Sub-phrases are then automatically collapsed if the combined period
exceeds the <i><font color="#993399">collapsedSubPhrase_hours&nbsp;</font></i><font
 color="#000000"> found in the ConfigVariables module.&nbsp;&nbsp; When
sub-phrases are collapsed, the data is summarized according to the </font><i><font
 color="#993399">mergeMethod</font></i><font color="#000000"> for the
weather element being collapsed.&nbsp; These settings can be overridden
in your Overrides file.</font> </p>
<p>&nbsp;<font color="#006600">&nbsp;&nbsp; def
collapseSubPhrase_hours_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If
the period is longer than these hours, subphrases will automatically</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # be
collapsed.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"otherwise": 24,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#"Wx": 24,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def mergeMethod_dict(self,
tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Designates the mergeMethod to use when sub-phrases are automatically
collapsed.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"otherwise": "Average",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"MinT": "Min",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"MaxT": "Max",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"PoP": "Max",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"Wx": "List",&nbsp; # Still want Wx to be broken out</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<h4>&nbsp;<a name="STRATEGYFORPHRASECONSOLIDATION"></a>PHRASE
CONSOLIDATION</h4>
Phrases with multiple weather elements and complex temporal resolution
can become very complicated and unduly wordy.&nbsp; To avoid these
situations, we implement a set of consolidation rules described in this
section.&nbsp; These rules are for Scalar and Vector elements.&nbsp;
For information on Weather consolidation see the Section on <a
 href="#WEATHERKEYFILTERING">Weather Phrasing.</a><br>
<p>Definitions: Phrases are composed of sub-phrases depending on the
temporal resolution of the statistics.&nbsp; For example, the Wind
phrase in the ZFP is composed of 2 6-hour sub-phrases, e.g. "North wind
10-15 mph increasing to 20 mph in the afternoon." A phrase can report
on
multiple elements (e.g. Wind and WindGust).&nbsp; "North wind 10-15 mph
with gusts up to 35 mph."&nbsp; Weather elements in these phrases are
considered "primary" and "secondary". </p>
<ul>
  <li>More than one element can be designated as "primary" in a phrase.
For example, for the wind phrase "Wind" and "WindGust" would both be
primary.</li>
  <li>Though there can be more than one primary element for
consolidation purposes, the sub-phrase time ranges will be based upon
the first element's statistics.</li>
  <li> <b>Consolidation Rule: Separate any "primary elements" that are
similar throughout the time period into a separate phrase.</b></li>
  <ul>
    <li>Instead of: <font color="#993300">"North wind 10 mph with
gusts up to 35 mph increasing to 20 mph with gusts up to 35 mph in the
afternoon."</font></li>
    <li>Produce: <font color="#993300">"North wind 10 mph increasing
to 20 mph in the afternoon. Gusts up to 35 mph."</font></li>
  </ul>
  <li>Elements can still be designated as secondary so that when
combined, an average, min, max, or sum of their values can be used.
Suppose that Swell and Swell2 are primary and Period and Period2 are
secondary.</li>
  <ul>
    <li>Instead of: <font color="#993300">"North swell 10 ft at 5
seconds and northeast swell 12 ft at 5 seconds becoming north swell 10
ft at 15 seconds and north swell 15 ft at 5 seconds"</font></li>
    <li>Produce: <font color="#993300">"North swell 10 ft at 10
seconds and northeast swell 12-15 ft at 5 seconds."</font></li>
  </ul>
  <li> <b>Consolidation Rule For Vector Direction: If there are no
secondary elements and the direction is a progression with similar
magnitudes, report only the first and last directions.</b></li>
  <ul>
    <li>Instead of: <font color="#993300">"North wind 10 mph becoming
northeast 15 mph in the late morning becoming east 10 mph."</font></li>
    <li>Produce: <font color="#993300">"North wind 10-15 mph becoming
east 10 mph in the afternoon."</font></li>
  </ul>
  <li> <b>Consolidation Rule For Trends: If there are no secondary
elements and the magnitude is a progression over the time period,
report
only the first and last magnitudes with no time descriptors.</b></li>
  <ul>
    <li>Instead of: <font color="#993300">"Waves 2 to 4 feet building
to 3 to 6 ft in the late morning and early afternoon building to 4 to 7
feet."</font></li>
    <li>Produce: <font color="#993300">"Waves 2 to 4 feet building to
4 to 7 feet."</font></li>
  </ul>
</ul>
<h4> <a name="PHRASEORDERING"></a>PHRASE ORDERING</h4>
You might want to re-order the phrases of a component based on the
forecast data.&nbsp; For example, suppose we have the following:
<p><font color="#993300">.TODAY...STRONG WINDS. THUNDERSTORMS WITH
HEAVY RAINFALL.&nbsp; HIGHS</font> <br>
<font color="#993300">AROUND 80. SOUTHEAST WINDS AROUND 70 MPH BECOMING
SOUTH AROUND 105</font> <br>
<font color="#993300">MPH IN THE AFTERNOON.</font> </p>
<p><font color="#000000">The winds are the most dominant feature and
thus you might want to move the "wind_withGusts_phrase" closer to the
beginning of the forecast.&nbsp; To re-order phrases on-the-fly, follow
steps similar to this example:</font> </p>
<p><font color="#000000">--Make sure the Product Component Definition
for any Periods in which you'd like to order the phrases has the
method, "orderPhrases", prior to "assembleSubPhrases":</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def Period_1(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
component =&nbsp; {</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"type": "component",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"methodList": [</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.orderPhrases,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.assemblePhrases,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.wordWrap,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
],</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
....</font> </p>
<p><font color="#000000">&nbsp;--Modify the
"orderPhrases"(PhraseBuilder) method, for example:</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def orderPhrases(self,
tree, component):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
reorderList = []</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
timeRange = component.getTimeRange()</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
areaLabel = component.getAreaLabel()</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Put in some logic to see if you want to re-arrange the order</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # of
the phrases.&nbsp; For example:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Check for high winds</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
windMax, dir = tree.stats.get("Wind", timeRange, areaLabel,
mergeMethod="Max")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
windMax &gt; 50:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Put wind phrase first</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
reorderList.append(("wind_withGusts_phrase", "weather_phrase"))</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Apply any reorderings that were identified</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for
name1, name2 in reorderList:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.moveAbove(tree, component, name1, name2)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
self.DONE()</font> </p>
<h4><a name="UNTILPHRASING"></a>"UNTIL" PHRASING</h4>
In some phrases, you might want more resolution on the time descriptors
such as in the following:
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#660000"> "</font><font
 color="#993300">North winds 20 mph until 10 AM then 35 mph."</font> </p>
<p>To accomplish this, override the flags below from the
ConfigVariables module.&nbsp; Be sure that if you want higher temporal
resolution in your phrase, to set the temporal resolution in the
analysisList accordingly.&nbsp; For example: </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("Wind", self.vectorMedianRange, [0]), </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
untilPhrasing_flag_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If
set to 1, "until" time descriptor phrasing will be used.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # E.g.
"NORTH WINDS 20 MPH UNTIL 10 AM...THEN 35 MPH"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"otherwise": 0,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#"Wind" : 1,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
onTheFly_untilPhrasing_flag_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If
set to 1, "until" time descriptor phrasing will be used ONLY if</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the
time range for a sub-phrase does not end on a 3-hour boundary.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"otherwise": 1,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#"Wind" : 1,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
untilPhrasing_format_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Format for "until" time descriptors.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If
"military": UNTIL 1000</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If
"standard": UNTIL 10 AM</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
{</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"otherwise": "military",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#"Wind": "standard",</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</font> </p>
<p><font color="#000000">The untilPhrasing may apply to only certain
components of your product.&nbsp; You can make this distinction as in
this&nbsp; example from the FWF:</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
untilPhrasing_flag_dict(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If
set to 1, "until" time descriptor phrasing will be used.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # E.g.
"NORTH WINDS 20 MPH UNTIL 10 AM...THEN 35 MPH"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Be
sure to increase the temporal resolution if desired:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
E.g.&nbsp; ("MixHgt", self.minMax, [0]),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dict =
TextRules.TextRules.untilPhrasing_flag_dict(self, tree, node)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["LAL"] = 1</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
componentName = node.getComponent().get("name")</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
componentName == "FirePeriod":</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["Sky"] = 1</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
dict["Wx"]&nbsp; = 1</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
dict</font> </p>
<h4><a name="HANDLINGVISIBILITY"></a><font color="#000000">VISIBILITY</font></h4>
Visibility is an attribute of the Wx grid and is reported on a
sub-phrase level within the <font color="#006600">weather_phrase</font>.&nbsp;
Since&nbsp; each sub-phrase can have multiple subkeys, we report&nbsp;
the lowest visibility over the subkeys.&nbsp;&nbsp;&nbsp; The
visibility
attribute is specified in the grids in statute miles.&nbsp; You can
specify the output units ("SM" or "NM" for nautical miles) for
visibility in the <i><font color="#993366">element_outUnits_dict </font></i><font
 color="#000000">for "Visibility"</font><i><font color="#993366">. </font></i>Here's
an example:
<p>Example 1: <br>
&nbsp; Grids: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hour 1-6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Patchy F 1/4SM Chc R 1/2SM <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hour 7-12&nbsp;&nbsp; Sct&nbsp; RW </p>
<p>&nbsp; Phrase: <br>
CHANCE OF LIGHT RAIN AND PATCHY FOG WITH VISIBILITY LESS THAN 1 NM THEN
SCATTERED RAIN <br>
SHOWERS IN THE AFTERNOON. </p>
<p>Example 2: <br>
&nbsp; Grids: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hour 1-6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Patchy F 1/4SM Chc R 1/2SM <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hour 7-12&nbsp;&nbsp; Sct&nbsp; RW
11/2SM </p>
<p>&nbsp; Phrase:&nbsp; CHANCE OF LIGHT RAIN AND PATCHY FOG WITH
VISIBILITY LESS THAN 1 NM THEN SCATTERED RAIN SHOWERS WITH 2 NM
VISIBILITY IN THE AFTERNOON. </p>
<p><font color="#000000">The wording for visibility within the weather
phrase can be configured by overriding the</font><i><font
 color="#993366">
visibility_weather_phrase_nlValue.</font></i> </p>
<p>You can set the <i><font color="#993366">null_nlValue&nbsp;</font></i>
for "Visibility" so that only visibilities below the threshold are
reported.&nbsp; The value should be in nautical miles. Suppose we have
set this value to 3 nautical miles, Then: </p>
<p>Example 3: <br>
&nbsp; Grids: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hour 1-6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Patchy F 4SM Chc R <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hour 7-12&nbsp;&nbsp; Sct&nbsp; RW </p>
<p>&nbsp; Phrase: <br>
CHANCE OF LIGHT RAIN AND PATCHY FOG THEN SCATTERED RAIN SHOWERS IN THE
AFTERNOON. </p>
<p>You can set the&nbsp; <i><font color="#993366">visibility_wx_threshold</font></i>&nbsp;
so that weather is only reported if visibility is below the
threshold.&nbsp;&nbsp; Also, in this case you might want to set up a
list of <i><font color="#993366">significant_wx_visibility_subkeys.&nbsp;&nbsp;</font></i><font
 color="#000000"> If any of these subkeys appear in the sub-phrase, the
weather will be reported regardless of the visibility.&nbsp;</font><i><font
 color="#993366"> </font></i>Suppose we have: </p>
<p>&nbsp;<font color="#006600">&nbsp;&nbsp; def
visibility_wx_threshold(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Weather will be reported if the visibility is below</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # this
threshold (in NM) OR if it includes a</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
significant_wx_visibility_subkey (see below)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
3</font> </p>
<p><font color="#006600">&nbsp;&nbsp;&nbsp; def
significant_wx_visibility_subkeys(self, tree, node):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Weather values that constitute significant weather to</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # be
reported regardless of visibility.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If
your visibility_wx_threshold is None, you do not need</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # to
set up these subkeys since weather will always be</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
reported.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Set
of tuples of weather key search tuples in the form:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; (cov type inten)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Wildcards are permitted.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[("* T"), ("* ZY")]</font> </p>
<p>then: </p>
<p>Example 4: <br>
&nbsp; Grids: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hour 1-6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Patchy F 1/4SM Chc R 4SM <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Hour 7-12&nbsp;&nbsp; Sct&nbsp; RW </p>
<p>&nbsp; Phrase:&nbsp; CHANCE OF LIGHT RAIN AND PATCHY FOG WITH
VISIBILITY LESS THAN 1 NM IN THE MORNING. </p>
<p>Example 5: <br>
&nbsp;&nbsp; Hour 1-6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F 1/4SM&nbsp; RW
1/2SM <br>
&nbsp;&nbsp; Hour 7-12&nbsp;&nbsp; TRW </p>
<p>&nbsp; Phrase:&nbsp;&nbsp; CHANCE OF LIGHT RAIN AND PATCHY FOG WITH
VISIBILITY LESS THAN 1 NM THEN SCATTERED SHOWERS AND <br>
THUNDERSTORMS IN THE AFTERNOON. </p>
<p>Finally, there is a consolidation method (<font color="#006600">consolidateVisibility</font>
in WxPhrases).&nbsp; If the low visibility is constant across
sub-phrases, visibility is separated out into its own phrase: </p>
<p>Example 6: <br>
&nbsp;&nbsp; Hour 1-6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; F 1/4SM&nbsp; RW
1/2SM <br>
&nbsp;&nbsp; Hour 7-12&nbsp;&nbsp; TRW&nbsp; 1/4SM </p>
<p>&nbsp; Phrase:&nbsp;&nbsp; CHANCE OF LIGHT RAIN AND PATCHY FOG THEN
SCATTERED SHOWERS AND THUNDERSTORMS IN THE AFTERNOON. VISIBILITY LESS
THAN 1 NM. </p>
<p><font color="#000000">The wording for visibility within the
visibility_phrase can be configured by overriding the</font><i><font
 color="#993366"> visibility_phrase_nlValue.</font></i> <br>
</p>
<p>If you always want visibility reported in its own phrase, you can
include the <font color="#006600">visibility_phrase</font> in your
phrase list ANDmake sure to set the&nbsp; <i><font color="#993366">embedded_visibility_flag</font></i><font
 color="#000000"> to zero so that it does not appear redundantly within
the weather phrase.</font> <br>
&nbsp; </p>
<h4><a name="WEATHERKEYFILTERING"></a><font color="#000000">WEATHER
PHRASING</font></h4>
Also see sections on <br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#dominantWx">Algorithm for rankedWx
and dominantWx</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#CustomizingWeatherPhrases">Customizing
Weather Phrases</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; <a href="#PopWx_Consistency">PoP/Wx
Consistency</a><br>
&nbsp;&nbsp; &nbsp; <a href="#LocalEffectsfortheCombinedSkyPopWxPhrase">Local
Effects for the Combined SkyPopWx Phrase</a><br>
<br>
<font color="#000000">Weather phrasing in the formatters involves many
modules and logic threads as outlined in the following diagram:<br>
<br>
<img src="images/WxDesign.png" alt="Weather Phrase Design"
 style="width: 979px; height: 1181px;"><br>
<br>
Weather phrasing is complex, but centers around two primary
methods:&nbsp; "makeAggregateSubkey" (CommonUtils) and
"checkWeatherSimilarity" (PhraseBuilder).&nbsp; These methods are
ultimately employed throughout the many phases of text generation:
Analysis, Merging of grid statistics, Sub-phrase Combining, Local
Effects, Period Combining and Weather Wording.&nbsp; This ensures
consistency throughout the process and makes customizing easier.<br>
<br>
The <span style="font-weight: bold;">makeAggregateSubkey</span> method
consolidates two subkeys according to the following:<br>
</font>
<ul>
  <li><font color="#000000">coverage and intensity:&nbsp; choose
highest ranked, or if similar ranks,&nbsp; strongest</font></li>
  <li><font color="#000000">visibility: choose lowest visibility</font></li>
  <li><font color="#000000">attributes:&nbsp; make aggregate list <br>
    </font></li>
</ul>
<font color="#000000">It uses the </font><i><font color="#993366">rankFuzzFactor</font></i>
(CommonUtils) to determine if 2 ranks are similar.&nbsp; It refers to
the <i><font color="#993366">wxHierarchies </font></i>(WxPhrases) to
determine which coverage or intensity is stronger.<br>
<br>
The<span style="font-weight: bold;"> checkWeatherSimilarity</span>
method compares two rankLists i.e. lists of (subkey, rank)
tuples.&nbsp; It uses <i><font color="#993366">similarWxTypes,
similarCoverageLists </font></i><font color="#000000"> and </font><i><font
 color="#993366">similarIntensities</font></i><font color="#000000"> to
determine if subkeys are similar.&nbsp;&nbsp; To
be deemed similar, the rankLists must meet the following criteria:<br>
</font>
<ul>
  <li>Have the same number of subkeys,</li>
  <li>If there is just one subkey per rankList, the subkeys must have
the same weather type,&nbsp; similar intensities AND similar coverages,</li>
  <li>The rankLists differ only in intensity (this test is skipped if
"noIntensityCombining" is turned on for the node e.g.
severeWeather_phrase),<br>
  </li>
  <li>If there is more than one subkey per rankList, they must pass the
"checkSubkeysSimilarity" test:<br>
  </li>
  <ul>
    <li>The set of wxTypes in rankList1 is equal to the set of wxTypes
in rankList2 AND <br>
    </li>
    <li>Each wxType individually can be combined i.e. they have similar
coverages.&nbsp;&nbsp;&nbsp; <br>
    </li>
  </ul>
  <li>In the case that they can be combined, the
"checkSubkeysSimilarity" method returns an aggregate "rankList" which
it creates using "makeAggregateSubkey". <br>
  </li>
</ul>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <br>
<font color="#000000"><span style="font-weight: bold;">Analysis:</span>&nbsp;
The "rankedWx" method is used for weather phrasing and is discussed in
detail in the section </font><a href="#dominantWx">Algorithm
for rankedWx
and dominantWx</a>. Of note, here, is that the algorithm uses the
"aggregateCov_algorithm" (default is "getAggregateCov")&nbsp; to
compute an aggregate coverage,
and the "getAggregate" method to determine the aggregate
intensity,&nbsp; visibility, and attributes according to the rules of
the "makeAggregateSubkey" (CommonUtils) method.&nbsp; <br>
<font color="#000000"><br>
In the Analysis phase, we also <span style="font-weight: bold;">Filter</span>
the subkeys.&nbsp; Just as Scalar and Vector statistics are
automatically converted and rounded, weather subkeys are automatically
filtered according to the following criteria:</font>
<ul>
  <li> <font color="#000000">If the</font><font color="#660000"> </font><i><font
 color="#993366">filter_subkeys_flag</font></i><font color="#000000">
is
set to 0, no filtering is done.&nbsp; Default is 1.</font></li>
  <li><font color="#000000">Subkeys with the same weather type are
combined using the "makeAggregateSubkey" method.<br>
    </font></li>
  <li> <font color="#000000">Subkeys with differing weather types are
combined according to the </font><i><font color="#993366">wxCombinations
    </font></i><font color="#000000">list:</font></li>
</ul>
<font color="#000000">&nbsp;</font><font color="#006600">&nbsp;&nbsp;
def wxCombinations(self):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # This
is the list of which wxTypes should be combined into one.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # For
example, if ("RW", "R") appears, then wxTypes of "RW" and "R" will</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # be
combined into one key and the key with the dominant coverage will</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # be
used as the combined key.</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # You
may also specify a method which will be</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; -- given arguments subkey1 and subkey2 and</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; -- should return</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp; -- a flag = 1 if they are to be combined, 0
otherwise</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp; -- the combined key to be used</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; Note: The method will be called twice, once with (subkey1,
subkey2)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; and once with (subkey2, subkey1) so you can assume one ordering.</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp; See the example below, "combine_T_RW"</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #</font>
<br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
[</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("RW", "R"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
("SW", "S"),</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.combine_T_RW,</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
]</font>
<p><font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp; def
combine_T_RW(self, subkey1, subkey2):</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #
Combine T and RW only if the coverage of T</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # is
dominant over the coverage of RW</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wxType1 = subkey1.wxType()</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
wxType2 = subkey2.wxType()</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
wxType1 == "T" and wxType2 == "RW":</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
order = self.dominantCoverageOrder(subkey1, subkey2)</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if order == -1:</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return 1, subkey1</font> <br>
<font color="#006600">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return
0, None</font> <br>
&nbsp; </p>
<font color="#000000">All weather filtering variables are located in
the WxPhrases module and can be overridden by copying them into your
Overrides file.</font> <br>
<br>
<span style="font-weight: bold;">Merging of statistics </span>occurs
when a tree.stats.get command requests statistics for a time period
spanning more than one in the Statistics Dictionary.&nbsp; For example,
if we request Wx statistics with a 3-hour temporal resolution and
request the statistics for a 6-hour period, we must merge the 3-hour
statistics.&nbsp; Again, we must filter&nbsp; subkeys and ultimately
employ&nbsp; the "makeAggregateSubkey" method.<br>
<br>
<span style="font-weight: bold;">Sub-phrase Combining.&nbsp; </span>There
are various weather phrases for which we must combine
sub-phrases.&nbsp; The "skyPopWx_phrase" is used for simpler cases in
which the resulting phrase only requires 1 or 2 sub-phrases.&nbsp; For
more complex scenarios, the "weather_phrase" is triggered.&nbsp; The
"severeWeather_phrase" and "heavyPrecip_phrase" are special cases, but
use the same combining scheme to determine the appropriate sub-phrasing.<br>
<ul>
  <li>"weather_phrase", "severeWeather_phrase", "heavyPrecip_phrase"
rely on the "preProcessWx" method to combine the weather types found in
the time period of interest.&nbsp; This method uses the
"checkWeatherSimilarity" method to determine if subkeys can be combined
and the "makeAggregateSubkey" method to create new subkeys for the
resulting sub-phrases.&nbsp; Subkeys are put into sub-phrases with
others of the same time span within the time period.&nbsp; This method
looks at all the subkeys for all sub-phrases at one time.&nbsp; For
example, if you had <br>
  </li>
  <ul>
    <li>Hours 1-3: Wide R, SChc S</li>
    <li>Hours 4-6: SChc S</li>
    <li>Hours 7-12: SChc S Lkly ZR</li>
  </ul>
</ul>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; you would
end up with<br>
<ul>
  <ul>
    <li>SubPhrase 1: Hours 1-3:&nbsp; Wide R</li>
    <li>SubPhrase 2: Hours 1-12: SChc S</li>
    <li>SubPhrase 3: Hours 7-12: Lkly ZR</li>
  </ul>
</ul>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and
wording:&nbsp; "Widespread rain in the early morning.&nbsp; Slight
chance of snow through the day.&nbsp; Freezing rain likely in the
afternoon."<br>
<ul>
  <li>"skyPopWx_phrase": This phrase is used only for the simpler case
of 1 or 2 resulting sub-phrases.&nbsp; Thus, we use the simpler
sub-phrase by sub-phrase combining method, "combineStats" which also
employs the "checkWeatherSimilarity" and "makeAggregateSubkey"
methods.&nbsp;&nbsp; The sub-phrase by sub-phrase combining allows us
to have phrases such as: "Rain and snow in the morning then snow in the
afternoon."&nbsp; instead of "Rain in the morning.&nbsp; Snow through
the day."</li>
</ul>
<span style="font-weight: bold;">Local Effects.&nbsp; </span>For
consistency, local effects for the weather phrases uses the same
underlying "checkWeatherSimilarity" method.&nbsp;&nbsp; Local effects
for the weather_phrase will use the general
"checkLocalEffectDifference" (PhraseBuilder) method which in turn calls
"checkWeatherSimilarity".&nbsp; For information on setting up local
effects for the "skyPopWx_phrase", see the section: <a
 href="#LocalEffectsfortheCombinedSkyPopWxPhrase">Local
Effects for the Combined SkyPopWx Phrase.</a><br>
<span style="font-weight: bold;"><br>
Period Combining.&nbsp;&nbsp; </span>If you choose to examine Wx&nbsp;
similarities as a basis for period combining, the "similarWx" method
will call "checkWeatherSimilarity" for it's comparison of Wx across
periods.<br>
<span style="font-weight: bold;"><br>
Weather Words.&nbsp;&nbsp; </span>The words for each weather
sub-phrase are created by the following steps:<br>
<ul>
  <li><font color="#000000">If the PoP is below the </font><i><font
 color="#993366">pop_wx_lower_threshold,&nbsp;&nbsp; pop_related_wxTypes</font></i><font
 color="#000000"> are removed.</font></li>
  <li><font color="#000000">Check for weather wording dependent on the
visibility threshold.&nbsp; See section: </font><a
 href="#HANDLINGVISIBILITY">Visibility</a></li>
  <li>If <i><font color="#993366">useSimple&nbsp; </font></i>(default
is 2 or fewer subkeys),&nbsp; use old-style simpler wording i.e. do not
use "mixed with", "pockets of", etc.&nbsp; Examples of Simple wording:
"Rain and snow likely in the evening." "Chance of rain and snow and
slight chance of sleet in the evening." "Chance of showers." "Mostly
cloudy with rain likely and a slight chance of
thunderstorms."&nbsp;&nbsp; Example of&nbsp; Complex wording: "Rain
mixed with snow likely in the evening." "Chance of rain mixed with snow
and sleet in the evening."</li>
  <li>Otherwise, use ranking of subkeys to form wording:</li>
  <ul>
    <li>For subkeys with similar rank and coverages, use "mixed with"
wording .</li>
    <li>For subkeys with lesser coverage than the highest ranked, use
"possibly mixed with".</li>
    <li>For subkeys with greater coverage than the highest ranked, use
"with pockets of"</li>
  </ul>
</ul>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Only switch once
to "mixed with", "possibly mixed with" or "with pockets of".&nbsp; The <i><font
 color="#993366">rankFuzzFactor</font></i> (CommonUtils) is used to
determine if ranks are similar and&nbsp;&nbsp; the <i><font
 color="#993366">similarCoverages&nbsp;</font></i> method is used to
determine if coverages are similar.&nbsp; The wording can be adjusted
for <i><font color="#993366">mixedWith, possiblyMixedWith,
withPocketsOf&nbsp; </font></i>and<i><font color="#993366">
wxConjunction.<br>
</font></i>
<ul>
  <li>The "weather_value" method constructs the words for each
subkey.&nbsp; This wording can be adjusted and is described in the
section: <a href="#CustomizingWeatherPhrases">Customizing
Weather Phrases.</a></li>
  <li>Add embedded visibility wording if needed.</li>
</ul>
<br>
<br>
<h1><a name="Appendix_A"></a>Appendix A</h1>
<h2>Local Effects Re-design/Design to Handle Combined Phrases<br>
</h2>
<h2>Phrase Processing Steps including Local Effects</h2>
<ul>
  <li><span style="font-weight: bold;">CONSOLIDATE</span> --<span
 style="font-weight: bold;">Phrase Level</span>:
e.g. separateNonPrecip (separate out non-precip events such as Fog from
RW), consolidateWx (if RW appears throughout the period and S is just
in the afternoon, split them into separate phrases), consolidatePhrase
(if Gusts are the same throughout the period and the Wind changes,
split them into separate phrases).</li>
  <li><span style="font-weight: bold;">CHECK FOR LOCAL EFFECTS </span>--<span
 style="font-weight: bold;"> Phrase Level</span>:&nbsp; If local
effects are triggered, create separate Conjunctive phrases for each
local effect area (or group of areas). <br>
  </li>
  <li><span style="font-weight: bold;">COMBINE </span>-- <span
 style="font-weight: bold;">Phrase Level</span>:&nbsp; Combine
sub-phrases based on similar data.</li>
  <li><span style="font-weight: bold;">CREATE WORDS</span> -- <span
 style="font-weight: bold;">Sub-phrase Level</span>: Create words for
each sub-phrase.</li>
  <li><span style="font-weight: bold;">CONSOLIDATE SUB-PHRASES --
Component Level</span>:
Consolidate so that we do not have duplicate phrasing within local
effect areas.&nbsp; <br>
  </li>
  <li><span style="font-weight: bold;">ASSEMBLE SUB-PHRASES -- Phrase
Level</span>. <br>
  </li>
  <li><span style="font-weight: bold;">ASSEMBLE PHRASES -- Component
Level</span>: <br>
  </li>
  <ul>
    <li>Order Wx Phrases <br>
    </li>
    <li>Consolidate Local Effect Phrases</li>
    <ul>
      <li>Incorporate Non Local Effect phrases (not implemented) OR</li>
      <li>Convert to Embedded phrases if possible</li>
      <li>Order Local Effect phrases that remain Conjunctive</li>
    </ul>
    <li>Assemble Component Words with appropriate qualifiers<br>
    </li>
  </ul>
</ul>
<h2>Examples of Phrase Processing Steps</h2>
The following examples show the progression through the phrase
processing steps.&nbsp; They are rough sketches, not intended to be
complete. They use these abbreviations:<br>
<ul>
  <li>Area1 is the entire area while WW (Windward)&nbsp; and LW
(Leeward) are local effect areas.</li>
  <li>SPW = skyPopWx_phrase</li>
  <li>Wx = weather_phrase</li>
  <li>PoP = popMax_phrase</li>
  <li>Sky = sky_phrase</li>
  <li>&gt;&gt; Means "executes"<br>
  </li>
  <li>--&gt; Means "results in"</li>
</ul>
<h3>Test Case 3_3 F20 <br>
</h3>
Grids:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Area1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; Iso T (hours 0-6)&nbsp; Chc R Lkly S&nbsp;&nbsp;&nbsp; Sky
90&nbsp; (hours 0-12)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(The Wx is the result when we sample the combined Windward and Leeward
values).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Windward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iso T (hours
0-6)&nbsp;&nbsp; Lkly R Lkly S&nbsp; PoP 90&nbsp;&nbsp;&nbsp; Sky
90&nbsp; (hours 0-12)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Leeward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Iso T (hours 0-6)&nbsp;&nbsp; Chc
R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
PoP 40&nbsp;&nbsp;&nbsp; Sky 90&nbsp; (hours 0-12)<br>
<br>
Words:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ISOLATED THUNDERSTORMS IN THE
MORNING.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RAIN AND SNOW LIKELY WINDWARD...A
40 PERCENT CHANCE OF RAIN LEEWARD<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...CHANCE OF PRECIPITATION 70
PERCENT WINDWARD.<br>
<br>
Note:&nbsp; The PoP is reported separately for WW because it is greater
than 60.<br>
<br>
Steps:<br>
<ul>
  <li>Sky Phrase &gt;&gt; includeSky == 0 since same throughout, so
kept phrase &gt;&gt; empty words since PoP &gt; 60<br>
  </li>
  <li>SPW Area1&nbsp; &gt;&gt; Consolidation --&gt; <br>
  </li>
  <ul>
    <li>&nbsp;SPW Area1 for Chc R Lkly S&nbsp; &gt;&gt;
CheckLocalEffects --&gt;</li>
    <ul>
      <li>SPW WW for Lkly R Lkly S --&gt; RAIN AND SNOW LIKELY WINDWARD</li>
      <li>SPW LW for Chc R --&gt; A 40 PERCENT CHANCE OF RAIN LEEWARD</li>
    </ul>
    <li>SPW&nbsp; Area1 for Iso T &gt;&gt; CheckLocalEffects --&gt;
ISOLATED THUNDERSTORMS IN THE MORNING.<br>
    </li>
  </ul>
  <li>Wx Area1 &gt;&gt; Consolidation (preProcessWx rearranges
sub-phrases) &gt;&gt; CheckLocalEffects --&gt;</li>
  <ul>
    <li>Wx WW &gt;&gt; removed by SPW Windward Lkly R Lkly S</li>
    <li>Wx LW &gt;&gt; removed by SPW Leeward Chc R</li>
  </ul>
  <li>Pop Area1 &gt;&gt; Removed by SPW Windward and Leeward <br>
  </li>
</ul>
<h3>Test Case 3_3 F6&nbsp; <br>
</h3>
Grids:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Area1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Windward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sct RW&nbsp;
Sky 70 &nbsp; PoP 50<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Leeward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NoWx&nbsp;&nbsp;&nbsp;&nbsp; Sky 20&nbsp;&nbsp; PoP&nbsp;&nbsp; 0<br>
<br>
Words:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUNNY LEEWARD...MOSTLY CLOUDY WITH
SCATTERED SHOWERS WINDWARD...CHANCE OF SHOWERS 50 PERCENT WINDWARD<br>
Steps:<br>
<ul>
  <li>Sky Area1 &gt;&gt; CheckLocalEffects --&gt;</li>
  <ul>
    <li>Sky WW --&gt; Removed by SPW for WW<br>
    </li>
    <li>Sky LW --&gt; SUNNY<br>
    </li>
  </ul>
  <li>SPW Area1&nbsp; &gt;&gt; Consolidation&nbsp; &gt;&gt;
CheckLocalEffects --&gt;<br>
  </li>
  <ul>
    <li>SPW WW --&gt; MOSTLY CLOUDY WITH SCATTERED SHOWERS<br>
    </li>
    <li>SPW LW&nbsp;&nbsp; -- Removed because there is NoWx<br>
    </li>
  </ul>
  <li>Wx Area1 &gt;&gt; CheckLocalEffects --&gt;</li>
  <ul>
    <li>Wx WW --&gt; removed by SPW WW --&gt; <br>
    </li>
    <li>Wx LW --&gt; empty<br>
    </li>
  </ul>
  <li>Pop Area1 &gt;&gt; CheckLocalEffects --&gt;</li>
  <ul>
    <li>Pop WW --&gt; CHANCE OF SHOWERS 50 PERCENT</li>
    <li>Pop LW --&gt; empty<br>
    </li>
  </ul>
</ul>
<h3>Test Case 3_3 F30&nbsp; Sub-phrase consolidation Case 1<br>
</h3>
This is an example in which we need the Consolidate Sub-phrases step.<br>
Case 1: duplicate sub-phrases are for the same areaLabel.<br>
<br>
Grids:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Area1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Windward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (hours 9-12) Wx:
Patchy:F&nbsp; PoP 20&nbsp; Sky 50<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Leeward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(hours 9-12) Wx: Wide:F&nbsp;&nbsp;&nbsp; PoP 0&nbsp;&nbsp;&nbsp; Sky 50<br>
<br>
Words:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOSTLY SUNNY. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WINDWARD...PATCHY FOG LATE IN THE
AFTERNOON. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEEWARD...WIDESPREAD FOG LATE IN
THE AFTERNOON.<br>
<br>
<ul>
  <li>Sky Area1 --&gt; MOSTLY SUNNY.<br>
  </li>
  <li>SPW Area1&nbsp; &gt;&gt; Consolidation --&gt;<br>
  </li>
  <ul>
    <li>Spawned Wx Area1 (F) --&gt; Consolidation --&gt;
CheckLocalEffects --&gt;</li>
    <ul>
      <li>Wx WW&nbsp; Patchy F</li>
      <li>Wx Leeward Widespread F<br>
      </li>
    </ul>
  </ul>
  <li>Wx Area1 &gt;&gt; CheckLocalEffects --&gt;</li>
  <ul>
    <li>Wx WW --&gt; Patchy F<br>
    </li>
    <li>Wx LW --&gt; Widespread F<br>
    </li>
  </ul>
  <li>Pop Area1 &gt;&gt; No PoP reported.<br>
  </li>
</ul>
<ul>
  <li>&gt;&gt; All these subPhrases are processed by
ConsolidateSubPhrases which finds Case 1:</li>
  <ul>
    <li>Wx WW &nbsp; Patchy F</li>
    <li>Wx WW&nbsp;&nbsp; Patchy F</li>
    <li>Wx LW&nbsp; Widespread F</li>
    <li>Wx LW&nbsp; Widespread F</li>
  </ul>
  <li>After Consolidating Sub-Phrases: --&gt;</li>
  <ul>
    <li>Wx WW&nbsp;&nbsp; Patchy F</li>
    <li>Wx LW&nbsp;&nbsp;&nbsp; Widespread F</li>
  </ul>
</ul>
<h3 style="font-weight: bold;">Test Case 3_3 F22&nbsp; Sub-phrase
consolidation Case 2</h3>
This is an example in which we need the Consolidate Sub-phrases step.<br>
Case 2:&nbsp; duplicate subphrases are for a local effect and cover all
possible local effect areas for their phrase, create a new phrase for
component.getAreaLabel() with this subPhrase wording. Remove the local
effect subPhrases.<br>
<br>
Grids:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Area1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Windward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Chc T (hours
0-6)&nbsp;&nbsp; Lkly RW&nbsp;&nbsp;&nbsp; PoP 70<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Leeward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Chc T (houts 0-6)&nbsp;&nbsp; Chc RW&nbsp;&nbsp;&nbsp;&nbsp; PoP 40<br>
<br>
Words:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOUDY.&nbsp; CHANCE OF
THUNDERSTORMS IN THE MORNING.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WINDWARD...SHOWERS LIKELY...CHANCE
OF SHOWERS AND THUNDERSTORMS 70 PERCENT.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LEEWARD...CHANCE OF SHOWERS IN THE
AFTERNOON...CHANCE OF SHOWERS AND THUNDERSTORMS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40 PERCENT.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
Steps:<br>
<ul>
  <li>Sky Area1 --&gt; CLOUDY.<br>
  </li>
  <li>SPW Area1&nbsp; &gt;&gt; Consolidation (Chc T is not the same
throughout period) &gt;&gt; CheckLocalEffects --&gt;<br>
  </li>
  <ul>
    <li>SPW WW &gt;&gt; Consolidation --&gt; <br>
    </li>
    <ul>
      <li>SPW WW for Chc T --&gt; CHANCE OF THUNDERSTORMS IN THE MORNING</li>
      <li>SPW WW for Lkly RW --&gt; SHOWERS LIKELY</li>
    </ul>
    <li>SPW LW &gt;&gt; Consolidation --&gt; <br>
    </li>
    <ul>
      <li>SPW LW for Chc T --&gt; CHANCE OF THUNDERSTORMS IN THE MORNING</li>
      <li>SPW LW for Chc RW --&gt; CHANCE OF SHOWERS IN THE AFTERNOON</li>
    </ul>
  </ul>
  <li>Wx Area1 &gt;&gt; CheckLocalEffects --&gt;</li>
  <ul>
    <li>Wx WW --&gt; removed by SPW WW<br>
    </li>
    <li>Wx LW --&gt; removed by SPW LW<br>
    </li>
  </ul>
  <li>Pop Area1 &gt;&gt; CheckLocalEffects --&gt;</li>
  <ul>
    <li>Pop WW --&gt; CHANCE OF SHOWERS AND THUNDERSTORMS 70 PERCENT</li>
    <li>Pop LW --&gt; CHANCE OF SHOWERS AND THUNDERSTORMS 40 PERCENT</li>
  </ul>
</ul>
<ul>
  <li>&gt;&gt; All these subPhrases are processed by
ConsolidateSubPhrases which finds Case 2:</li>
  <ul>
    <li>SPW WW&nbsp;&nbsp; CHANCE OF THUNDERSTORMS</li>
    <li>SPW LW&nbsp;&nbsp;&nbsp; CHANCE OF THUNDERSTORMS</li>
  </ul>
  <li>After Consolidating Sub-Phrases: --&gt;</li>
  <ul>
    <li>SPW Area1 Chc T --&gt; CHANCE OF THUNDERSTORMS IN THE MORNING</li>
    <li><br>
    </li>
    <li>SPW WW for Lkly RW --&gt; SHOWERS LIKELY</li>
    <li>SPW LW for Chc RW --&gt; CHANCE OF SHOWERS IN THE AFTERNOON</li>
  </ul>
</ul>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note:&nbsp; The leeward showers
are "in the afternoon" because T and RW are combined if their<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the coverage of T is greater or
equal to that of RW.<br>
<h3>Test Case 3_3 F45 Need checkSkyPopWx to remove pop phrases for
component as well as local effect area.</h3>
Grids:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Windward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sky:
Cloudy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SChc S &nbsp;&nbsp; PoP 20<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Leeward:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Sky: Partly Sunny Chc R &nbsp;&nbsp;&nbsp;&nbsp; PoP 30<br>
<br>
Words:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOUDY WITH A 20 PERCENT CHANCE OF SNOW
WINDWARD...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARTLY SUNNY WITH A 30 PERCENT CHANCE OF
RAIN LEEWARD <br>
<br>
(No extra PoP phrase)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
Steps:<br>
<ul>
  <li>Sky &gt;&gt; CheckLocalEffects --&gt;</li>
  <ul>
    <li>Sky Windward &gt;&gt; removed by SPW Windward<br>
    </li>
    <li>Sky Leeward &gt;&gt; removed by SPW Leeward<br>
    </li>
  </ul>
  <li>SPW Area1&nbsp; &gt;&gt; CheckLocalEffects --&gt; </li>
  <ul>
    <li>SPW Windward&nbsp; &gt;&gt; CLOUDY WITH A 20 PERCENT CHANCE OF
SNOW WINDWARD... </li>
    <li>SPW Leeward&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&gt; PARTLY SUNNY
WITH A 30 PERCENT CHANCE OF RAIN LEEWARD </li>
  </ul>
  <li>Wx Area1 &gt;&gt; CheckLocalEffects --&gt;</li>
  <ul>
    <li>Wx Windward &gt;&gt; removed by SPW Windward <br>
    </li>
    <li>Wx Leeward &gt;&gt; removed by SPW Leeward<br>
    </li>
  </ul>
  <li>PoP Area1 &gt;&gt; removed by SPW Windward and/or Leeward (which
removes both the LE area and Area1).&nbsp; This works because there is
never a case where you have a local effect PoP reported AND you also
want an Area1 PoP reported.<br>
  </li>
</ul>
<h3></h3>
<h2>Design Changes Made from Original Local Effect Strategy to New</h2>
Basically, we were trying to do too much upstream,&nbsp; making
assumptions
that were ok for simple 1-dimensional phrases, but did not hold for
multi-element phrases. Now we have moved much of the decision-making
downstream when we know more about the outcome.<br>
<ul>
  <li><span style="font-weight: bold;">"checkLocalEffects"
method:&nbsp; </span>Change: "checkLocalEffects" must run after
spawning new phrases.&nbsp;
We cannot assume that "checkLocalEffects" runs as the first phrase
method. With phrases that might split into multiple phrases, we need to
check for local effects AFTER phrases have been split, say, into
separate sky and weather phrases or separate wind and wind gust
phrases. <br>
  </li>
  <ul>
    <li>"checkLocalEffects" was automatically added as the first
phraseList method by ForecastNarrative.</li>
    <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 153, 0);">Now Phrase Definitions must&nbsp; list
"checkLocalEffects" explicitly.&nbsp; </span><br>
      </span></li>
    <ul>
      <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 153, 0);">"standard_phraseMethods"</span>&nbsp;<span
 style="color: rgb(51, 0, 51);"> (PhraseBuilder)</span><br>
        </span></li>
      <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 153, 0);">"standard_vector_phraseMethods" </span><span
 style="color: rgb(51, 0, 51);">(VectorRelatedPhrases)</span><br>
        </span></li>
      <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 153, 0);">"standard_weather_phraseMethods</span><span
 style="color: rgb(51, 0, 51);"><span style="color: rgb(0, 153, 0);">" </span>(WxPhrases)</span><br>
        </span></li>
      <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 153, 0);">"skyPopWx_phrase"</span> <span
 style="color: rgb(51, 0, 51);">(CombinedPhrases)</span><br>
        </span></li>
      <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 153, 0);">"sky_phrase"</span><span
 style="color: rgb(51, 0, 51);"> (ScalarPhrases)</span></span></li>
      <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(0, 153, 0);">"fireSky_phrase",
"trend_DayOrNight_phrase", "dayOrNight_phrase", "haines_phrase",
"lal_phrase"</span> </span>(FirePhrases)<br>
        </span></span></li>
    </ul>
    <li>Must carry over "localEffects" information when spawning new
phrases in <span style="color: rgb(0, 153, 0);">"splitPhrase" <span
 style="color: rgb(51, 0, 51);">and </span>"splitWxPhrases"</span>
(PhraseBuilder)</li>
    <li>Must apply "disabledSubkeys" when checking local effects in <span
 style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 153, 0);">"checkThreshold",
"checkSkyWxDifference"</span><span style="color: rgb(51, 0, 51);"><span
 style="color: rgb(0, 153, 0);"> </span>(PhraseBuilder)</span></span><br>
    </li>
  </ul>
  <li><span style="font-weight: bold;">All local effects start out as
conjunctive. </span>Change: Make all local effects conjunctive when
created then after all processing is done, convert to embedded if
appropriate.<span style="font-weight: bold;"> </span>(<span
 style="color: rgb(0, 153, 0);">"checkLocalEffects"</span> in
PhraseBuilder and <span style="color: rgb(0, 153, 0);">"makeLocalEffectNodes"</span>)
We used to try and determine if a phrase could be embedded at the
beginning of processing when we first discovered there was a local
effect.&nbsp; Later, we would find that some of the conjunctive phrases
degenerated and could be turned into embedded.&nbsp; <br>
  </li>
  <ul>
    <li><span style="color: rgb(0, 153, 0);">"localEffect_hook"</span>
used to try and decide which phrases could be eliminated. When SPW
became more complex, this job was not possible and caused duplicate and
missing phrases.&nbsp; Now we generate them all and remove duplicate
information:</li>
    <ul>
      <li>In the <span style="color: rgb(0, 153, 0);">"checkSkyPopWx"</span>
method</li>
      <li>Through consolidation in the Consolidate Sub Phrases step.</li>
    </ul>
  </ul>
  <li><span style="font-weight: bold;">Create subPhrase words.</span>&nbsp;
Proceed as normal to create subPhrase words for local effect and other
subPhrases.</li>
  <li><span style="font-weight: bold;">Consolidate SubPhrases</span>:
&nbsp; At product Component Level: <br>
  </li>
</ul>
<div style="margin-left: 80px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
##&nbsp; Timing: This method runs at the component level<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp; AFTER all
sub-phrase words have been set and<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp; BEFORE they have
been assembled into phrases at the phrase level.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp; Purpose: If for all
possible areaLabels per phrase or phrase type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
##&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; we repeat a particular
subPhrase and timeRange,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
##&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Factor it out into an un-qualified
phrase<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp; For example:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp;&nbsp;&nbsp; Chance
of thunderstorms in the morning (windward)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp;&nbsp;&nbsp; Chance
of thunderstorms in the morning (leeward)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp;&nbsp;&nbsp; Chance
of rain in the afternoon (windward)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp;&nbsp;&nbsp; Chance
of snow in the afternoon (leeward)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp; becomes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp;&nbsp;&nbsp; Chance
of thunderstorms in the morning (unqualified)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp;&nbsp;&nbsp; Chance
of rain in the afternoon (windward)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ##&nbsp;&nbsp;&nbsp; Chance
of snow in the afternoon (leeward)<br>
</div>
<ul>
  <ul>
    <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(255, 0, 0);">All Product components must list
"consolidateSubPhrases"</span> <span style="color: rgb(0, 153, 0);"><span
 style="color: rgb(51, 0, 51);">before </span>"assemblePhrases" <span
 style="color: rgb(51, 0, 51);">or</span>
"assembleIndentedPhrases"</span></span></li>
    <ul>
      <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);">In all</span> <span
 style="color: rgb(51, 0, 51);">Narrative Standard products</span></span></li>
      <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);">In FirePhrases compound phrases:&nbsp; <span
 style="color: rgb(0, 153, 0);">"skyWeather_byTimeRange_compoundPhrase",
"fireWind_compoundPhrase", "fireValleyWind_compoundPhrase",
"fireRidgeWind_compoundPhrase"</span></span></span></li>
      <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);">In FWS_Overrides:</span>&nbsp;<span
 style="color: rgb(0, 153, 0);"> "fireEyeWind_compoundPhrase"</span><br>
        </span></span></span></li>
    </ul>
  </ul>
</ul>
<ul>
  <ul>
    <li>Because consolidateSubPhrases waits until all subPhrases are
finished AND executes
before assembleSubPhrases (and assemblePhrases),&nbsp; phrases can no
longer
wait for other phrases to completely finish.&nbsp; They can, however,
wait
for all subphrases to finish.&nbsp; Thus, "findWords" (PhraseBuilder)
now
just returns concatenated subPhrases instead of concatenated completed
phrases.&nbsp; All methods should use "findWords" rather than waiting
for phrases to complete.&nbsp;&nbsp; <br>
    </li>
  </ul>
  <ul>
    <ul style="color: rgb(0, 153, 0);">
      <li>"extremeTemps_words" <span style="color: rgb(51, 0, 51);">must
be changed to use</span> "findWords" OR <span
 style="color: rgb(51, 0, 51);">the system will give </span>"21
PASSES" <span style="color: rgb(51, 0, 51);">message since it is
waiting for the
reportTrends_phrase to finish.</span></li>
    </ul>
    <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);">Enhanced <span
 style="color: rgb(0, 153, 0);">"checkRepeatingString"</span>
(PhraseBuilder) to handle local effect situations.</span><br>
      </span></li>
  </ul>
  <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);"><span style="font-weight: bold;">Assemble
Sub Phrases</span>:&nbsp; <span style="color: rgb(0, 153, 0);">"assembleSubPhrases"</span>
(PhraseBuilder)&nbsp; now needs consolidateSubPhrases_trigger to make
sure
that subPhrases have been consolidated before we assemble them.</span></span></li>
  <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);"><span style="font-weight: bold;">Assemble
Phrases</span>:<span style="color: rgb(0, 153, 0);"> </span><span
 style="color: rgb(255, 0, 0);"><span style="color: rgb(0, 153, 0);">"assemblePhrases",
"assembleIndentedPhrases", "assembleSentences":</span><span
 style="color: rgb(51, 0, 51);"><span style="color: rgb(0, 153, 0);"> </span><br>
    </span></span></span></span></li>
  <ul>
    <li><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);"><span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);"><span style="font-weight: bold;">Consolidate
Local Effects</span>:&nbsp; Replace "combineConjunctiveLocalEffects"
with
"consolidateLocalEffects"</span></span>.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <br>
      </span></span></li>
  </ul>
</ul>
<span style="color: rgb(255, 0, 0);"><span
 style="color: rgb(51, 0, 51);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; # Organize the local effect and non-local
effect phrases.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; # "node" can be a
component or a compound phrase.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; # Convert to embedded
local effect phrases if appropriate.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; # Apply the
Local Effect thresholds:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp; repeatingEmbedded_localEffect_threshold<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp; repeatingPhrase_localEffect_threshold<br>
<br>
</span></span>
<ul style="margin-left: 80px;">
  <li>Calls "incorporateNonLocalEffectPhrases":<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; Try to incorporate
non-qualified phrases<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; If there
is exactly one leArea group in the set of phrases<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND this group is composed of intersect
areas<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND there is more than one local effect
phrase<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND the number of non-local effect
phrases<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;
repeatingPhrase_localEffect_threshold:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Convert them to
conjunctive local effect phrases<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (one for each
intersect local effect area)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; Else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; EXAMPLE:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; Instead of:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Chance of thunderstorms in the morning.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Windward...Cloudy...Rain likely...Chance of precipitation 70 percent.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Leeward...Partly cloudy...Scattered showers...Chance of precipitation 30<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
percent. Highs in the 40s.&nbsp; Winds 20 mph.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; We will
produce:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Windward...Cloudy....Rain likely...Chance of thunderstorms in the
morning...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Chance of precipitation 70 percent.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Leeward...Partly cloudy...Scattered showers...Chance of thunderstorms in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
the morning...Chance of precipitation 30 percent. Highs in the 40s.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Winds 20 mph.</li>
  <br>
  <li>If cannot incorporate, then calls&nbsp;
"convertToEmbedded":&nbsp; (updated <span
 style="color: rgb(0, 153, 0);">"makeEmbeddedFromConjunctive"</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; Converts
conjunctive local effects to embedded if possible.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; For each
leGroup:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If number of possible embedded phrases<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt; repeatingEmbedded_localEffect_threshold<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND there are NO
mandatory conjunctives:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Replace conjunctive phrases with embedded phrase(s).</li>
</ul>
<ul style="margin-left: 80px;">
  <li>Finally, calls<span style="color: rgb(0, 153, 0);">
"orderLocalEffectPhrases"</span>:&nbsp; See Test Cases F8, F14, F15,
F16, F22, F37, F38, F46<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; Group all
conjunctive local effect phrases<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for each local effect area together<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (at the location of the first
occurrence).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; EXAMPLE:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
LEEWARD...SUNNY IN THE MORNING THEN BECOMING PARTLY SUNNY...SCATTERED
SHOWERS.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
WINDWARD...MOSTLY CLOUDY WITH SCATTERED SHOWERS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; instead of:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
LEEWARD...SUNNY IN THE MORNING THEN BECOMING PARTLY SUNNY.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
WINDWARD...MOSTLY CLOUDY WITH SCATTERED SHOWERS.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
LEEWARD...SCATTERED SHOWERS. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#&nbsp;&nbsp;</li>
</ul>
<ul>
  <ul>
    <li><span style="font-weight: bold;">Qualify conjunctive local
effect phrases</span>:&nbsp; Modified<span
 style="color: rgb(0, 153, 0);"> "qualifyWords"</span>
to handle local effect qualifiers in this new design and to remove some
bugs from previous design.&nbsp; Added "addPeriod" argument to <span
 style="color: rgb(0, 153, 0);">"sentence"</span> (StringUtils) and
removal of extra space from <span style="color: rgb(0, 153, 0);">"combineSentences"</span>
(StringUtils).</li>
  </ul>
</ul>
<ul>
  <li>&nbsp;&nbsp;<span style="font-weight: bold;"> New ConfigVariables:</span>
  </li>
</ul>
<div style="margin-left: 80px;">&nbsp;&nbsp;&nbsp; #### Component-Level
Local Effect thresholds<br>
&nbsp;&nbsp;&nbsp; def repeatingEmbedded_localEffect_threshold(self,
tree, component):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Number of embedded local
effect phrases allowed in a component<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # before they are gathered
together into a conjunctive local<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # effect clause.&nbsp; For
example, with the threshold set to 2:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Instead of:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Cloudy windward and partly cloudy leeward.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Rain likely windward and scattered showers leeward.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Chance of precipitation 50 percent windward and 30<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
percent leeward.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # We will produce:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Windward...Cloudy...Rain likely...Chance of precipitation 50 percent.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Leeward...Partly cloudy...Scattered showers...Chance of precipitation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp; 30
percent.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # NOTE:&nbsp; If we have
even one conjunctive local effect, however, all will be left<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
conjunctive.&nbsp; For example, instead of:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Cloudy windward and partly cloudy leeward.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Windward...Rain likely in the morning.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Leeward...Scattered showers in the afternoon.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp; We will produce:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Windward...Cloudy...Rain likely in the morning.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;
Leeward...Partly cloudy...Scattered showers in the afternoon.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2<br>
<br>
&nbsp;&nbsp;&nbsp; def repeatingPhrase_localEffect_threshold(self,
tree, component):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Number of repeating local
effect phrases allowed inside a<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # set of conjunctive local
effects for each of the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # repeatingPhrase_categories
(see below).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # For example, with the
default of 1 and the categories below,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Instead of:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; Chance
of thunderstorms in the morning.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;
Windward...Cloudy...Rain likely...Chance of precipitation 70 percent.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;
Leeward...Partly cloudy...Scattered showers...Chance of precipitation 30<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; percent.
Highs in the 40s.&nbsp; Winds 20 mph.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # We will produce:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;
Windward...Cloudy....Rain likely...Chance of thunderstorms in the
morning...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; Chance
of precipitation 70 percent.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;
Leeward...Partly cloudy...Scattered showers...Chance of thunderstorms in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; the
morning...Chance of precipitation 30 percent. Highs in the 40s.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; Winds 20
mph.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Note that if we had:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;
Windward...Cloudy....Rain likely...Chance of precipitation 70 percent.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;
Leeward...Partly cloudy...Scattered showers......Chance of precipitation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; 30
percent. Highs in the 40s. Winds 20 mph.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # The phrasing would remain
unchanged since there are 2 phrases (Temps and Winds)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # in the "ALL OTHER PHRASES"
category that would have to be repeated within the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # conjunctive local effects.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; def repeatingPhrase_localEffect_categories(self,
tree, component):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
["skyPopWx_phrase", "sky_phrase", "weather_phrase", "popMax_phrase"],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
["ALL OTHER PHRASES"],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]<br>
<br>
&nbsp;&nbsp;&nbsp; def lePhraseNameGroups(self, tree, component):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Groups of phrase names
that can be combined into embedded local effect phrases.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # If the phrase is not
listed here, it is assumed that only phrases with the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # same name can be combined
with it into an embedded local effect phrase.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # For example:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; With the
group:&nbsp; ("skyPopWx_phrase", "weather_phrase"), we will allow:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; A 20 percent
chance of rain windward and areas of fog leeward.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; Since
"skyPopWx_phrase" and "wind_phrase" do not appear as group, we will<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; not allow:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; A 20
percent chance of rain windward and north winds 20 mph leeward.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [("skyPopWx_phrase",
"weather_phrase")]<br>
<br>
</div>
<br>
</body>
</html>
