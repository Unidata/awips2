<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
<TITLE> Online Numerical Python Documentation </TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<H1 CLASS="TitleBook">
<A NAME="pgfId-90250"></A>&nbsp;</H1>
</DIV>
<DIV>
<H1 CLASS="TitleBook">
<A NAME="pgfId-93934"></A>Numerical Python</H1>
<P CLASS="AuthorBook">
<A NAME="pgfId-80697"></A>David Ascher<BR>
Paul F. Dubois<BR>
Konrad Hinsen<BR>
Jim Hugunin<BR>
Travis Oliphant</P>
<P CLASS="Body">
<A NAME="pgfId-139553"></A>March 30, 2001</P>
<P CLASS="PublisherBook">
<A NAME="pgfId-80713"></A>Lawrence Livermore National Laboratory, Livermore, CA 94566</P>
<P CLASS="PublisherBook">
<A NAME="pgfId-80714"></A>UCRL-MA-128569</P>
<DIV>
<H4 CLASS="Auspices">
<A NAME="pgfId-80758"></A><A NAME="18807"></A>Legal Notice</H4>
<P CLASS="PublisherBook">
<A NAME="pgfId-157986"></A>&nbsp;</P>
<P CLASS="AuspicesText">
<A NAME="pgfId-157987"></A>Please see file Legal.html in the source distribution.</P>
<P CLASS="AuspicesText">
<A NAME="pgfId-157994"></A>This open source project has been contributed to by many people, including personnel of the Lawrence Livermore National Laboratory. The following notice covers those contributions including this manual.</P>
<P CLASS="AuspicesText">
<A NAME="pgfId-157998"></A>&nbsp;</P>
<P CLASS="AuspicesText">
<A NAME="pgfId-80760"></A>Copyright (c) 1999 The Regents of the University of California. All rights reserved. </P>
<P CLASS="AuspicesText">
<A NAME="pgfId-80761"></A>Permission to use, copy, modify, and distribute this software for any purpose without fee is hereby granted, provided that this entire notice is included in all copies of any software which is or includes a copy or modification of this software and in all copies of the supporting documentation for such software. </P>
<P CLASS="AuspicesText">
<A NAME="pgfId-80762"></A>This work was produced at the University of California, Lawrence Livermore National Laboratory under contract no. W-7405-ENG-48 between the U.S. Department of Energy and The Regents of the University of California for the operation of UC LLNL. </P>
<P CLASS="AuspicesText">
<A NAME="pgfId-80755"></A>This software was prepared as an account of work sponsored by an agency of the United States Government. Neither the United States Government nor the University of California nor any of their employees, makes any warranty, express or implied, or assumes any liability or responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately-owned rights. Reference herein to any specific commercial products, process, or service by trade name, trademark, manufacturer, or otherwise, does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States Government or the University of California. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States Government or the University of California, and shall not be used for advertising or product endorsement purposes.</P>
<P CLASS="AuspicesText">
<A NAME="pgfId-90256"></A>&nbsp;</P>
<P CLASS="AuspicesText">
<A NAME="pgfId-80754"></A>&nbsp;</P>
</DIV>
<DIV>
<H3 CLASS="TocTitle">
<A NAME="pgfId-688118"></A>Table Of Contents</H3>
<DIV>
<H4 CLASS="ChapterSetTOC">
<A NAME="pgfId-699672"></A><A HREF="numdoc.html#pgfId-59427" CLASS="Index">Numerical Python 1</A></H4>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699674"></A><A HREF="numdoc.html#pgfId-78440" CLASS="Index">Introduction 2</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699676"></A><A HREF="numdoc.html#pgfId-67465" CLASS="Index">Where to get information and code 3</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699678"></A><A HREF="numdoc.html#pgfId-67319" CLASS="Index">Acknowledgments 4</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699680"></A><A HREF="numdoc.html#pgfId-35559" CLASS="Index">Installing NumPy 5</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699682"></A><A HREF="numdoc.html#pgfId-37275" CLASS="Index">Testing the Python installation 5</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699684"></A><A HREF="numdoc.html#pgfId-37281" CLASS="Index">Testing the Numeric Python Extension Installation 5</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699686"></A><A HREF="numdoc.html#pgfId-54827" CLASS="Index">Installing NumPy 5</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699688"></A><A HREF="numdoc.html#pgfId-84400" CLASS="Index">Installing on Windows 6</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699690"></A><A HREF="numdoc.html#pgfId-84404" CLASS="Index">Installing on Unix 6</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699692"></A><A HREF="numdoc.html#pgfId-68233" CLASS="Index">At the SourceForge... 6</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699694"></A><A HREF="numdoc.html#pgfId-37261" CLASS="Index">The NumTut package 7</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699696"></A><A HREF="numdoc.html#pgfId-35585" CLASS="Index">Testing the NumTut package 7</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699698"></A><A HREF="numdoc.html#pgfId-56796" CLASS="Index">Possible reasons for failure 7</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699700"></A><A HREF="numdoc.html#pgfId-57000" CLASS="Index">Win32 7</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699702"></A><A HREF="numdoc.html#pgfId-56857" CLASS="Index">Unix 8</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699704"></A><A HREF="numdoc.html#pgfId-57136" CLASS="Index">High-Level Overview 9</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699706"></A><A HREF="numdoc.html#pgfId-57154" CLASS="Index">Array Objects 9</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699708"></A><A HREF="numdoc.html#pgfId-57178" CLASS="Index">Universal Functions 10</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699710"></A><A HREF="numdoc.html#pgfId-60952" CLASS="Index">Convenience Functions 10</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699712"></A><A HREF="numdoc.html#pgfId-57315" CLASS="Index">Array Basics 12</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699714"></A><A HREF="numdoc.html#pgfId-37311" CLASS="Index">Basics 12</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699716"></A><A HREF="numdoc.html#pgfId-35605" CLASS="Index">Creating arrays from scratch 12</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699718"></A><A HREF="numdoc.html#pgfId-35606" CLASS="Index">array() and typecodes 12</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699720"></A><A HREF="numdoc.html#pgfId-35637" CLASS="Index">Multidimensional Arrays 14</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699722"></A><A HREF="numdoc.html#pgfId-68290" CLASS="Index">resize 16</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699724"></A><A HREF="numdoc.html#pgfId-60291" CLASS="Index">Creating arrays with values specified `on-the-fly' 17</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699726"></A><A HREF="numdoc.html#pgfId-60120" CLASS="Index">zeros() and ones() 17</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699728"></A><A HREF="numdoc.html#pgfId-35764" CLASS="Index">arrayrange() 17</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699730"></A><A HREF="numdoc.html#pgfId-35809" CLASS="Index">Creating an array from a function: fromfunction() 19</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699732"></A><A HREF="numdoc.html#pgfId-59602" CLASS="Index">identity() 20</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699734"></A><A HREF="numdoc.html#pgfId-35852" CLASS="Index">Coercion and Casting 20</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699736"></A><A HREF="numdoc.html#pgfId-35854" CLASS="Index">Automatic Coercions and Binary Operations 20</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699738"></A><A HREF="numdoc.html#pgfId-35864" CLASS="Index">Deliberate up-casting: The asarray function 21</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699740"></A><A HREF="numdoc.html#pgfId-35867" CLASS="Index">The typecode value table 21</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699742"></A><A HREF="numdoc.html#pgfId-35950" CLASS="Index">Consequences of silent upcasting 22</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699744"></A><A HREF="numdoc.html#pgfId-68241" CLASS="Index">Saving space 22</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699746"></A><A HREF="numdoc.html#pgfId-35975" CLASS="Index">Deliberate casts (potentially down): the astype method 22</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699748"></A><A HREF="numdoc.html#pgfId-35984" CLASS="Index">Operating on Arrays 23</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699750"></A><A HREF="numdoc.html#pgfId-35985" CLASS="Index">Simple operations 23</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699752"></A><A HREF="numdoc.html#pgfId-85860" CLASS="Index">In-place operations 24</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699754"></A><A HREF="numdoc.html#pgfId-36033" CLASS="Index">Getting and Setting array values 24</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699756"></A><A HREF="numdoc.html#pgfId-36074" CLASS="Index">Slicing Arrays 25</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699758"></A><A HREF="numdoc.html#pgfId-36126" CLASS="Index">Ufuncs 27</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699760"></A><A HREF="numdoc.html#pgfId-36127" CLASS="Index">What are Ufuncs? 27</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699762"></A><A HREF="numdoc.html#pgfId-36229" CLASS="Index">Ufuncs can operate on any Python sequence 28</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699764"></A><A HREF="numdoc.html#pgfId-36233" CLASS="Index">Ufuncs can take output arguments 28</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699766"></A><A HREF="numdoc.html#pgfId-36249" CLASS="Index">Ufuncs have special methods 28</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699768"></A><A HREF="numdoc.html#pgfId-36250" CLASS="Index">The reduce ufunc method 28</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699770"></A><A HREF="numdoc.html#pgfId-61704" CLASS="Index">The accumulate ufunc method 29</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699772"></A><A HREF="numdoc.html#pgfId-61715" CLASS="Index">The outer ufunc method 29</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699774"></A><A HREF="numdoc.html#pgfId-61737" CLASS="Index">The reduceat ufunc method 29</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699776"></A><A HREF="numdoc.html#pgfId-61739" CLASS="Index">Ufuncs always return new arrays 30</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699778"></A><A HREF="numdoc.html#pgfId-36300" CLASS="Index">Which are the Ufuncs? 30</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699780"></A><A HREF="numdoc.html#pgfId-36302" CLASS="Index">Unary Mathematical Ufuncs (take only one argument) 30</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699782"></A><A HREF="numdoc.html#pgfId-36313" CLASS="Index">Binary Mathematical Ufuncs 30</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699784"></A><A HREF="numdoc.html#pgfId-36315" CLASS="Index">Logical Ufuncs 30</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699786"></A><A HREF="numdoc.html#pgfId-36357" CLASS="Index">Ufunc shorthands 31</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699788"></A><A HREF="numdoc.html#pgfId-36371" CLASS="Index">Pseudo Indices 32</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699790"></A><A HREF="numdoc.html#pgfId-36422" CLASS="Index">Array Functions 34</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699792"></A><A HREF="numdoc.html#pgfId-36425" CLASS="Index">take(a, indices, axis=0) 34</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699794"></A><A HREF="numdoc.html#pgfId-78510" CLASS="Index">put (a, indices, values) 35</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699796"></A><A HREF="numdoc.html#pgfId-84177" CLASS="Index">putmask (a, mask, values) 36</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699798"></A><A HREF="numdoc.html#pgfId-36476" CLASS="Index">transpose(a, axes=None) 36</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699800"></A><A HREF="numdoc.html#pgfId-36494" CLASS="Index">repeat(a, repeats, axis=0) 36</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699802"></A><A HREF="numdoc.html#pgfId-36498" CLASS="Index">choose(a, (b0, ..., bn)) 36</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699804"></A><A HREF="numdoc.html#pgfId-36512" CLASS="Index">ravel(a) 37</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699806"></A><A HREF="numdoc.html#pgfId-58067" CLASS="Index">nonzero(a) 37</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699808"></A><A HREF="numdoc.html#pgfId-36518" CLASS="Index">where(condition, x, y) 37</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699810"></A><A HREF="numdoc.html#pgfId-36520" CLASS="Index">compress(condition, a, axis=0) 37</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699812"></A><A HREF="numdoc.html#pgfId-58163" CLASS="Index">diagonal(a, k=0) 37</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699814"></A><A HREF="numdoc.html#pgfId-36523" CLASS="Index">trace(a, k=0) 38</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699816"></A><A HREF="numdoc.html#pgfId-36532" CLASS="Index">searchsorted(a, values) 38</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699818"></A><A HREF="numdoc.html#pgfId-66636" CLASS="Index">sort(a, axis=-1) 38</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699820"></A><A HREF="numdoc.html#pgfId-65841" CLASS="Index">argsort(a, axis=-1) 39</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699822"></A><A HREF="numdoc.html#pgfId-66027" CLASS="Index">argmax(a, axis=-1), argmin(a, axis=-1) 39</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699824"></A><A HREF="numdoc.html#pgfId-36538" CLASS="Index">fromstring(string, typecode) 39</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699826"></A><A HREF="numdoc.html#pgfId-36540" CLASS="Index">dot(m1, m2) 40</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699828"></A><A HREF="numdoc.html#pgfId-36542" CLASS="Index">matrixmultiply(m1, m2) 40</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699830"></A><A HREF="numdoc.html#pgfId-36545" CLASS="Index">clip(m, m_min, m_max) 40</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699832"></A><A HREF="numdoc.html#pgfId-66267" CLASS="Index">indices(shape, typecode=None) 40</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699834"></A><A HREF="numdoc.html#pgfId-58407" CLASS="Index">swapaxes(a, axis1, axis2) 41</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699836"></A><A HREF="numdoc.html#pgfId-58428" CLASS="Index">concatenate((a0, a1, ... , an), axis=0) 41</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699838"></A><A HREF="numdoc.html#pgfId-58474" CLASS="Index">innerproduct(a, b) 42</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699840"></A><A HREF="numdoc.html#pgfId-84301" CLASS="Index">outerproduct(a,b) 42</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699842"></A><A HREF="numdoc.html#pgfId-84308" CLASS="Index">array_repr() 42</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699844"></A><A HREF="numdoc.html#pgfId-58479" CLASS="Index">array_str() 42</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699846"></A><A HREF="numdoc.html#pgfId-58481" CLASS="Index">resize(a, new_shape) 42</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699848"></A><A HREF="numdoc.html#pgfId-58514" CLASS="Index">diagonal(a, offset=0, axis1=-2, axis2=-1) 42</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699850"></A><A HREF="numdoc.html#pgfId-58523" CLASS="Index">repeat	 (a, counts, axis=0) 42</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699852"></A><A HREF="numdoc.html#pgfId-67914" CLASS="Index">convolve (a, v, mode=0) 43</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699854"></A><A HREF="numdoc.html#pgfId-67917" CLASS="Index">cross_correlate (a, v, mode=0) 43</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699856"></A><A HREF="numdoc.html#pgfId-67907" CLASS="Index">where (condition, x, y) 43</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699858"></A><A HREF="numdoc.html#pgfId-58536" CLASS="Index">identity(n) 43</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699860"></A><A HREF="numdoc.html#pgfId-58544" CLASS="Index">sum(a, index=0) 44</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699862"></A><A HREF="numdoc.html#pgfId-58556" CLASS="Index">cumsum(a, index=0) 44</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699864"></A><A HREF="numdoc.html#pgfId-58558" CLASS="Index">product(a, index=0) 44</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699866"></A><A HREF="numdoc.html#pgfId-58560" CLASS="Index">cumproduct(a, index=0) 44</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699868"></A><A HREF="numdoc.html#pgfId-58562" CLASS="Index">alltrue(a, index=0) 44</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699870"></A><A HREF="numdoc.html#pgfId-58564" CLASS="Index">sometrue(a, index=0) 44</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699872"></A><A HREF="numdoc.html#pgfId-36552" CLASS="Index">Array Methods 45</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699874"></A><A HREF="numdoc.html#pgfId-36554" CLASS="Index">itemsize() 45</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699876"></A><A HREF="numdoc.html#pgfId-36565" CLASS="Index">iscontiguous() 45</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699878"></A><A HREF="numdoc.html#pgfId-36568" CLASS="Index">typecode() 45</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699880"></A><A HREF="numdoc.html#pgfId-36576" CLASS="Index">byteswapped() 45</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699882"></A><A HREF="numdoc.html#pgfId-36582" CLASS="Index">tostring() 45</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699884"></A><A HREF="numdoc.html#pgfId-36588" CLASS="Index">tolist() 46</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699886"></A><A HREF="numdoc.html#pgfId-36604" CLASS="Index">Array Attributes 47</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699888"></A><EM CLASS="Emphasis">
<A HREF="numdoc.html#pgfId-36606" CLASS="Index">flat 47</A></EM>
</P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699890"></A><EM CLASS="Emphasis">
<A HREF="numdoc.html#pgfId-36629" CLASS="Index">real</A></EM>
 and <EM CLASS="Emphasis">
imaginary 47</EM>
</P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699892"></A><A HREF="numdoc.html#pgfId-59071" CLASS="Index">Special Topics 49</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699894"></A><A HREF="numdoc.html#pgfId-67984" CLASS="Index">Subclassing 49</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699896"></A><A HREF="numdoc.html#pgfId-67992" CLASS="Index">Code Organization 49</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699898"></A><A HREF="numdoc.html#pgfId-66725" CLASS="Index">Numeric.py and friends 49</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699900"></A><A HREF="numdoc.html#pgfId-66711" CLASS="Index">UserArray.py 49</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699902"></A><A HREF="numdoc.html#pgfId-66719" CLASS="Index">Matrix.py 49</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699904"></A><A HREF="numdoc.html#pgfId-66783" CLASS="Index">Precision.py 49</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699906"></A><A HREF="numdoc.html#pgfId-66787" CLASS="Index">ArrayPrinter.py 49</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-699908"></A><A HREF="numdoc.html#pgfId-66808" CLASS="Index">Mlab.py 49</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699910"></A><A HREF="numdoc.html#pgfId-66920" CLASS="Index">bartlett(M) 49</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699912"></A><A HREF="numdoc.html#pgfId-66922" CLASS="Index">blackman(M) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699914"></A><A HREF="numdoc.html#pgfId-66924" CLASS="Index">corrcoef(x, y=None) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699916"></A><A HREF="numdoc.html#pgfId-66926" CLASS="Index">cov(m,y=None) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699918"></A><A HREF="numdoc.html#pgfId-66928" CLASS="Index">cumprod(m) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699920"></A><A HREF="numdoc.html#pgfId-66930" CLASS="Index">cumsum(m) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699922"></A><A HREF="numdoc.html#pgfId-66932" CLASS="Index">diag(v, k=0) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699924"></A><A HREF="numdoc.html#pgfId-66934" CLASS="Index">diff(x, n=1) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699926"></A><A HREF="numdoc.html#pgfId-66936" CLASS="Index">eig(m) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699928"></A><A HREF="numdoc.html#pgfId-66938" CLASS="Index">eye(N, M=N, k=0, typecode=None) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699930"></A><A HREF="numdoc.html#pgfId-66940" CLASS="Index">fliplr(m) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699932"></A><A HREF="numdoc.html#pgfId-66942" CLASS="Index">flipud(m) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699934"></A><A HREF="numdoc.html#pgfId-66944" CLASS="Index">hamming(M) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699936"></A><A HREF="numdoc.html#pgfId-66946" CLASS="Index">hanning(M) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699938"></A><A HREF="numdoc.html#pgfId-66948" CLASS="Index">kaiser(M, beta) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699940"></A><A HREF="numdoc.html#pgfId-66950" CLASS="Index">max(m) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699942"></A><A HREF="numdoc.html#pgfId-67179" CLASS="Index">mean(m) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699944"></A><A HREF="numdoc.html#pgfId-66954" CLASS="Index">median(m) 50</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699946"></A><A HREF="numdoc.html#pgfId-66956" CLASS="Index">min(m) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699948"></A><A HREF="numdoc.html#pgfId-66958" CLASS="Index">msort(m) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699950"></A><A HREF="numdoc.html#pgfId-66960" CLASS="Index">prod(m) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699952"></A><A HREF="numdoc.html#pgfId-66962" CLASS="Index">ptp(m) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699954"></A><A HREF="numdoc.html#pgfId-66964" CLASS="Index">rand(d1, ..., dn) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699956"></A><A HREF="numdoc.html#pgfId-67153" CLASS="Index">rot90(m,k=1) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699958"></A><A HREF="numdoc.html#pgfId-67155" CLASS="Index">sinc(x) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699960"></A><A HREF="numdoc.html#pgfId-66970" CLASS="Index">squeeze(a) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699962"></A><A HREF="numdoc.html#pgfId-66972" CLASS="Index">std(m) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699964"></A><A HREF="numdoc.html#pgfId-66974" CLASS="Index">sum(m) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699966"></A><A HREF="numdoc.html#pgfId-66976" CLASS="Index">svd(m) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699968"></A><A HREF="numdoc.html#pgfId-66978" CLASS="Index">trapz(y,x=None) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699970"></A><A HREF="numdoc.html#pgfId-66980" CLASS="Index">tri(N, M=N, k=0, typecode=None) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699972"></A><A HREF="numdoc.html#pgfId-66982" CLASS="Index">tril(m,k=0) 51</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-699974"></A><A HREF="numdoc.html#pgfId-66984" CLASS="Index">triu(m,k=0) 51</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699976"></A><A HREF="numdoc.html#pgfId-66811" CLASS="Index">The multiarray object 52</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699978"></A><A HREF="numdoc.html#pgfId-59085" CLASS="Index">Typecodes 52</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699980"></A><A HREF="numdoc.html#pgfId-59290" CLASS="Index">Indexing in and out, slicing 53</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699982"></A><A HREF="numdoc.html#pgfId-59320" CLASS="Index">Ellipses 54</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699984"></A><A HREF="numdoc.html#pgfId-59324" CLASS="Index">NewAxis 54</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699986"></A><A HREF="numdoc.html#pgfId-59327" CLASS="Index">Set-indexing and Broadcasting 54</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699988"></A><A HREF="numdoc.html#pgfId-59331" CLASS="Index">Axis specifications 55</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699990"></A><A HREF="numdoc.html#pgfId-59333" CLASS="Index">Textual representations of arrays 55</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699992"></A><A HREF="numdoc.html#pgfId-59418" CLASS="Index">Comparisons 57</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699994"></A><A HREF="numdoc.html#pgfId-67223" CLASS="Index">Pickling and Unpickling -- storing arrays on disk 57</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-699996"></A><A HREF="numdoc.html#pgfId-59422" CLASS="Index">Dealing with floating point exceptions 57</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-699998"></A><A HREF="numdoc.html#pgfId-36640" CLASS="Index">Writing a C extension to NumPy 58</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700000"></A><A HREF="numdoc.html#pgfId-36641" CLASS="Index">Introduction 58</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700002"></A><A HREF="numdoc.html#pgfId-36646" CLASS="Index">Preparing an extension module for NumPy arrays 58</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700004"></A><A HREF="numdoc.html#pgfId-36649" CLASS="Index">Accessing NumPy arrays from C 58</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700006"></A><A HREF="numdoc.html#pgfId-36650" CLASS="Index">Types and Internal Structure 58</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700008"></A><A HREF="numdoc.html#pgfId-36661" CLASS="Index">Element data types 59</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700010"></A><A HREF="numdoc.html#pgfId-36717" CLASS="Index">Contiguous arrays 60</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700012"></A><A HREF="numdoc.html#pgfId-36719" CLASS="Index">Zero-dimensional arrays 60</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700014"></A><A HREF="numdoc.html#pgfId-36721" CLASS="Index">A simple example 60</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700016"></A><A HREF="numdoc.html#pgfId-36748" CLASS="Index">Accepting input data from any sequence type 61</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700018"></A><A HREF="numdoc.html#pgfId-36783" CLASS="Index">Creating NumPy arrays 62</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700020"></A><A HREF="numdoc.html#pgfId-36796" CLASS="Index">Returning arrays from C functions 62</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700022"></A><A HREF="numdoc.html#pgfId-36801" CLASS="Index">A less simple example 62</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-700024"></A><A HREF="numdoc.html#pgfId-57398" CLASS="Index">C API Reference 64</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700026"></A><A HREF="numdoc.html#pgfId-25107" CLASS="Index">ArrayObject C Structure and API 64</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700028"></A><A HREF="numdoc.html#pgfId-57404" CLASS="Index">Structures 64</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700030"></A><A HREF="numdoc.html#pgfId-34282" CLASS="Index">The ArrayObject API 65</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700032"></A><A HREF="numdoc.html#pgfId-586" CLASS="Index">Notes 68</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700034"></A><A HREF="numdoc.html#pgfId-587" CLASS="Index">UfuncObject C Structure and API 68</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700036"></A><A HREF="numdoc.html#pgfId-589" CLASS="Index">C Structure 68</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700038"></A><A HREF="numdoc.html#pgfId-590" CLASS="Index">UfuncObject C API 70</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-700040"></A><A HREF="numdoc.html#pgfId-57323" CLASS="Index">Glossary 73</A></P>
</DIV>
<DIV>
<H4 CLASS="ChapterSetTOC">
<A NAME="pgfId-700042"></A><A HREF="numdoc.html#pgfId-304408" CLASS="Index">Optional Packages 75</A></H4>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700044"></A><A HREF="numdoc.html#pgfId-304744" CLASS="Index">License and disclaimer for packages MA and RNG 76</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-700046"></A><A HREF="numdoc.html#pgfId-304711" CLASS="Index">FFT Reference 77</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700048"></A><A HREF="numdoc.html#pgfId-302955" CLASS="Index">Python Interface 77</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700050"></A><A HREF="numdoc.html#pgfId-302958" CLASS="Index">fft(data, n=None, axis=-1) 77</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700052"></A><A HREF="numdoc.html#pgfId-302970" CLASS="Index">inverse_fft(data, n=None, axis=-1) 77</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700054"></A><A HREF="numdoc.html#pgfId-302973" CLASS="Index">real_fft(data, n=None, axis=-1) 77</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700056"></A><A HREF="numdoc.html#pgfId-302986" CLASS="Index">inverse_real_fft(data, n=None, axis=-1) 78</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700058"></A><A HREF="numdoc.html#pgfId-302988" CLASS="Index">fft2d(data, s=None, axes=(-2,-1)) 78</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700060"></A><A HREF="numdoc.html#pgfId-302990" CLASS="Index">real_fft2d(data, s=None, axes=(-2,-1)) 78</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700062"></A><A HREF="numdoc.html#pgfId-302992" CLASS="Index">C API 78</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700064"></A><A HREF="numdoc.html#pgfId-303012" CLASS="Index">Compilation Notes 79</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-700066"></A><A HREF="numdoc.html#pgfId-303015" CLASS="Index">LinearAlgebra Reference 80</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700068"></A><A HREF="numdoc.html#pgfId-303017" CLASS="Index">Python Interface 80</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700070"></A><A HREF="numdoc.html#pgfId-303019" CLASS="Index">solve_linear_equations(a, b) 80</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700072"></A><A HREF="numdoc.html#pgfId-303023" CLASS="Index">inverse(a) 80</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700074"></A><A HREF="numdoc.html#pgfId-303047" CLASS="Index">eigenvalues(a) 80</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700076"></A><A HREF="numdoc.html#pgfId-303058" CLASS="Index">eigenvectors(a) 81</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700078"></A><A HREF="numdoc.html#pgfId-303076" CLASS="Index">singular_value_decomposition(a, full_matrices=0) 81</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700080"></A><A HREF="numdoc.html#pgfId-303079" CLASS="Index">generalized_inverse(a, rcond=1e-10) 81</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700082"></A><A HREF="numdoc.html#pgfId-303082" CLASS="Index">determinant(a) 81</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700084"></A><A HREF="numdoc.html#pgfId-303085" CLASS="Index">linear_least_squares(a, b, rcond=e-10) 81</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700086"></A><A HREF="numdoc.html#pgfId-303088" CLASS="Index">Compilation Notes 81</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-700088"></A><A HREF="numdoc.html#pgfId-303091" CLASS="Index">RandomArray Reference 82</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700090"></A><A HREF="numdoc.html#pgfId-303094" CLASS="Index">Python Interface 82</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700092"></A><A HREF="numdoc.html#pgfId-303096" CLASS="Index">seed(x=0, y=0) 82</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700094"></A><A HREF="numdoc.html#pgfId-303099" CLASS="Index">get_seed() 82</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700096"></A><A HREF="numdoc.html#pgfId-303102" CLASS="Index">random(shape=</A><EM CLASS="Emphasis">
ReturnFloat</EM>
) 82</P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700098"></A><A HREF="numdoc.html#pgfId-303105" CLASS="Index">uniform(minimum, maximum, shape=ReturnFloat) 82</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700100"></A><A HREF="numdoc.html#pgfId-303108" CLASS="Index">randint(minimum, maximum, shape=ReturnFloat) 82</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700102"></A><A HREF="numdoc.html#pgfId-303111" CLASS="Index">permutation(n) 82</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700104"></A><A HREF="numdoc.html#pgfId-305397" CLASS="Index">Floating point random arrays 83</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700106"></A><A HREF="numdoc.html#pgfId-305398" CLASS="Index">standard_normal (shape=ReturnFloat) 83</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700108"></A><A HREF="numdoc.html#pgfId-305400" CLASS="Index">normal (mean, stddev, shape=ReturnFloat) 83</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700110"></A><A HREF="numdoc.html#pgfId-305402" CLASS="Index">multivariate_normal (mean, covariance) or <BR>
multivariate_normal (mean, covariance, leadingAxesShape) 83</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700112"></A><A HREF="numdoc.html#pgfId-305407" CLASS="Index">exponential (mean, shape=ReturnFloat) 83</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700114"></A><A HREF="numdoc.html#pgfId-305409" CLASS="Index">beta (a, b, shape=ReturnFloat) 83</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700116"></A><A HREF="numdoc.html#pgfId-305411" CLASS="Index">gamma (a, r, shape=ReturnFloat) 84</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700118"></A><A HREF="numdoc.html#pgfId-305413" CLASS="Index">chi_square (df, shape=ReturnFloat) 84</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700120"></A><A HREF="numdoc.html#pgfId-305415" CLASS="Index">noncentral_chi_square (df, nonc, shape=ReturnFloat) 84</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700122"></A><A HREF="numdoc.html#pgfId-305417" CLASS="Index">F (dfn, dfd, shape=ReturnFloat) 84</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700124"></A><A HREF="numdoc.html#pgfId-305419" CLASS="Index">noncentral_F (dfn, dfd, nconc, shape=ReturnFloat) 84</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700126"></A><A HREF="numdoc.html#pgfId-305421" CLASS="Index">Integer random arrays 84</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700128"></A><A HREF="numdoc.html#pgfId-305422" CLASS="Index">binomial (trials, prob, shape=ReturnInt) 84</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700130"></A><A HREF="numdoc.html#pgfId-305424" CLASS="Index">negative_binomial (trials, prob, shape=ReturnInt) 84</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700132"></A><A HREF="numdoc.html#pgfId-305426" CLASS="Index">poisson (mean, shape=ReturnInt) 84</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700134"></A><A HREF="numdoc.html#pgfId-305428" CLASS="Index">multinomial (trials, probs) or multinomial (trials, probs, leadingAxesShape) 84</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700136"></A><A HREF="numdoc.html#pgfId-305431" CLASS="Index">Examples 85</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-700138"></A><A HREF="numdoc.html#pgfId-290702" CLASS="Index">Independent Random Streams 87</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700140"></A><A HREF="numdoc.html#pgfId-304780" CLASS="Index">Background 87</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700142"></A><A HREF="numdoc.html#pgfId-304419" CLASS="Index">Usage 87</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700144"></A><A HREF="numdoc.html#pgfId-304559" CLASS="Index">Module RNG 87</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-700146"></A><A HREF="numdoc.html#pgfId-304635" CLASS="Index">Generator objects 87</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700148"></A><A HREF="numdoc.html#pgfId-304493" CLASS="Index">Module ranf 88</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700150"></A><A HREF="numdoc.html#pgfId-304426" CLASS="Index">Examples 88</A></P>
<P CLASS="ChapterTOC">
<A NAME="pgfId-700152"></A><A HREF="numdoc.html#pgfId-303698" CLASS="Index">Masked Arrays 89</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700154"></A><A HREF="numdoc.html#pgfId-296294" CLASS="Index">What is a masked array? 89</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700156"></A><A HREF="numdoc.html#pgfId-304772" CLASS="Index">Installing and using MA 89</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700158"></A><A HREF="numdoc.html#pgfId-296950" CLASS="Index">Class MaskedArray 89</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700160"></A><A HREF="numdoc.html#pgfId-305213" CLASS="Index">Attributes of masked arrays 90</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700162"></A><A HREF="numdoc.html#pgfId-305217" CLASS="Index">Methods on masked arrays. 91</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700164"></A><A HREF="numdoc.html#pgfId-320251" CLASS="Index">Constructing masked arrays 92</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700166"></A><A HREF="numdoc.html#pgfId-320302" CLASS="Index">What are masks? 94</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700168"></A><A HREF="numdoc.html#pgfId-320312" CLASS="Index">Working with masks 94</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700170"></A><A HREF="numdoc.html#pgfId-320257" CLASS="Index">Operations 94</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700172"></A><A HREF="numdoc.html#pgfId-305173" CLASS="Index">Copying or not? 95</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700174"></A><A HREF="numdoc.html#pgfId-305435" CLASS="Index">Behaviors 95</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700176"></A><A HREF="numdoc.html#pgfId-304210" CLASS="Index">Indexing and Slicing 95</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700178"></A><A HREF="numdoc.html#pgfId-306592" CLASS="Index">Indexing that produces a scalar result 95</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700180"></A><A HREF="numdoc.html#pgfId-304229" CLASS="Index">Assignment to elements and slices 95</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700182"></A><A HREF="numdoc.html#pgfId-297249" CLASS="Index">Module MA: Attributes 96</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700184"></A><A HREF="numdoc.html#pgfId-305706" CLASS="Index">Module MA: Functions 96</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700186"></A><A HREF="numdoc.html#pgfId-298306" CLASS="Index">Unary functions 96</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700188"></A><A HREF="numdoc.html#pgfId-298312" CLASS="Index">Binary functions 96</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-700190"></A><A HREF="numdoc.html#pgfId-298340" CLASS="Index">Comparison operators 96</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-700192"></A><A HREF="numdoc.html#pgfId-298353" CLASS="Index">Logical operators 96</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700194"></A><A HREF="numdoc.html#pgfId-298365" CLASS="Index">Special array operators 97</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700196"></A><A HREF="numdoc.html#pgfId-305726" CLASS="Index">Controlling the size of the string representations 98</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700198"></A><A HREF="numdoc.html#pgfId-304172" CLASS="Index">Helper classes 98</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700200"></A><A HREF="numdoc.html#pgfId-306892" CLASS="Index">MAError 98</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700202"></A><A HREF="numdoc.html#pgfId-306894" CLASS="Index">The constant masked 98</A></P>
<P CLASS="FM3HeadingTOC">
<A NAME="pgfId-700204"></A><A HREF="numdoc.html#pgfId-306903" CLASS="Index">Example of masked behavior 99</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700206"></A><A HREF="numdoc.html#pgfId-305737" CLASS="Index">Class masked_unary_function 99</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700208"></A><A HREF="numdoc.html#pgfId-305759" CLASS="Index">Class masked_binary_function 99</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700210"></A><A HREF="numdoc.html#pgfId-306950" CLASS="Index">ActiveAttributes 100</A></P>
<P CLASS="FM1HeadingTOC">
<A NAME="pgfId-700212"></A><A HREF="numdoc.html#pgfId-306123" CLASS="Index">Examples of Using MA 100</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700214"></A><A HREF="numdoc.html#pgfId-306127" CLASS="Index">Data with a given value representing missing data 100</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700216"></A><A HREF="numdoc.html#pgfId-306145" CLASS="Index">Filling in the missing data 101</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700218"></A><A HREF="numdoc.html#pgfId-306378" CLASS="Index">Numerical operations 101</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700220"></A><A HREF="numdoc.html#pgfId-306406" CLASS="Index">Seeing the mask 101</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700222"></A><A HREF="numdoc.html#pgfId-306428" CLASS="Index">Filling it your way 101</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700224"></A><A HREF="numdoc.html#pgfId-320020" CLASS="Index">Ignoring extreme values 101</A></P>
<P CLASS="FM2HeadingTOC">
<A NAME="pgfId-700226"></A><A HREF="numdoc.html#pgfId-320037" CLASS="Index">Averaging an entire multidimensional array 102</A></P>
</DIV>
<DIV>
<H4 CLASS="IndexTitleTOC">
<A NAME="pgfId-700228"></A><A HREF="numdoc.html#pgfId-862972" CLASS="Index">Index 103</A></H4>
</DIV>
</DIV>
<DIV>
<H2 CLASS="ChapterSet">
<A NAME="pgfId-59427"></A></h2>
<DIV>
</DIV>
Part I: <A NAME="92764"></A>Numerical Python<DIV>
</DIV>
<P CLASS="ChapterDescription">
<A NAME="pgfId-78485"></A>Numerical Python (&quot;Numpy&quot;) adds a fast multidimensional array facility to Python. This part contains all you need to know about &quot;Numpy&quot; arrays and the functions that operate upon them.</P>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-78440"></A>1.	 Introduction</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-37405"></A>This chapter introduces the Numeric Python extension and outlines the rest of the document.</P>
<P CLASS="Body">
<A NAME="pgfId-35556"></A>The Numeric Python extensions (NumPy henceforth) is a set of extensions to the Python programming language which allows Python programmers to efficiently manipulate large sets of objects organized in grid-like fashion. These sets of objects are called arrays, and they can have any number of dimensions: one dimensional arrays are similar to standard Python sequences, two-dimensional arrays are similar to matrices from linear algebra. Note that one-dimensional arrays are also different from any other Python sequence, and that two-dimensional matrices are also different from the matrices of linear algebra, in ways which we will mention later in this text.</P>
<P CLASS="Body">
<A NAME="pgfId-35557"></A>Why are these extensions needed? The core reason is a very prosaic one, and that is that manipulating a set of a million numbers in Python with the standard data structures such as lists, tuples or classes is much too slow and uses too much space. Anything which we can do in NumPy we can do in standard Python - we just may not be alive to see the program finish. A more subtle reason for these extensions however is that the kinds of operations that programmers typically want to do on arrays, while sometimes very complex, can often be decomposed into a set of fairly standard operations.  This decomposition has been developed similarly in many array languages.  In some ways, NumPy is simply the application of this experience to the Python language - thus many of the operations described in NumPy work the way they do because experience has shown that way to be a good one, in a variety of contexts. The languages which were used to guide the development of NumPy include the infamous APL family of languages, Basis, MATLAB, FORTRAN, S and S+, and others. This heritage will be obvious to users of NumPy who already have experience with these other languages. This tutorial, however, does not assume any such background, and all that is expected of the reader is a reasonable working knowledge of the standard Python language.</P>
<P CLASS="Body">
<A NAME="pgfId-35558"></A>This document is the &quot;official&quot; documentation for NumPy. It is both a tutorial and the most authoritative source of information about NumPy with the exception of the source code. The tutorial material will walk you through a set of manipulations of simple, small, arrays of numbers, as well as image files. This choice was made because: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-67348"></A>A concrete data set makes explaining the behavior of some functions much easier to motivate than simply talking about abstract operations on abstract data sets;</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-67349"></A>Every reader will have at least an intuition as to the meaning of the data and organization of image files, and </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-67350"></A>The result of various manipulations can be displayed simply since the data set has a natural graphical representation. </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-67351"></A>All users of NumPy, whether interested in image processing or not, are encouraged to follow the tutorial with a working NumPy installation at their side, testing the examples, and, more importantly, transferring the understanding gained by working on images to their specific domain. The best way to learn is by doing - the aim of this tutorial is to guide you along this &quot;doing.&quot;</P>
<P CLASS="Body">
<A NAME="pgfId-67367"></A>Here is what the rest of this part contains:</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67265"></A><A HREF="numdoc.html#71535" CLASS="XRef">Installing NumPy</A> provides information on testing Python, NumPy, and compiling and installing NumPy if necessary.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67266"></A><A HREF="numdoc.html#35986" CLASS="XRef">The NumTut package</A> provides information on testing and installing the NumTut package, which allows easy visualization of arrays.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67267"></A><A HREF="numdoc.html#70766" CLASS="XRef">High-Level Overview</A> gives a high-level overview of the components of the NumPy system as a whole.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67268"></A><A HREF="numdoc.html#82200" CLASS="XRef">Array Basics</A> provides a detailed step-by-step introduction to the most important aspect of NumPy, the multidimensional array objects.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67269"></A><A HREF="numdoc.html#30906" CLASS="XRef">Ufuncs</A> provides information on universal functions, the mathematical functions which operate on arrays and other sequences elementwise.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67270"></A><A HREF="numdoc.html#21398" CLASS="XRef">Pseudo Indices</A> covers syntax for some special indexing operators.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67271"></A><A HREF="numdoc.html#28351" CLASS="XRef">Array Functions</A> is a catalog of each of the utility functions which allow easy algorithmic processing of arrays.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67272"></A><A HREF="numdoc.html#42194" CLASS="XRef">Array Methods</A> discusses the methods of array objects.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67273"></A><A HREF="numdoc.html#86746" CLASS="XRef">Array Attributes</A> presents the attributes of array objects.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67274"></A><A HREF="numdoc.html#92607" CLASS="XRef">Special Topics</A> is a collection of special topics, from the organization of the codebase to the mechanisms for customizing printing.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67275"></A><A HREF="numdoc.html#69650" CLASS="XRef">Writing a C extension to NumPy</A> is an tutorial on how to write a C extension which uses NumPy arrays.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67276"></A><A HREF="numdoc.html#36241" CLASS="XRef">C API Reference</A> is a reference for the C API to NumPy objects (both PyArrayObjects and UFuncObjects).</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-67292"></A><A HREF="numdoc.html#92539" CLASS="XRef">Glossary</A> is a glossary of terms.</P>
<P CLASS="KeepTogetherList">
<A NAME="pgfId-78480"></A>Reference material for the optional packages distributed with Numeric Python are described in the next part, <A HREF="numdoc.html#90799" CLASS="XRef">Optional Packages</A>.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-67465"></A><A NAME="18177"></A>Where to get information and code</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-67469"></A>Numerical Python and its documentation are available at SourceForge. The main web site is:</P>
<P CLASS="Body">
<A NAME="pgfId-68053"></A>http://numpy.sourceforge.net</P>
<P CLASS="Body">
<A NAME="pgfId-68060"></A>Downloads, bug reports, and patch facility, and releases are at the main project page, reachable from the above site or directly at: http://sourceforge.net/projects/numpy</P>
<P CLASS="Body">
<A NAME="pgfId-67489"></A>The Python web site is www.python.org</P>
<P CLASS="Body">
<A NAME="pgfId-84341"></A>Many packages are available from third parties that use Numeric to interface to a variety of mathematical and statistical software. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-67319"></A>Acknowledgments</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-67323"></A>Numerical Python is the outgrowth of a long collaborative design process carried out by the Matrix SIG of the Python Software Activity (PSA). Jim Hugunin, while a graduate student at MIT, wrote most of the code and initial documentation. When Jim joined CNRI and began working on JPython, he didn't have the time to maintain Numerical Python so Paul Dubois at LLNL agreed to become the maintainer of Numerical Python. David Ascher, working as a consultant to LLNL, wrote most of this document, incorporating contributions from Konrad Hinsen and Travis Oliphant, both of whom are major contributors to Numerical Python. </P>
<P CLASS="Body">
<A NAME="pgfId-84342"></A>Since the source was moved to SourceForge, the Numeric user community has become a significant part of the process. Numerical Python illustrates the power of the open source software concept. </P>
<P CLASS="Body">
<A NAME="pgfId-84350"></A>Please send comments and corrections to this manual to paul@pfdubois.com, or to Paul F. Dubois, L-264, Lawrence Livermore National Laboratory, Livermore, CA 94566, U.S.A.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-35559"></A>2.	 <A NAME="71535"></A>Installing NumPy</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-37406"></A>This chapter explains how to install and test NumPy, from either the source distribution or from the binary distribution.</P>
<P CLASS="FirstBody">
<A NAME="pgfId-37274"></A>Before we start with the actual tutorial, we will describe the steps needed for you to be able to follow along the examples step by step. These steps including installing Python, the NumPy extensions, and some tools and sample files used in the examples of this tutorial.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-37275"></A>Testing the Python installation</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-37276"></A>The first step is to install Python if you haven't already. Python is available from the Python project page at http://sourceforge.net/projects/python. Click on the link corresponding to your platform, and follow the instructions described there.  When installed, starting Python by typing <EM CLASS="Code">
python</EM>
 at the shell or double-clicking on the Python interpreter should give a prompt such as:</P>
<P CLASS="Python">
<A NAME="pgfId-85793"></A>Python 2.1b2 (#12, Mar 23 2001, 14:01:30) [MSC 32 bit (Intel)] on win32</P>
<P CLASS="Python">
<A NAME="pgfId-85794"></A>Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</P>
<P CLASS="Python">
<A NAME="pgfId-85795"></A>&gt;&gt;&gt;</P>
<P CLASS="Body">
<A NAME="pgfId-37280"></A>If you have problems getting this part to work, consider contacting a local support person or emailing <EM CLASS="URL">
python-help@python.org</EM>
 for help. If neither solution works, consider posting on the comp.lang.python newsgroup (details on the newsgroup/mailing list are available at <EM CLASS="URL">
http://www.python.org/psa/MailingLists.html#clp</EM>
).</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-37281"></A>Testing the Numeric Python Extension Installation</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-37282"></A>The standard Python distribution does not come as of this writing with the Numeric Python extensions installed, but your system administrator may have installed them already. To find out if your Python interpreter has NumPy installed, type <EM CLASS="Code">
import</EM>
 <EM CLASS="Code">
Numeric</EM>
 at the Python prompt. You'll see one of two behaviors (throughout this document, <EM CLASS="CodeInput">
bold</EM>
 <EM CLASS="CodeInput">
Courier New</EM>
 font indicates user input, and <EM CLASS="Code">
standard</EM>
 <EM CLASS="Code">
Courier New</EM>
 font indicates output):</P>
<P CLASS="Python">
<A NAME="pgfId-37283"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
import Numeric</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-37284"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-37285"></A> File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-37286"></A>ImportError: No module named Numeric</P>
<P CLASS="Python">
<A NAME="pgfId-37287"></A>&gt;&gt;&gt;</P>
<P CLASS="Body">
<A NAME="pgfId-37288"></A>indicating that you don't have NumPy installed, or:</P>
<P CLASS="Python">
<A NAME="pgfId-37289"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
import Numeric</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-37290"></A>&gt;&gt;&gt; </P>
<P CLASS="Body">
<A NAME="pgfId-37291"></A>indicating that you do. If you do, go on to the next step. If you don't, you have to get the NumPy extensions. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-54827"></A><A NAME="marker-59513"></A>Installing NumPy</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-68084"></A>The release facility at SourceForge is accessed through the project page, http://sourceforge.net/projects/numpy. Click on the &quot;numpy&quot; releases and you will be presented with a list of the available files. The files whose names end in &quot;.tar.gz&quot; are source code releases. The others are &quot;prebuilt&quot; for a given platform. It is possible to get the latest sources directly from our CVS repository using the facilities described at SourceForge. Note that while every effort is made to ensure that the repository is always &quot;good&quot;, direct use of the repository is subject to more errors than using a standard release.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-84400"></A>Installing on Windows</H6>
<P CLASS="Body">
<A NAME="pgfId-78642"></A>On Windows, we currently have .zip files that should be unzipped into the top of your Python distribution; there is no &quot;Setup&quot; to run. If you wish to build from source on Windows, the Unix procedure described below can be used, running python in a command-line tool.</P>
<P CLASS="Body">
<A NAME="pgfId-78643"></A>In general, there may not be a prebuilt version of a particular kind available in every minor release. If you need a prebuilt version, choose the most recent version available. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-84404"></A>Installing on Unix</H6>
<P CLASS="Body">
<A NAME="pgfId-59525"></A><A NAME="marker-59524"></A>The source distribution should be uncompressed and unpacked using the the tar program:</P>
<P CLASS="Python">
<A NAME="pgfId-57128"></A>csh&gt; tar xfz Numeric-n.m.tar.gz</P>
<P CLASS="Body">
<A NAME="pgfId-57132"></A>Follow the instructions in the top-level directory for compilation and installation. Note that there are options you must consider before beginning. Installation is usually as simple as:</P>
<P CLASS="Python">
<A NAME="pgfId-68617"></A>python setup_all.py install</P>
<P CLASS="Body">
<A NAME="pgfId-68624"></A>However, please (please!) see the README itself for the latest details.</P>
<DIV>
<H6 CLASS="NoteTip">
<A NAME="pgfId-67445"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Note">
<A NAME="pgfId-84474"></A><A NAME="fromNumericimportexplanation"></A>Just like all Python modules and packages, the Numeric module can be invoked using either the <EM CLASS="Code">
import Numeric</EM>
 form, or the <EM CLASS="Code">
from Numeric import ...</EM>
 form.  Because most of the functions we'll talk about are in the Numeric module, in this document, all of the code samples will assume that they have been preceded by a statement: <BR>
<BR>
from Numeric import *</P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-84478"></A></h6>
<DIV>
</DIV>
&nbsp;
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-68233"></A>At the SourceForge...</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-68540"></A>The <A NAME="marker-68558"></A>SourceForge project page for Numerical Python is at http://sourceforge.net/projects/numpy. On this project page you will find links to:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-68521"></A>The Numeric <A NAME="marker-68556"></A>Discussion List</LI>
<LI CLASS="BulletedCont">
<A NAME="pgfId-68237"></A>You can subscribe to a discussion list about Numeric python using the project page at SourceForge. The list is a good place to ask questions and get help. Send mail to numpy-discussion@lists.sourceforge.net.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-85709"></A>The Web Site</LI>
<LI CLASS="BulletedCont">
<A NAME="pgfId-85710"></A>Click on &quot;home page&quot; to get to the Numeric Python Home Page, which has links to documentation and other resources, including tools for connecting Numerical Python to Fortran.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-68511"></A><A NAME="marker-68554"></A>Bugs and <A NAME="marker-68555"></A>Patches</LI>
<LI CLASS="BulletContinuation">
<A NAME="pgfId-68512"></A>Bug tracking and patch-management facilities is provided on the SourceForge project page.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-68543"></A><A NAME="marker-68553"></A>CVS Repository</LI>
<LI CLASS="BulletContinuation">
<A NAME="pgfId-68530"></A>You can get the latest and greatest (albeit less tested and trustworthy) version of Numeric directly from our CVS repository.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-68534"></A><A NAME="marker-68557"></A>FTP Site</LI>
<LI CLASS="BulletContinuation">
<A NAME="pgfId-68535"></A>The FTP Site contains this documentation in several formats, plus maybe some other goodies we have lying around.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-37261"></A>3.	 <A NAME="35986"></A>The <A NAME="marker-59530"></A>NumTut package</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-67256"></A>This chapter leads the user through the installation and testing of the NumTut package, which should have been distributed with this document.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-35585"></A>Testing the NumTut package</H6>
<P CLASS="Body">
<A NAME="pgfId-67257"></A>This tutorial assumes that the NumTut package has been installed. If it hasn't, see below, <A HREF="numdoc.html#89754" CLASS="XRef">Possible reasons for failure</A>). This package contains a few sample images and utility functions for displaying arrays and the like. To find out if NumTut has been installed, do:</P>
<P CLASS="Python">
<A NAME="pgfId-35586"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
from NumTut import *</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35587"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(greece)</EM>
<A NAME="marker-59535"></A><A NAME="marker-59531"></A></P>
<P CLASS="Python">
<A NAME="pgfId-56844"></A>&nbsp;</P>
<DIV>
</DIV>
<P CLASS="Body">
<A NAME="pgfId-35588"></A>If a picture of a greek street shows up on your screen, you're all set, and you can go to the next chapter.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-56796"></A><A NAME="89754"></A>Possible reasons for failure</H6>
<P CLASS="Python">
<A NAME="pgfId-56961"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
import NumTut</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-56970"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-56971"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-56967"></A>ImportError: No module named NumTut</P>
<P CLASS="Body">
<A NAME="pgfId-56966"></A>This message indicates that you do not have the NumTut package installed in your PythonPath. NumTut is distributed along with the Numeric source distribution in the <EM CLASS="Code">
Demo</EM>
 subdirectory. Copy the <EM CLASS="Code">
NumTut</EM>
 subdirectory somewhere into your Python path, or just execute python from the Demo directory. </P>
<P CLASS="Body">
<A NAME="pgfId-85791"></A>If you have installed Numeric from a binary distribution, NumTut may not be included. Get the source distribution and find NumTut in the Demo subdirectory.</P>
<P CLASS="Body">
<A NAME="pgfId-68566"></A>On Win32, the NumTut directory can be placed in the main directory of your Python installation. On Unix, it can be placed in the site-packages directory of your installation.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-57000"></A>Win32</H6>
<P CLASS="Python">
<A NAME="pgfId-57005"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
import NumTut</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57006"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-57007"></A>[...]</P>
<P CLASS="Python">
<A NAME="pgfId-57008"></A>ConfigurationError: view needs Tkinter on Win32, and either threads or the IDLE editor&quot;</P>
<P CLASS="Body">
<A NAME="pgfId-57019"></A>or:</P>
<P CLASS="Python">
<A NAME="pgfId-57028"></A>ConfigurationError: view needs either threads or the IDLE editor to be enabled.</P>
<P CLASS="Body">
<A NAME="pgfId-56880"></A>On Win32 (Windows 95, 98, NT), the <A NAME="marker-59532"></A>Tk toolkit is needed to view the images. Additionally, either the Python interpreter needs to be compiled with <A NAME="marker-59533"></A>thread support (which is true in the standard win32 distribution) or you need to call the NumTut program from the <A NAME="marker-59534"></A>IDLE interactive development environment.</P>
<P CLASS="Body">
<A NAME="pgfId-57100"></A>If you do not wish to modify your Python installation to match these requirements, you can simply ignore the references to the demonstrations which use the <EM CLASS="Code">
view()</EM>
 command later in this document. Using NumPy does not require image display tools, they just make some array operations easier to understand.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-56857"></A>Unix</H6>
<P CLASS="Body">
<A NAME="pgfId-56884"></A>On Unix machines, NumTut will work best with a Python interpreter with Tk support (not true in the default configuration), with the Tkinter GUI framework available and optionally with the tkImaging add-on (part of the Python Imaging Library). If this is not the case, it will try to use an external viewer which is able to read PPM files. The default viewer is 'xv', a common image viewer available from <EM CLASS="URL">
ftp://ftp.cis.upenn.edu/pub/xv. </EM>
If xv is not installed, you will get an error message similar to:</P>
<P CLASS="Python">
<A NAME="pgfId-57062"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
import NumTut</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57063"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-57064"></A>[...]</P>
<P CLASS="Python">
<A NAME="pgfId-57065"></A>ConfigurationError: PPM image viewer 'xv' not found</P>
<P CLASS="Body">
<A NAME="pgfId-57057"></A>You can configure NumTut to use a different image viewer, by typing e.g.:</P>
<P CLASS="Python">
<A NAME="pgfId-56923"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
import NumTut</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-56927"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
NumTut.view.PPMVIEWER = 'ppmviewer'</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-56943"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
from NumTut import *</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-56947"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(greece)</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-57089"></A>If you do not have a PPM image viewer, you can simply ignore the references to the demonstrations which use the <EM CLASS="Code">
view()</EM>
 command later in this document. Using NumPy does not require image display tools, they just make some array operations easier to understand.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-57136"></A>4.	 <A NAME="70766"></A>High-Level Overview</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-57137"></A>In this chapter, a high-level overview of the extensions is provided, giving the reader the definitions of the key components of the system.  This section defines the concepts used by the remaining sections.</P>
<P CLASS="Body">
<A NAME="pgfId-57138"></A>Numeric Python consists of a set of modules:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-57145"></A><EM CLASS="Code">
Numeric.py</EM>
<A NAME="marker-59536"></A> (and its helper modules <EM CLASS="Code">
multiarray</EM>
 and <EM CLASS="Code">
umath</EM>
.)</LI>
</UL>
<P CLASS="CBullet">
<A NAME="pgfId-57146"></A>This module defines two new object types, and a set of functions which manipulate these objects, as well as convert between them and other Python types.  The objects are the new array object (technically called <EM CLASS="Code">
multiarray</EM>
<A NAME="marker-59537"></A> objects), and <A NAME="marker-59539"></A>universal functions (technically <EM CLASS="Code">
ufunc</EM>
<A NAME="marker-59538"></A> objects).   </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-68164"></A>Other optional packages shipped with Numeric are discussed in <A HREF="numdoc.html#90799" CLASS="XRef">Optional Packages</A>. Among these a packages for linear algebra, random numbers, masked or missing values, and Fast Fourier Transforms.</LI>
</UL>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-57154"></A><A NAME="30538"></A>Array Objects</H6>
<P CLASS="Body">
<A NAME="pgfId-57155"></A>The array objects are generally homogeneous collections of potentially large numbers of numbers.  All numbers in a multiarray are the same kind (i.e. number representation, such as double-precision floating point).  Array objects must be full (no empty cells are allowed), and their size is immutable.  The specific numbers within them can change throughout the life of the array.</P>
<P CLASS="Body">
<A NAME="pgfId-68201"></A>Note: In some applications arrays of numbers may contain entries representing invalid or missing values. An optional package &quot;MA&quot; is available to represent such arrays. <A NAME="marker-68202"></A>Attempting to do so by using NaN as a value may lead to disappointment or lack of portability.</P>
<P CLASS="Body">
<A NAME="pgfId-67507"></A>Mathematical operations on arrays return new arrays containing the results of these operations performed <EM CLASS="Emphasis">
elementwise</EM>
 on the arguments of the operation.</P>
<P CLASS="Body">
<A NAME="pgfId-57156"></A>The <EM CLASS="Emphasis">
size</EM>
 of an array is the total number of elements therein (it can be 0 or more). It does not change throughout the life of the array.</P>
<P CLASS="Body">
<A NAME="pgfId-57157"></A>The <EM CLASS="Emphasis">
shape</EM>
 of an array is the number of dimensions of the array and its extent in each of these dimensions (it can be 0, 1 or more). It can change throughout the life of the array. In Python terms, the shape of an array is a tuple of integers, one integer for each dimension that represents the extent in that dimension.</P>
<P CLASS="Body">
<A NAME="pgfId-57158"></A>The <EM CLASS="Emphasis">
rank</EM>
 of an array is the number of dimensions along which it is defined. It can change throughout the life of the array. Thus, the rank is the length of the shape.</P>
<P CLASS="Body">
<A NAME="pgfId-57159"></A>The <EM CLASS="Emphasis">
typecode</EM>
 of an array is a single character description of the kind of element it contains (number format, character or Python reference). It determines the itemsize of the array.</P>
<P CLASS="Body">
<A NAME="pgfId-57160"></A>The <EM CLASS="Emphasis">
itemsize</EM>
 of an array is the number of 8-bit bytes used to store a single element in the array. The total memory used by an array tends to its size times its itemsize, as the size goes to infinity (there is a fixed overhead per array, as well as a fixed overhead per dimension).</P>
<P CLASS="Body">
<A NAME="pgfId-57161"></A>To put this in more familiar mathematicial language: A vector is a rank-1 array (it has only one dimension along which it can be indexed).  A matrix as used in linear algebra is a rank-2 array (it has two dimensions along which it can be indexed).  There are also rank-0 arrays, which can hold single scalars -- they have no dimension along which they can be indexed, but they contain a single number. </P>
<P CLASS="Body">
<A NAME="pgfId-67522"></A>Here is an example of Python code using the array objects (bold text refers to user input, non-bold text to computer output):</P>
<P CLASS="Python">
<A NAME="pgfId-57163"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
vector1 = array((1,2,3,4,5))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57164"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print vector1</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57165"></A>[1 2 3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-57166"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
matrix1 = array(([0,1],[1,3]))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57167"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print matrix1</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57168"></A>[[0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-57169"></A> [1 3]]</P>
<P CLASS="Python">
<A NAME="pgfId-57170"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print vector1.shape, matrix1.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57171"></A>(5,) (2,2)</P>
<P CLASS="Python">
<A NAME="pgfId-57172"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print vector1 + vector1</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57173"></A>[ 2  4  6  8  10]]</P>
<P CLASS="Python">
<A NAME="pgfId-57174"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print matrix1 * matrix1</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57175"></A>[[0 1]						<EM CLASS="Emphasis">
# note that this is not the matrix </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57176"></A> [1 9]]	<EM CLASS="CodeInput">
						# multiplication of linear algebra</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-67551"></A>If this example does not work for you because it complains of an unknown name &quot;array&quot;, you forgot to begin your session with </P>
<P CLASS="Python">
<A NAME="pgfId-67558"></A><EM CLASS="CodeInput">
from Numeric import *</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-67559"></A>See <A HREF="numdoc.html#fromNumericimportexplanation" CLASS="XRef">Just like all Python modules and packages, the Numeric module can be invoked using either the import Numeric form, or the from Numeric import ... form. Because most of the functions we'll talk about are in the Numeric module, in this document, all of the code samples will assume that they have been preceded by a statement: from Numeric import *</A>.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-57178"></A><A NAME="24371"></A>Universal Functions</H6>
<P CLASS="Body">
<A NAME="pgfId-57179"></A>Universal functions (ufuncs) are functions which operate on arrays and other sequences.  Most ufuncs perform mathematical operations on their arguments, also elementwise.  </P>
<P CLASS="Body">
<A NAME="pgfId-57180"></A>Here is an example of Python code using the ufunc objects:</P>
<P CLASS="Python">
<A NAME="pgfId-67532"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sin([pi/2., pi/4., pi/6.])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-67533"></A>[ 1.        ,  0.70710678,  0.5       ]</P>
<P CLASS="Python">
<A NAME="pgfId-57182"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print greater([1,2,4,5], [5,4,3,2])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57183"></A>[0 0 1 1]</P>
<P CLASS="Python">
<A NAME="pgfId-57184"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add([1,2,4,5], [5,4,3,2])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57185"></A>[6 6 7 7]</P>
<P CLASS="Python">
<A NAME="pgfId-57186"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.reduce([1,2,4,5])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-60950"></A>12									# 1 + 2 + 3 + 4 + 5</P>
<P CLASS="Body">
<A NAME="pgfId-60956"></A>Ufuncs are covered in detail in <A HREF="numdoc.html#30906" CLASS="XRef">Ufuncs</A>. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-60952"></A><A NAME="marker-60951"></A>Convenience Functions</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-60953"></A>The Numeric module provides, in addition to the functions which are needed to create the objects above, a set of powerful functions to manipulate arrays, select subsets of arrays based on the contents of other arrays, and other array-processing operations.</P>
<P CLASS="Python">
<A NAME="pgfId-57192"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
data = arange(10)</EM>
							# convenient homolog of builtin range()</P>
<P CLASS="Python">
<A NAME="pgfId-57193"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print data</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57194"></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P CLASS="Python">
<A NAME="pgfId-57195"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print where(greater(data, 5), -1, data)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57196"></A>[ 0  1  2  3  4  5 -1 -1 -1 -1]									# selection facility</P>
<P CLASS="Python">
<A NAME="pgfId-57197"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
data = resize(array((0,1)), (9, 9))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57198"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print data			</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-57199"></A>[[0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-57200"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-57201"></A> [0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-57202"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-57203"></A> [0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-57204"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-57205"></A> [0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-57206"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-60992"></A> [0 1 0 1 0 1 0 1 0]]</P>
<P CLASS="Body">
<A NAME="pgfId-60993"></A>All of the functions which operate on NumPy arrays are described in <A HREF="numdoc.html#28351" CLASS="XRef">Array Functions</A>.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-57315"></A>5.	 <A NAME="82200"></A>Array Basics</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-35604"></A>This chapter introduces some of the basic functions which will be used throughout the text.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-37311"></A>Basics</H6>
<P CLASS="Body">
<A NAME="pgfId-37312"></A>Before we explore the world of image manipulation as a case-study in array manipulation, we should first define a few terms which we'll use over and over again. Discussions of arrays and matrices and vectors can get confusing due to disagreements on the nomenclature. Here is a brief definition of the terms used in this tutorial, and more or less consistently in the error messages of NumPy.</P>
<P CLASS="Body">
<A NAME="pgfId-37313"></A>The python objects under discussion are formally called &quot;<A NAME="marker-59540"></A>multiarray&quot; objects, but informally we'll just call them &quot;array&quot; objects or just &quot;arrays.&quot; These are different from the array objects defined in the standard Python <EM CLASS="Code">
array</EM>
 module (which is an older module designed for processing one-dimensional data such as sound files). </P>
<P CLASS="Body">
<A NAME="pgfId-37314"></A>These array objects hold their data in a <A NAME="marker-59541"></A>homogeneous block of elements, i.e. their elements all have the same C type (such as a 64-bit floating-point number). This is quite different from most Python container objects, which can contain heterogeneous collections. (You can, however, have an array of Python objects, as discussed later).</P>
<P CLASS="Body">
<A NAME="pgfId-37318"></A>Any given array object has a <A NAME="marker-59542"></A>rank, which is the number of &quot;<A NAME="marker-59543"></A>dimensions&quot; or &quot;<A NAME="marker-59544"></A>axes&quot; it has. For example, a point in 3D space [1, 2, 1] is an array of rank 1 - it has one dimension. That dimension has a <EM CLASS="Emphasis">
length</EM>
 of 3. </P>
<P CLASS="Body">
<A NAME="pgfId-37319"></A>As another example, the array </P>
<P CLASS="Python">
<A NAME="pgfId-37320"></A>1.0 0.0 0.0</P>
<P CLASS="Python">
<A NAME="pgfId-37321"></A>0.0 1.0 2.0</P>
<P CLASS="Body">
<A NAME="pgfId-61092"></A>is an array of rank 2 (it is 2-dimensional). The first dimension has a length of 2, the second dimension has a length of 3. Because the word &quot;dimension&quot; has many different meanings to different folks, in general the word &quot;axis&quot; will be used instead. Axes are numbered just like Python list indices: they start at 0, and can also be counted from the end, so that axis -1 is the last axis of an array, axis -2 is the penultimate axis, etc. </P>
<P CLASS="Body">
<A NAME="pgfId-61093"></A>There are two important and potentially unintuitive behaviors of NumPy arrays which take some getting used to. The first is that by default, operations on arrays are performed <A NAME="marker-61094"></A>element-wise. This means that when adding two arrays, the resulting array has as elements the pairwise sums of the two operand arrays. This is true for all operations, including multiplication. Thus, array multiplication using the * operator will default to element-wise multiplication, not matrix multiplication as used in linear algebra. Many people will want to use arrays as linear algebra-type matrices (including their rank-1 versions, vectors). For those users, the Matrix class provides a more intuitive interface. We defer discussion of the Matrix class until later. </P>
<P CLASS="Body">
<A NAME="pgfId-67591"></A>The second behavior which will catch many users by surprise is that functions which return arrays which are simply different views at the same data will in fact share their data. This will be discussed at length when we have more concrete examples of what exactly this means.</P>
<P CLASS="Body">
<A NAME="pgfId-37324"></A>Now that all of these definitions and warnings are laid out, let's see what we can do with these arrays. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-35605"></A>Creating arrays from scratch</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35606"></A><A NAME="marker-59546"></A>array() and <A NAME="marker-59547"></A>typecodes</H6>
<P CLASS="Body">
<A NAME="pgfId-35607"></A>There are many ways to create arrays. The most basic one is the use of the <EM CLASS="Code">
array()</EM>
 function: </P>
<P CLASS="Python">
<A NAME="pgfId-35608"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1.2, 3.5, -1])</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-35609"></A>to make sure this worked, do: </P>
<P CLASS="Python">
<A NAME="pgfId-35610"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35611"></A>[ 1.2  3.5 -1. ]</P>
<P CLASS="Body">
<A NAME="pgfId-35615"></A>The <EM CLASS="Code">
array(numbers, typecode=None, savespace=0) </EM>
function takes three arguments - the first one is the values, which have to be in a Python sequence object (such as a list or a tuple). The optional second argument is the typecode of the elements. If it is omitted, as in the example above, Python tries to find the one type which can represent all the elements. The third is discussed in <A HREF="numdoc.html#29152" CLASS="XRef">Saving space</A>. </P>
<P CLASS="Body">
<A NAME="pgfId-68273"></A>Since the elements we gave our example were two floats and one integer, it chose `float' as the type of the resulting array. If one specifies the typecode, one can specify unequivocally the type of the elements - this is especially useful when, for example, one wants to make sure that an array contains floats even though in some cases all of its elements are integers: </P>
<P CLASS="Python">
<A NAME="pgfId-35616"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x,y,z = 1,2,3</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35617"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([x,y,z])	</EM>
# integers are enough for 1, 2 and 3</P>
<P CLASS="Python">
<A NAME="pgfId-35618"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35619"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35620"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([x,y,z], Float) 	</EM>
# not the default type</P>
<P CLASS="Python">
<A NAME="pgfId-35621"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35622"></A>[ 1.  2.  3.]</P>
<DIV>
<H6 CLASS="NoteTip">
<A NAME="pgfId-85572"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Note">
<A NAME="pgfId-85579"></A>Pop Quiz:	 What will be the type of an array defined as follows:<BR>
</P>
<P CLASS="PythonNote">
<A NAME="pgfId-61028"></A><EM CLASS="Code">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
mystery = array([1, 2.0, -3j])</EM>
</P>
<P CLASS="PythonNote">
<A NAME="pgfId-84465"></A>&nbsp;</P>
<P CLASS="Note">
<A NAME="pgfId-61029"></A>Hint: <EM CLASS="Code">
-3j</EM>
 is an imaginary number.</P>
<P CLASS="Note">
<A NAME="pgfId-61032"></A><A NAME="marker-84325"></A>Answer: complex</P>
<P CLASS="Note">
<A NAME="pgfId-61047"></A>A very common mistake is to call array with a set of numbers as arguments, as in <EM CLASS="Code">
array(1,2,3,4,5)</EM>
. This doesn't produce the expected result as soon as at least two numbers are used, because the first argument to <EM CLASS="Code">
array()</EM>
 must be the entire data for the array -- thus, in most cases, a sequence of numbers.  The correct way to write the preceding invocation is most likely <EM CLASS="Code">
array((1,2,3,4,5))</EM>
.</P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-84466"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Body">
<A NAME="pgfId-35625"></A>Possible values for the second argument to the <EM CLASS="Code">
array</EM>
 creator function (and indeed to any function which accepts a so-called typecode for arrays) are: </P>
<OL>
<LI CLASS="Step">
<A NAME="pgfId-35626"></A>One type corresponding to single ASCII characters: <EM CLASS="Code">
Character</EM>
<A NAME="marker-59548"></A>.</LI>
<LI CLASS="Step">
<A NAME="pgfId-35627"></A>One unsigned numeric type: <EM CLASS="Code">
UnsignedInt8</EM>
<A NAME="marker-59549"></A>, used to store numbers between 0 and 255.</LI>
<LI CLASS="Step">
<A NAME="pgfId-35628"></A>Many signed numeric types:</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-59564"></A>Signed integer choices: <EM CLASS="Code">
Int</EM>
<A NAME="marker-59558"></A>, <EM CLASS="Code">
Int0</EM>
<A NAME="marker-59559"></A>, <EM CLASS="Code">
Int8</EM>
<A NAME="marker-59560"></A>, <EM CLASS="Code">
Int16</EM>
<A NAME="marker-59561"></A>, <EM CLASS="Code">
Int32</EM>
<A NAME="marker-59562"></A>, and on some platforms, <EM CLASS="Code">
Int64</EM>
<A NAME="marker-59563"></A> and <EM CLASS="Code">
Int128</EM>
<A NAME="marker-59565"></A> (their ranges depend on their size).</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-59567"></A>Floating point choices: <EM CLASS="Code">
Float</EM>
<A NAME="marker-59566"></A>, <EM CLASS="Code">
Float0</EM>
<A NAME="marker-59570"></A>, <EM CLASS="Code">
Float8</EM>
<A NAME="marker-59571"></A>, <EM CLASS="Code">
Float16</EM>
<A NAME="marker-59572"></A>, <EM CLASS="Code">
Float32</EM>
<A NAME="marker-59573"></A>, <EM CLASS="Code">
Float64</EM>
<A NAME="marker-59574"></A>, and on some platforms, <EM CLASS="Code">
Float128</EM>
<A NAME="marker-59575"></A>.</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-35631"></A>Complex number choices: <EM CLASS="Code">
Complex</EM>
<A NAME="marker-59576"></A>, <EM CLASS="Code">
Complex0</EM>
<A NAME="marker-59577"></A>, <EM CLASS="Code">
Complex8</EM>
<A NAME="marker-59578"></A>, <EM CLASS="Code">
Complex16</EM>
<A NAME="marker-59579"></A>, <EM CLASS="Code">
Complex32</EM>
<A NAME="marker-59580"></A>, <EM CLASS="Code">
Complex64</EM>
<A NAME="marker-59581"></A>, <EM CLASS="Code">
Complex128</EM>
<A NAME="marker-59582"></A>.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-35632"></A>The meaning of these is as follows:</P>
<UL>
<LI CLASS="BulletLev2">
<A NAME="pgfId-35633"></A>The versions without any numbers (<EM CLASS="Code">
Int</EM>
, <EM CLASS="Code">
Float</EM>
, <EM CLASS="Code">
Complex</EM>
) correspond to the <EM CLASS="Code">
int</EM>
, <EM CLASS="Code">
float</EM>
 and <EM CLASS="Code">
complex</EM>
 datatypes in Python.  They are thus long integers and double-precision floating point numbers, with a complex number corresponding to two double-precision floats.</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-35634"></A>The versions with a number following correspond to whatever words are available on the specific platform you are using which have <EM CLASS="Emphasis">
at least</EM>
 that many bits in them.  Thus, <EM CLASS="Code">
Int0</EM>
 corresponds to the smallest integer word size available, <EM CLASS="Code">
Int8</EM>
 corresponds to the smallest integer word size available which has at least 8 bits, etc.  The word sizes for the complex numbers refer to the total number of bits used by both the real and imaginary parts (in other words, the data portion of an array of N <EM CLASS="Code">
Complex128</EM>
 elements uses up the same amount of memory as the data portions of two arrays of typecode  <EM CLASS="Code">
Float64</EM>
 with 2N elements).</LI>
<LI CLASS="Step">
<A NAME="pgfId-35635"></A>One non-numeric type, <EM CLASS="Code">
PyObject</EM>
<A NAME="marker-59583"></A>.  Arrays of typecode <EM CLASS="Code">
PyObject</EM>
 are arrays of Python references, and as such their data area can contain references to any kind of Python objects.</LI>
</UL>
<P CLASS="FirstBody">
<A NAME="pgfId-35636"></A>The last typecode deserves a little comment. Indeed, it seems to indicate that arrays can be filled with any Python objects. This appears to violate the notion that arrays are homogeneous. In fact, the typecode <EM CLASS="Code">
PyObject</EM>
 does allow heterogeneous arrays. However, if you plan to do numerical computation, you're much better off with a homogeneous array with a potentially &quot;large&quot; type than with a heterogeneous array. This is because a heterogeneous array stores references to objects, which incurs a memory cost, and because the speed of computation is much slower with arrays of <EM CLASS="Code">
PyObject</EM>
's than with uniform number arrays. Why does it exist, then? </P>
<P CLASS="Body">
<A NAME="pgfId-68287"></A>A very useful features of arrays is the ability to slice them, dice them, select and choose from them, etc. This feature is so nice that sometimes one wants to do the same operations with, e.g., arrays of class instances. In such cases, computation speed is not as important as convenience. Also, if the array is filled with objects which are instances of classes which define the appropriate methods, then NumPy will let you do math with those objects. For example, if one creates an object class which has an <EM CLASS="Code">
__add__</EM>
 method, then arrays (created with the <EM CLASS="Code">
PyObject</EM>
 typecode) of instances of such a class can be added together. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35637"></A>Multidimensional Arrays</H6>
<P CLASS="Body">
<A NAME="pgfId-35638"></A>The following example shows one way of creating multidimensional arrays: </P>
<P CLASS="Python">
<A NAME="pgfId-35639"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
ma = array([[1,2,3],[4,5,6]])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35640"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print ma</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35641"></A>[[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35642"></A> [4 5 6]]</P>
<P CLASS="Body">
<A NAME="pgfId-35643"></A>The first argument to <EM CLASS="Code">
array()</EM>
 in the code above is a single list containing two lists, each containing three elements. If we wanted floats instead, we could specify, as discussed in the previous section, the optional typecode we wished: </P>
<P CLASS="Python">
<A NAME="pgfId-35644"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
ma_floats = array([[1,2,3],[4,5,6]], Float)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35645"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print ma_floats</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35646"></A>[[ 1.  2.  3.]</P>
<P CLASS="Python">
<A NAME="pgfId-35647"></A> [ 4.  5.  6.]]</P>
<P CLASS="Body">
<A NAME="pgfId-35648"></A>This array allows us to introduce the notion of `shape'. The shape of an array is the set of numbers which define its dimensions. The shape of the array <EM CLASS="Code">
ma</EM>
 defined above is 2 by 3.  More precisely, all arrays have a shape attribute which is a tuple of integers.  So, in this case: </P>
<P CLASS="Python">
<A NAME="pgfId-35649"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print ma.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35650"></A>(2, 3)</P>
<P CLASS="Body">
<A NAME="pgfId-35651"></A>Using the earlier definitions, this is a shape of rank 2, where the first axis has length 2, and the seond axis has length 3. The rank of an array <EM CLASS="Code">
A</EM>
 is always equal to <EM CLASS="Code">
len(A.shape)</EM>
. </P>
<P CLASS="Body">
<A NAME="pgfId-35652"></A>Note that <EM CLASS="Code">
shape</EM>
 is an <EM CLASS="Emphasis">
attribute</EM>
 of  <EM CLASS="Code">
array</EM>
 objects. It is the first of several which we will see throughout this tutorial. If you're not used to object-oriented programming, you can think of attributes as  &quot;features&quot; or &quot;qualities&quot; of individual arrays. The relation between an array and its shape is similar to the relation between a person and their hair color. In Python, it's called an object/attribute relation. </P>
<P CLASS="Body">
<A NAME="pgfId-35653"></A>What if one wants to change the dimensions of an array? For now, let us consider changing the shape of an array without making it &quot;grow.&quot; Say, for example, we want to make the 2x3 array defined above (<EM CLASS="Code">
ma</EM>
) an array of rank 1: </P>
<P CLASS="Python">
<A NAME="pgfId-35654"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
flattened_ma = reshape(ma, (6,))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35655"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print flattened_ma</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35656"></A>[1 2 3 4 5 6]</P>
<P CLASS="Body">
<A NAME="pgfId-35657"></A>One can change the shape of arrays to any shape as long as the product of all the lengths of all the axes is kept constant (in other words, as long as the number of elements in the array doesn't change): </P>
<P CLASS="Python">
<A NAME="pgfId-35658"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1,2,3,4,5,6,7,8])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35659"></A>[1 2 3 4 5 6 7 8]</P>
<P CLASS="Python">
<A NAME="pgfId-35660"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35661"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = reshape(a, (2,4))	</EM>
# 2*4 == 8</P>
<P CLASS="Python">
<A NAME="pgfId-35662"></A>[[1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-35663"></A> [5 6 7 8]]</P>
<P CLASS="Python">
<A NAME="pgfId-35664"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35665"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
c = reshape(b, (4,2)	</EM>
# 4*2 == 8 </P>
<P CLASS="Python">
<A NAME="pgfId-35666"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print c</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35667"></A>[[1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-35668"></A> [3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-35669"></A> [5 6]</P>
<P CLASS="Python">
<A NAME="pgfId-35670"></A> [7 8]]</P>
<P CLASS="Body">
<A NAME="pgfId-35671"></A>Notice that we used a new function, <EM CLASS="Code">
reshape()</EM>
<A NAME="marker-59584"></A>. It, like <EM CLASS="Code">
array()</EM>
, is a function defined in the <EM CLASS="Code">
Numeric</EM>
 module. It expects an array as its first argument, and a shape as its second argument. The shape has to be a sequence of integers (a list or a tuple). Keep in mind that a tuple with a single element needs a comma at the end; the right shape tuple for a rank-1 array with 5 elements is <EM CLASS="Code">
(5,)</EM>
, not <EM CLASS="Code">
(5)</EM>
. </P>
<P CLASS="Body">
<A NAME="pgfId-35672"></A>One nice feature of shape tuples is that one entry in the shape tuple is allowed to be <EM CLASS="Code">
-1</EM>
.  The <EM CLASS="Code">
-1</EM>
 will be automatically replaced by whatever number is needed to build a shape which does not change the size of the array. Thus: </P>
<P CLASS="Python">
<A NAME="pgfId-35673"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = reshape(array(range(25)), (5,-1))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35674"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a, a.shape </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35675"></A>[[ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-35676"></A> [ 5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-35677"></A> [10 11 12 13 14]</P>
<P CLASS="Python">
<A NAME="pgfId-35678"></A> [15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-35679"></A> [20 21 22 23 24]] (5, 5)</P>
<P CLASS="Body">
<A NAME="pgfId-35680"></A>The shape of an array is a modifiable attribute of the array. You can therefore change the shape of an array simply by assigning a new shape to it: </P>
<P CLASS="Python">
<A NAME="pgfId-35681"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1,2,3,4,5,6,7,8,9,10]) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35682"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35683"></A>(10,) </P>
<P CLASS="Python">
<A NAME="pgfId-35684"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (2,5) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35685"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35686"></A>[[ 1  2  3  4  5]</P>
<P CLASS="Python">
<A NAME="pgfId-35687"></A> [ 6  7  8  9 10]]</P>
<P CLASS="Python">
<A NAME="pgfId-35688"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (10,1)	</EM>
	# second axis has length 1</P>
<P CLASS="Python">
<A NAME="pgfId-35689"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35690"></A>[[ 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35691"></A> [ 2]</P>
<P CLASS="Python">
<A NAME="pgfId-35692"></A> [ 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35693"></A> [ 4]</P>
<P CLASS="Python">
<A NAME="pgfId-35694"></A> [ 5]</P>
<P CLASS="Python">
<A NAME="pgfId-35695"></A> [ 6]</P>
<P CLASS="Python">
<A NAME="pgfId-35696"></A> [ 7]</P>
<P CLASS="Python">
<A NAME="pgfId-35697"></A> [ 8]</P>
<P CLASS="Python">
<A NAME="pgfId-35698"></A> [ 9]</P>
<P CLASS="Python">
<A NAME="pgfId-35699"></A> [10]]</P>
<P CLASS="Python">
<A NAME="pgfId-35700"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (5,-1)	</EM>
# note the -1 trick described above</P>
<P CLASS="Python">
<A NAME="pgfId-35701"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35702"></A>[[ 1  2]</P>
<P CLASS="Python">
<A NAME="pgfId-35703"></A> [ 3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-35704"></A> [ 5  6]</P>
<P CLASS="Python">
<A NAME="pgfId-35705"></A> [ 7  8]</P>
<P CLASS="Python">
<A NAME="pgfId-35706"></A> [ 9 10]]</P>
<P CLASS="Body">
<A NAME="pgfId-35707"></A>As in the rest of Python, violating rules (such as the one about which shapes are allowed) results in exceptions:</P>
<P CLASS="Python">
<A NAME="pgfId-35708"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (6,-1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35709"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-35710"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-35711"></A>ValueError: total size of new array must be unchanged</P>
<DIV>
<H6 CLASS="MoreTip">
<A NAME="pgfId-35713"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Note">
<A NAME="pgfId-61102"></A>The default printing routine provided by the Numeric module prints arrays as follows:</P>
<OL>
<LI CLASS="NoteEnum">
<A NAME="pgfId-35714"></A>The last axis is always printed left to right</LI>
<LI CLASS="NoteEnum">
<A NAME="pgfId-35715"></A>The next-to-last axis is printed top to bottom</LI>
</OL>
<P CLASS="Note">
<A NAME="pgfId-35716"></A>The remaining axes are printed top to bottom with increasing numbers of separators.</P>
<P CLASS="Note">
<A NAME="pgfId-35717"></A>This explains why rank-1 arrays are printed from left to right, rank-2 arrays have the first dimension going down the screen and the second dimension going from left to right, etc. </P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-85613"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Body">
<A NAME="pgfId-35718"></A>If you want to change the shape of an array so that it has more elements than it started with (i.e. grow it), then you have many options: One solution is to use the <EM CLASS="Code">
concat()</EM>
 method discussed later. An alternative is to use the <EM CLASS="Code">
array()</EM>
 creator function with existing arrays as arguments: </P>
<P CLASS="Python">
<A NAME="pgfId-35719"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35720"></A>[0 1 2 3 4 5 6 6 7]</P>
<P CLASS="Python">
<A NAME="pgfId-35721"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = array([a,a]) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35722"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35723"></A>[[1 2 3 4 5 6 7 8]</P>
<P CLASS="Python">
<A NAME="pgfId-35724"></A> [1 2 3 4 5 6 7 8]] </P>
<P CLASS="Python">
<A NAME="pgfId-35725"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35726"></A>(2, 8) </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-68290"></A>resize</H6>
<P CLASS="Body">
<A NAME="pgfId-65778"></A>A final possibility is the <EM CLASS="Code">
resize()</EM>
<A NAME="marker-59585"></A>function, which takes a &quot;base&quot; array as its first argument and the desired shape as the second argument. Unlike <EM CLASS="Code">
reshape()</EM>
, the shape argument to <EM CLASS="Code">
resize()</EM>
 can corresponds to a smaller or larger shape than the input array.  Smaller shapes will result in arrays with the data at the &quot;beginning&quot; of the input array, and larger shapes result in arrays with data containing as many replications of the input array as are needed to fill the shape. For example, starting with a simple array</P>
<P CLASS="Python">
<A NAME="pgfId-35728"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
base = array([0,1])</EM>
 </P>
<P CLASS="Body">
<A NAME="pgfId-35729"></A>one can quickly build a large array with replicated data: </P>
<P CLASS="Python">
<A NAME="pgfId-35730"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
big = resize(base, (9,9)) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35731"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print big</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35732"></A>[[0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35733"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35734"></A> [0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35735"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35736"></A> [0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35737"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35738"></A> [0 1 0 1 0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35739"></A> [1 0 1 0 1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35740"></A> [0 1 0 1 0 1 0 1 0]]</P>
<P CLASS="Body">
<A NAME="pgfId-35741"></A>and if you imported the <EM CLASS="Code">
view</EM>
 function from the <EM CLASS="Code">
NumTut</EM>
 package, you can do:</P>
<P CLASS="Python">
<A NAME="pgfId-35742"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(resize(base, (100,100)))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35743"></A><EM CLASS="Emphasis">
# grey grid of horizontal lines is shown</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59939"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(resize(base, (101,101)))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59947"></A><EM CLASS="Emphasis">
# grey grid of alternating black and white pixels is shown</EM>
</P>
<DIV>
<H6 CLASS="MoreTip">
<A NAME="pgfId-60322"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Note">
<A NAME="pgfId-60323"></A>Sections denoted &quot;For Advanced Users&quot; will be used to indicate aspects of the functions which may not be needed for a first introduction at NumPy, but which should be mentioned for the sake of completeness.</P>
<P CLASS="Note">
<A NAME="pgfId-60338"></A>The <EM CLASS="Code">
array</EM>
 constructor takes a mandatory <EM CLASS="Code">
data</EM>
 argument, an optional typecode, and optional <EM CLASS="Code">
savespace</EM>
 argument, and an optional <EM CLASS="Code">
copy</EM>
 argument.  If the <EM CLASS="Code">
data</EM>
 argument is a sequence, then array creates a new object of type multiarray, and fills the array with the elements of the <EM CLASS="Code">
data</EM>
 object. The shape of the array is determined by the size and nesting arrangement of the elements of data.</P>
<P CLASS="Note">
<A NAME="pgfId-60301"></A>If <EM CLASS="Code">
data</EM>
 is not a sequence, then the array returned is an array of shape <EM CLASS="Code">
()</EM>
 (the empty tuple), of typecode <EM CLASS="Code">
'O'</EM>
, containing a single element, which is <EM CLASS="Code">
data</EM>
.</P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-85628"></A></h6>
<DIV>
</DIV>
&nbsp;
</DIV>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-60291"></A>Creating arrays with values specified `on-the-fly' </H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-60120"></A><A NAME="marker-60118"></A>zeros() and <A NAME="marker-60119"></A>ones() </H6>
<P CLASS="Body">
<A NAME="pgfId-35748"></A>Often, one needs to manipulate arrays filled with numbers which aren't available beforehand. The Numeric module provides a few functions which create arrays from scratch: </P>
<P CLASS="Body">
<A NAME="pgfId-35749"></A><EM CLASS="Code">
zeros()</EM>
 and <EM CLASS="Code">
ones()</EM>
 simply create arrays of a given shape filled with zeros and ones respectively: </P>
<P CLASS="Python">
<A NAME="pgfId-35750"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
z = zeros((3,3))</EM>
 </P>
<P CLASS="Python">
<A NAME="pgfId-35751"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print z</EM>
 </P>
<P CLASS="Python">
<A NAME="pgfId-35752"></A>[[0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35753"></A> [0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35754"></A> [0 0 0]]</P>
<P CLASS="Python">
<A NAME="pgfId-35755"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
o = ones([2,3])</EM>
 </P>
<P CLASS="Python">
<A NAME="pgfId-35756"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print o</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35757"></A>[[1 1 1]</P>
<P CLASS="Python">
<A NAME="pgfId-35758"></A> [1 1 1]]</P>
<P CLASS="Body">
<A NAME="pgfId-35759"></A>Note that the first argument is a shape - it needs to be a list or a tuple of integers. Also note that the default type for the returned arrays is <EM CLASS="Code">
Int</EM>
, which you can feel free to override using something like: </P>
<P CLASS="Python">
<A NAME="pgfId-35760"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
o = ones((2,3), Float)</EM>
 </P>
<P CLASS="Python">
<A NAME="pgfId-35761"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print o</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35762"></A>[[ 1.  1.  1.]</P>
<P CLASS="Python">
<A NAME="pgfId-35763"></A> [ 1.  1.  1.]]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35764"></A><A NAME="marker-59594"></A>arrayrange() </H6>
<P CLASS="Body">
<A NAME="pgfId-35765"></A>The <EM CLASS="Code">
arrayrange()</EM>
 function is similar to the <EM CLASS="Code">
range()</EM>
 function in Python, except that it returns an array as opposed to a list. </P>
<P CLASS="Python">
<A NAME="pgfId-35766"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
r = arrayrange(10) </EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35767"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print r</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35768"></A>[0 1 2 3 4 5 6 7 8 9] </P>
<P CLASS="Body">
<A NAME="pgfId-35769"></A>Combining the <EM CLASS="Code">
arrayrange()</EM>
 with the <EM CLASS="Code">
reshape()</EM>
 function, we can get: </P>
<P CLASS="Python">
<A NAME="pgfId-35770"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
big = reshape(arrayrange(100),(10,10))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35771"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print big<BR>
</EM>
[[ 0  1  2  3  4  5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-35772"></A> [10 11 12 13 14 15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-35773"></A> [20 21 22 23 24 25 26 27 28 29]</P>
<P CLASS="Python">
<A NAME="pgfId-35774"></A> [30 31 32 33 34 35 36 37 38 39]</P>
<P CLASS="Python">
<A NAME="pgfId-35775"></A> [40 41 42 43 44 45 46 47 48 49]</P>
<P CLASS="Python">
<A NAME="pgfId-35776"></A> [50 51 52 53 54 55 56 57 58 59]</P>
<P CLASS="Python">
<A NAME="pgfId-35777"></A> [60 61 62 63 64 65 66 67 68 69]</P>
<P CLASS="Python">
<A NAME="pgfId-35778"></A> [70 71 72 73 74 75 76 77 78 79]</P>
<P CLASS="Python">
<A NAME="pgfId-35779"></A> [80 81 82 83 84 85 86 87 88 89]</P>
<P CLASS="Python">
<A NAME="pgfId-35780"></A> [90 91 92 93 94 95 96 97 98 99]]</P>
<P CLASS="Python">
<A NAME="pgfId-35781"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(reshape(arrayrange(10000),(100,100)))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35782"></A><EM CLASS="Emphasis">
# array of increasing lightness from top down (slowly) and from left to</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35783"></A><EM CLASS="Emphasis">
# right (faster) is shown</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-35784"></A><EM CLASS="Code">
arange()</EM>
 is a shorthand for <EM CLASS="Code">
arrayrange()</EM>
.  </P>
<P CLASS="Body">
<A NAME="pgfId-35785"></A>One can set the start, stop and step arguments, which allows for more varied ranges: </P>
<P CLASS="Python">
<A NAME="pgfId-35786"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print arrayrange(10,-10,-2)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35787"></A>[10  8  6  4  2  0  -2  -4  -6  -8]</P>
<P CLASS="Body">
<A NAME="pgfId-35788"></A>An important feature of arrayrange is that it can be used with non-integer starting points and strides:</P>
<P CLASS="Python">
<A NAME="pgfId-35789"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print arrayrange(5.0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35790"></A>[ 0. 1. 2. 3. 4.]</P>
<P CLASS="Python">
<A NAME="pgfId-35791"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print arrayrange(0, 1, .2)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35792"></A>[ 0.   0.2  0.4  0.6  0.8]</P>
<P CLASS="Body">
<A NAME="pgfId-60244"></A>If you want to create an array with just one value, repeated over and over, you can use the * operator applied to lists </P>
<P CLASS="Python">
<A NAME="pgfId-60245"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([[3]*5]*5)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-60246"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35796"></A>[[3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35797"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35798"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35799"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35800"></A> [3 3 3 3 3]]</P>
<P CLASS="Body">
<A NAME="pgfId-35801"></A>but that is relatively slow, since the duplication is done on Python lists. A quicker way would be to start with 0's and add 3: </P>
<P CLASS="Python">
<A NAME="pgfId-35802"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = zeros([5,5]) + 3</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35803"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35804"></A>[[3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35805"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35806"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35807"></A> [3 3 3 3 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35808"></A> [3 3 3 3 3]]</P>
<P CLASS="FirstBody">
<A NAME="pgfId-66497"></A>The optional typecode argument can force the typecode of the resulting array, which is otherwise the &quot;highest&quot; of the starting and stopping arguments. The starting argument defaults to 0 if not specified. Note that if a typecode is specified which is &quot;lower&quot; than that which arrayrange would normally use, the array is the result of a precision-losing cast (a round-down, as that used in the <EM CLASS="Code">
astype</EM>
 method for arrays.)</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35809"></A>Creating an array from a function: <A NAME="marker-59598"></A>fromfunction()</H6>
<P CLASS="Body">
<A NAME="pgfId-35810"></A>Finally, one may want to create an array with contents which are the result of a function evaluation. This is done using the <EM CLASS="Code">
fromfunction()</EM>
 function, which takes two arguments, a shape and a callable object (usually a function).  For example: </P>
<P CLASS="Python">
<A NAME="pgfId-35811"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
def dist(x,y):</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35812"></A>... <EM CLASS="CodeInput">
  return (x-5)**2+(y-5)**2	</EM>
# distance from point (5,5) squared</P>
<P CLASS="Python">
<A NAME="pgfId-35813"></A>...</P>
<P CLASS="Python">
<A NAME="pgfId-35814"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
m = fromfunction(dist, (10,10))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35815"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print m</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35816"></A>[[50 41 34 29 26 25 26 29 34 41]</P>
<P CLASS="Python">
<A NAME="pgfId-35817"></A> [41 32 25 20 17 16 17 20 25 32]</P>
<P CLASS="Python">
<A NAME="pgfId-35818"></A> [34 25 18 13 10  9 10 13 18 25]</P>
<P CLASS="Python">
<A NAME="pgfId-35819"></A> [29 20 13  8  5  4  5  8 13 20]</P>
<P CLASS="Python">
<A NAME="pgfId-35820"></A> [26 17 10  5  2  1  2  5 10 17]</P>
<P CLASS="Python">
<A NAME="pgfId-35821"></A> [25 16  9  4  1  0  1  4  9 16]</P>
<P CLASS="Python">
<A NAME="pgfId-35822"></A> [26 17 10  5  2  1  2  5 10 17]</P>
<P CLASS="Python">
<A NAME="pgfId-35823"></A> [29 20 13  8  5  4  5  8 13 20]</P>
<P CLASS="Python">
<A NAME="pgfId-35824"></A> [34 25 18 13 10  9 10 13 18 25]</P>
<P CLASS="Python">
<A NAME="pgfId-35825"></A> [41 32 25 20 17 16 17 20 25 32]]</P>
<P CLASS="Python">
<A NAME="pgfId-35826"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(fromfunction(dist, (100,100))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35827"></A><EM CLASS="Emphasis">
# shows image which is dark in topleft corner, and lighter away from it.</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35828"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
m = fromfunction(lambda i,j,k: 100*(i+1)+10*(j+1)+(k+1), (4,2,3))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35829"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print m</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35830"></A>[[[111 112 113]</P>
<P CLASS="Python">
<A NAME="pgfId-35831"></A>  [121 122 123]]</P>
<P CLASS="Python">
<A NAME="pgfId-35832"></A> [[211 212 213]</P>
<P CLASS="Python">
<A NAME="pgfId-35833"></A>  [221 222 223]]</P>
<P CLASS="Python">
<A NAME="pgfId-35834"></A> [[311 312 313]</P>
<P CLASS="Python">
<A NAME="pgfId-35835"></A>  [321 322 323]]</P>
<P CLASS="Python">
<A NAME="pgfId-35836"></A> [[411 412 413]</P>
<P CLASS="Python">
<A NAME="pgfId-35837"></A>  [421 422 423]]]</P>
<P CLASS="Body">
<A NAME="pgfId-35838"></A>By examining the above examples, one can see that <EM CLASS="Code">
fromfunction()</EM>
 creates an array of the shape specified by its second argument, and with the contents corresponding to the value of the function argument (the first argument) evaluated at the indices of the array.  Thus the value of <EM CLASS="Code">
m[3,4]</EM>
 in the first example above is the value of <EM CLASS="Code">
dist</EM>
 when <EM CLASS="Code">
x=3</EM>
 and <EM CLASS="Code">
y=4</EM>
.  Similarly for the lambda function in the second example, but with a rank-3 array.</P>
<P CLASS="Body">
<A NAME="pgfId-66372"></A>The implementation of fromfunction consists of:</P>
<P CLASS="Python">
<A NAME="pgfId-66373"></A>def fromfunction(function, dimensions):</P>
<P CLASS="Python">
<A NAME="pgfId-66374"></A>    return apply(function, tuple(indices(dimensions)))</P>
<P CLASS="Body">
<A NAME="pgfId-66375"></A>which means that the function function is called for each element in the sequence indices(dimensions). As described in the definition of indices, this consists of arrays of indices which will be of rank one less than that specified by dimensions. This means that the function argument must accept the same number of arguments as there are dimensions in dimensions, and that each argument will be an array of the same shape as that specified by dimensions. Furthermore, the array which is passed as the first argument corresponds to the indices of each element in the resulting array along the first axis, that which is passed as the second argument corresponds to the indices of each element in the resulting array along the second axis, etc. A consequence of this is that the function which is used with fromfunction will work as expected only if it performs a separable computation on its arguments, and expects its arguments to be indices along each axis. Thus, no logical operation on the arguments can be performed, or any non-shape preserving operation. The first example below satisfies these requirements, hence works (the <EM CLASS="Code">
x</EM>
 and <EM CLASS="Code">
y</EM>
 arrays both get 10x10 arrays as input corresponding to the values of the indices along the two dimensions), while the second array attemps to do a comparison test on an array of indices, which fails.</P>
<P CLASS="Python">
<A NAME="pgfId-66411"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
def buggy(test):</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66412"></A>...     <EM CLASS="CodeInput">
if test &gt; 4: return 1</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66413"></A>...    <EM CLASS="CodeInput">
 else: return 0</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66414"></A>...</P>
<P CLASS="Python">
<A NAME="pgfId-66415"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print fromfunction(buggy, (10,))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66416"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-66417"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-66418"></A>  File &quot;C:&#92;PYTHON&#92;LIB&#92;Numeric.py&quot;, line 157, in fromfunction</P>
<P CLASS="Python">
<A NAME="pgfId-66419"></A>    return apply(function, tuple(indices(dimensions)))</P>
<P CLASS="Python">
<A NAME="pgfId-66420"></A>  File &quot;&lt;stdin&gt;&quot;, line 2, in buggy</P>
<P CLASS="Python">
<A NAME="pgfId-66421"></A>TypeError: Comparison of multiarray objects is not implemented.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-59602"></A><A NAME="marker-59606"></A>identity()</H6>
<P CLASS="Body">
<A NAME="pgfId-59603"></A>The simplest array constructor is the <EM CLASS="Code">
identity(n)</EM>
 function, which takes a single integer argument and returns a square identity array of that size of integers: </P>
<P CLASS="Python">
<A NAME="pgfId-35844"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print identity(5)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35845"></A>[[1 0 0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35846"></A> [0 1 0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35847"></A> [0 0 1 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35848"></A> [0 0 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-35849"></A> [0 0 0 0 1]]</P>
<P CLASS="Python">
<A NAME="pgfId-35850"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(identity(100))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35851"></A><EM CLASS="Emphasis">
# shows black square with a single white diagonal</EM>
</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-35852"></A><A NAME="marker-59607"></A>Coercion and <A NAME="marker-59608"></A>Casting</H6>
<P CLASS="Body">
<A NAME="pgfId-35853"></A>We've mentioned the typecodes of arrays, and how to create arrays with the right typecode, but we haven't covered what happens when arrays with different typecodes interact.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35854"></A><A NAME="marker-59609"></A>Automatic Coercions and Binary Operations</H6>
<P CLASS="Body">
<A NAME="pgfId-35855"></A>The rules followed by NumPy when performing binary operations on arrays mirror those used by Python in general.  Operations between numeric and non-numeric types are not allowed (e.g. an array of characters can't be added to an array of numbers), and operations between mixed number types (e.g. floats and integers, floats and omplex numbers, or in the case of NumPy, operations between any two arrays with different numeric typecodes) first perform a coercion of the 'smaller' numeric type to the type of the `larger' numeric type.  Finally, when scalars and arrays are operated on together, the scalar is converted to a rank-0 array first. Thus, adding a &quot;small&quot; integer to a &quot;large&quot; floating point array is equivalent to first casting the integer &quot;up&quot; to the typecode of the array:</P>
<P CLASS="Python">
<A NAME="pgfId-35856"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
arange(0, 1.0, .1) + 12</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35857"></A>array([ 12. ,  12.1,  12.2,  12.3,  12.4,  12.5,  12.6,  12.7,  12.8,  12.9])</P>
<P CLASS="Body">
<A NAME="pgfId-35858"></A>The automatic coercions are described in Figure 1. Avoiding upcasting is discussed in <A HREF="numdoc.html#29152" CLASS="XRef">Saving space</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-35862"></A><EM CLASS="Code">
</EM>
&nbsp;</P>
<DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Figure">
<A NAME="pgfId-35863"></A>Up-casts are indicated with arrows.  Down-casts are allowed by the <EM CLASS="Code">
astype()</EM>
 method, but may result in loss of information.</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35864"></A>Deliberate up-casting: The asarray function</H6>
<P CLASS="Body">
<A NAME="pgfId-35865"></A>One more array constructor is the <EM CLASS="Code">
asarray()</EM>
 function. It is used if you want to have an array of a specific typecode and you don't know what typecode array you have (for example, in a generic function which can operate on all kinds of arrays, but needs them to be converted to complex arrays). If the array it gets as an argument is of the right typecode, it will get sent back unchanged. If the array is not of the right typecode, each element of the new array will be the result of the coercion to the new type of the old elements.  <EM CLASS="Code">
asarray()</EM>
 will refuse to operate if there might be loss of information -- in other words, <EM CLASS="Code">
asarray()</EM>
 only casts 'up'. </P>
<P CLASS="Body">
<A NAME="pgfId-35866"></A><EM CLASS="Code">
asarray</EM>
 is also used when you have a function that operates on arrays, but you want to allow people to call it with an arbitrary python sequence object. This gives your function a behavior similar to that of most of the builtin functions that operate on arrays. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35867"></A>The <A NAME="marker-59613"></A>typecode value table</H6>
<P CLASS="Body">
<A NAME="pgfId-35868"></A>The typecodes identifiers (<EM CLASS="Code">
Float0</EM>
, etc.) have as values single-character strings.  The mapping between typecode and character strings is machine dependent.  An example of the correspondences between typecode characters and the typecode identifiers for 32-bit architectures are shown in Table 3-X.</P>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="TableTitle">
<A NAME="pgfId-35871"></A>Typecode character/identifier table on a Pentium computer</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-35879"></A>Character</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-35881"></A># of bytes</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-35883"></A># of bits</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-35885"></A>Identifiers</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35887"></A><EM CLASS="Code">
D</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35889"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35891"></A>128</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35893"></A><EM CLASS="Code">
Complex, Complex64</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35895"></A><EM CLASS="Code">
F</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35897"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35899"></A>64</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35901"></A><EM CLASS="Code">
Complex0, Complex16, Complex32, Complex8</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35903"></A><EM CLASS="Code">
d</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35905"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35907"></A>64</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35909"></A><EM CLASS="Code">
Float, Float64</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35911"></A><EM CLASS="Code">
f</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35913"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35915"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35917"></A><EM CLASS="Code">
Float0, Float16, Float32, Float8</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35919"></A><EM CLASS="Code">
l</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35921"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35923"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35925"></A><EM CLASS="Code">
Int</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35927"></A><EM CLASS="Code">
1</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35929"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35931"></A>8</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35933"></A><EM CLASS="Code">
Int0, Int8</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35935"></A><EM CLASS="Code">
s</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35937"></A>2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35939"></A>16</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35941"></A><EM CLASS="Code">
Int16</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35943"></A><EM CLASS="Code">
i</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35945"></A>4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35947"></A>32</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-35949"></A><EM CLASS="Code">
Int32</EM>
</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35950"></A>Consequences of silent upcasting</H6>
<P CLASS="Body">
<A NAME="pgfId-35951"></A>When dealing with very large arrays of floats and if precision is not important (or arrays of small integers), then it may be worthwhile to cast the arrays to &quot;small&quot; typecodes, such as <EM CLASS="Code">
Int8</EM>
, <EM CLASS="Code">
Int16</EM>
 or <EM CLASS="Code">
Float32</EM>
.  As the standard Python integers and floats correspond to the typecodes <EM CLASS="Code">
Int32</EM>
 and <EM CLASS="Code">
Float64</EM>
, using them in apparently &quot;innocent&quot; ways will result in up-casting, which may null the benefit of the use of small typecode arrays.  For example:</P>
<P CLASS="Python">
<A NAME="pgfId-35952"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray.typecode()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35953"></A>'f'	#  a.k.a. Float32 on a Pentium</P>
<P CLASS="Python">
<A NAME="pgfId-35954"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray.itemsize()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35955"></A>4</P>
<P CLASS="Python">
<A NAME="pgfId-35956"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray = mylargearray + 1</EM>
	# 1 is an Int64 on a Pentium</P>
<P CLASS="Python">
<A NAME="pgfId-35957"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray.typecode()</EM>
	# see Fig. 1 for explanation.</P>
<P CLASS="Python">
<A NAME="pgfId-35958"></A>'d'</P>
<P CLASS="Python">
<A NAME="pgfId-35959"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
mylargearray.itemsize()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35960"></A>8</P>
<P CLASS="Body">
<A NAME="pgfId-35961"></A>Note that the sizes returned by the <EM CLASS="Code">
itemsize()</EM>
 method are expressed in bytes.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-68241"></A><A NAME="29152"></A>Saving space</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-68245"></A>Numeric arrays can be created using an optional, keyworded argument to the constructor, savespace. If savespace is set to 1, Numeric will attempt to avoid the silent upcasting behavior. The status of an array can be queried with the spacesaver() method. If x.spacesaver() is true, x has its space-saving flag set. The flag can be set with the savespace method: x.savespace(1) to set it, x.savespace(0) to clear it.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35975"></A>Deliberate casts (potentially down): the <A NAME="marker-59617"></A>astype method</H6>
<P CLASS="Body">
<A NAME="pgfId-35976"></A>You may also force NumPy to cast any number array to another number array.  For example, to take an array of any numeric type (IntX or FloatX or ComplexX or UnsignedInt8) and convert it to a 64-bit float, one can do:</P>
<P CLASS="Python">
<A NAME="pgfId-35977"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
floatarray = otherarray.astype(Float64)</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-35978"></A>The typecode can be any of the number typecodes, &quot;larger&quot; or &quot;smaller&quot;.  If it is larger, this is a cast-up, as if asarray() had been used.  If it is smaller, the standard casting rules of the underlying language (C) are used, which means that truncation or loss of precision can occur:</P>
<P CLASS="Python">
<A NAME="pgfId-35979"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35980"></A>[ 0.   0.4  0.8  1.2  1.6]</P>
<P CLASS="Python">
<A NAME="pgfId-35981"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x.astype(Int)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35982"></A>array([0, 0, 0, 1, 1])</P>
<P CLASS="Body">
<A NAME="pgfId-35983"></A>If the typecode used with <EM CLASS="Code">
astype()</EM>
 is the original array's typecode, then a copy of the original array is returned.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-35984"></A>Operating on Arrays</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-35985"></A>Simple operations </H6>
<P CLASS="Body">
<A NAME="pgfId-35986"></A>If you have a keen eye, you have noticed that some of the previous examples did something new. It added a number to an array. Indeed, most Python operations applicable to numbers are directly applicable to arrays: </P>
<P CLASS="Python">
<A NAME="pgfId-35987"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35988"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-35989"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a * 3</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35990"></A>[3 6 9]</P>
<P CLASS="Python">
<A NAME="pgfId-35991"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + 3</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35992"></A>[4 5 6]</P>
<P CLASS="Body">
<A NAME="pgfId-35993"></A>Note that the mathematical operators behave differently depending on the types of their operands. When one of the operands is an array and the other is a number, the number is added to all the elements of the array and the resulting array is returned. This is called <EM CLASS="Emphasis">
broadcasting</EM>
. This also occurs for unary mathematical operations such as sin and the negative sign</P>
<P CLASS="Python">
<A NAME="pgfId-35994"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sin(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35995"></A>[ 0.84147098  0.90929743  0.14112001]</P>
<P CLASS="Python">
<A NAME="pgfId-35996"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print -a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-35997"></A>[-1 -2 -3]</P>
<P CLASS="Body">
<A NAME="pgfId-35998"></A>When both elements are arrays with the same shape, then a new array is created, where each element is the sum of the corresponding elements in the original arrays: </P>
<P CLASS="Python">
<A NAME="pgfId-35999"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36000"></A>[2 4 6]</P>
<P CLASS="Body">
<A NAME="pgfId-36001"></A>If the operands of operations such as addition are arrays which have the same rank but different non-integer dimensions, then an exception is generated: </P>
<P CLASS="Python">
<A NAME="pgfId-36002"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36003"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36004"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = array([4,5,6,7])</EM>
	# note this has four elements</P>
<P CLASS="Python">
<A NAME="pgfId-36005"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36006"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-36007"></A>  File ``&lt;stdin&gt;``, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-36008"></A>ArrayError: frames are not aligned</P>
<P CLASS="Body">
<A NAME="pgfId-36009"></A>This is because there is no reasonable way for NumPy to interpret addition of a <EM CLASS="Code">
(3,)</EM>
 shaped array and a <EM CLASS="Code">
(4,) </EM>
shaped array.</P>
<P CLASS="Body">
<A NAME="pgfId-36010"></A>Note what happens  when adding arrays with different rank </P>
<P CLASS="Python">
<A NAME="pgfId-36011"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36012"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36013"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36014"></A>[[ 4  8 12]</P>
<P CLASS="Python">
<A NAME="pgfId-36015"></A> [ 5  9 13]</P>
<P CLASS="Python">
<A NAME="pgfId-36016"></A> [ 6 10 14]</P>
<P CLASS="Python">
<A NAME="pgfId-36017"></A> [ 7 11 15]]</P>
<P CLASS="Python">
<A NAME="pgfId-36018"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36019"></A>[[ 5 10 15]</P>
<P CLASS="Python">
<A NAME="pgfId-36020"></A> [ 6 11 16]</P>
<P CLASS="Python">
<A NAME="pgfId-36021"></A> [ 7 12 17]</P>
<P CLASS="Python">
<A NAME="pgfId-36022"></A> [ 8 13 18]]</P>
<P CLASS="Body">
<A NAME="pgfId-36023"></A>This is another form of broadcasting. To understand this, one needs to look carefully at the shapes of <EM CLASS="Code">
a</EM>
 and <EM CLASS="Code">
b</EM>
: </P>
<P CLASS="Python">
<A NAME="pgfId-36024"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36025"></A>(3,)</P>
<P CLASS="Python">
<A NAME="pgfId-36026"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36027"></A>(4,3)</P>
<P CLASS="Body">
<A NAME="pgfId-36028"></A>Because array <EM CLASS="Code">
a</EM>
's last dimension had length 3 and array <EM CLASS="Code">
b</EM>
's last dimension also had length 3, those two dimensions were &quot;matched&quot; and a new dimension was created and automatically &quot;assumed&quot; for array a.  The data already in <EM CLASS="Code">
a</EM>
 was &quot;replicated&quot; as many times as needed (4, in this case) to make the two shapes of the operand arrays conform.  This replication (broadcasting) occurs when arrays are operands to binary operations and their shapes differ and when the following conditions are true:</P>
<UL>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36029"></A>starting from the last axis, the axis lengths (dimensions) of the operands are compared</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36030"></A>if both arrays have an axis length greater than 1, an exception is raised</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36031"></A>if one array has an axis length greater than 1, then the other array's axis is &quot;stretched&quot; to match the length of the first axis -- if the other array's axis is not present (i.e., if the other array has smaller rank), then a new axis of the same length is created.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-36032"></A>This algorithm is complex, but intuitive in practice.  For more details, consult the Numeric Reference.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-85860"></A>In-place operations</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-85864"></A>Beginning with Python 2.0, Python supports the in-place operators +=, -=, *=, and /=. Numeric supports these operations but you need to be careful. The right-hand side should be of the same typecode. Some violation of this is possible as the following example shows, but in general contortions may be necessary for using the smaller &quot;kinds&quot; of typecodes.</P>
<P CLASS="Python">
<A NAME="pgfId-85870"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85871"></A>array([ 5.,  6.,  7.])</P>
<P CLASS="Python">
<A NAME="pgfId-85872"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; x+= 3.</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85873"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; id(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85874"></A>8253904</P>
<P CLASS="Python">
<A NAME="pgfId-85875"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; y=x.astype(Float32)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85876"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; y+=2</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85877"></A>Traceback (most recent call last):</P>
<P CLASS="Python">
<A NAME="pgfId-85878"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-85879"></A>TypeError: return array has incorrect type</P>
<P CLASS="Python">
<A NAME="pgfId-85880"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; y+=array(2.).astype(Float32)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85881"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; y</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-85882"></A>array([ 10.,  11.,  12.],'f')</P>
<P CLASS="FirstBody">
<A NAME="pgfId-85926"></A>This area clearly needs improvement.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36033"></A><A NAME="marker-59618"></A>Getting and <A NAME="marker-59619"></A>Setting array values</H6>
<P CLASS="Body">
<A NAME="pgfId-36034"></A>Just like other Python sequences, array contents are manipulated with the [] notation. For rank-1 arrays, there are no differences between list and array notations:</P>
<P CLASS="Python">
<A NAME="pgfId-36035"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arrayrange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36036"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0]	</EM>
# get first element</P>
<P CLASS="Python">
<A NAME="pgfId-36037"></A>0</P>
<P CLASS="Python">
<A NAME="pgfId-36038"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[1:5]	</EM>
# get second through fifth element</P>
<P CLASS="Python">
<A NAME="pgfId-36039"></A>[1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36040"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[:-1]	</EM>
# get last element</P>
<P CLASS="Python">
<A NAME="pgfId-36041"></A>9</P>
<P CLASS="Body">
<A NAME="pgfId-36042"></A>The first difference with lists comes with multidimensional indexing.  If an array is multidimensional (of rank &gt; 1), then specifying a single integer index will return an array of dimension one less than the original array. </P>
<P CLASS="Python">
<A NAME="pgfId-36043"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arrayrange(9)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36044"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (3,3)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36045"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36046"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36047"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36048"></A> [6 7 8]]</P>
<P CLASS="Python">
<A NAME="pgfId-36049"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0]	</EM>
# get first row, not first element!</P>
<P CLASS="Python">
<A NAME="pgfId-36050"></A>[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36051"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[1]	</EM>
# get second row</P>
<P CLASS="Python">
<A NAME="pgfId-36052"></A>[3 4 5]</P>
<P CLASS="Body">
<A NAME="pgfId-36053"></A>To get to individual elements in a rank-2 array, one specifies both indices separated by commas:</P>
<P CLASS="Python">
<A NAME="pgfId-36054"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0,0]	</EM>
# get elt at first row, first column</P>
<P CLASS="Python">
<A NAME="pgfId-36055"></A>0</P>
<P CLASS="Python">
<A NAME="pgfId-36056"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0,1]	</EM>
# get elt at first row, second column</P>
<P CLASS="Python">
<A NAME="pgfId-36057"></A>1</P>
<P CLASS="Python">
<A NAME="pgfId-36058"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[1,0]	</EM>
# get elt at second row, first column</P>
<P CLASS="Python">
<A NAME="pgfId-36059"></A>3</P>
<P CLASS="Python">
<A NAME="pgfId-36060"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[2,-1]	</EM>
# get elt at third row, last column</P>
<P CLASS="Python">
<A NAME="pgfId-36061"></A>8</P>
<P CLASS="Body">
<A NAME="pgfId-36062"></A>Of course, the <EM CLASS="Code">
[]</EM>
 notation can be used to <EM CLASS="Emphasis">
set</EM>
 values as well: </P>
<P CLASS="Python">
<A NAME="pgfId-36063"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a[0,0] = 123</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36064"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36065"></A>[[123   1   2]</P>
<P CLASS="Python">
<A NAME="pgfId-36066"></A> [  3   4   5]</P>
<P CLASS="Python">
<A NAME="pgfId-36067"></A> [  6   7   8]]</P>
<P CLASS="Body">
<A NAME="pgfId-36068"></A>Note that when referring to rows, the right hand side of the equal sign needs to be a sequence which &quot;fits&quot; in the referred array subset (in the code sample below, a 3-element row):</P>
<P CLASS="Python">
<A NAME="pgfId-36069"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a[1] = [10,11,12]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36070"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36071"></A>[[123   1   2]</P>
<P CLASS="Python">
<A NAME="pgfId-36072"></A> [ 10  11  12]</P>
<P CLASS="Python">
<A NAME="pgfId-36073"></A> [  6   7   8]]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36074"></A><A NAME="marker-59620"></A>Slicing Arrays </H6>
<P CLASS="Body">
<A NAME="pgfId-36075"></A>The standard rules of Python slicing apply to arrays, on a per-dimension basis. Assuming a 3x3 array: </P>
<P CLASS="Python">
<A NAME="pgfId-36076"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = reshape(arrayrange(9),(3,3))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36077"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36078"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36079"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36080"></A> [6 7 8]]</P>
<P CLASS="Body">
<A NAME="pgfId-36081"></A>The plain [<A NAME="marker-59830"></A>:] operator slices from beginning to end:</P>
<P CLASS="Python">
<A NAME="pgfId-36082"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[:,:]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36083"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36084"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36085"></A> [6 7 8]]</P>
<P CLASS="Body">
<A NAME="pgfId-36086"></A>In other words, [:] with no arguments is the same as [:] for lists - it can be read ``all indices along this axis. So, to get the second row along the second dimension: </P>
<P CLASS="Python">
<A NAME="pgfId-36087"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[:,1]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36088"></A>[1 4 7]</P>
<P CLASS="Body">
<A NAME="pgfId-36089"></A>Note that what was a &quot;column&quot; vector is now a &quot;row&quot; vector -- any &quot;integer slice&quot; (as in the 1 in the example above) results in a returned array with rank one less than the input array.</P>
<P CLASS="Body">
<A NAME="pgfId-36090"></A>If one does not specify as many slices as there are dimensions in an array, then the remaining slices are assumed to be ``all''. If <EM CLASS="Code">
A</EM>
 is a rank-3 array, then</P>
<P CLASS="Python">
<A NAME="pgfId-36091"></A><EM CLASS="Code">
A[1] == A[1,:] == A[1,:,:]</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-36092"></A>There is one addition to the slice notation for arrays which does not exist for lists, and that is the optional third argument, meaning the ``step size'' also called stride or increment.  Its default value is 1, meaning return every element in the specified range.  Alternate values allow one to skip some of the elements in the slice: </P>
<P CLASS="Python">
<A NAME="pgfId-36093"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(12)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36094"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36095"></A>[ 0  1  2  3  4  5  6  7  8  9 10 11]</P>
<P CLASS="Python">
<A NAME="pgfId-36096"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::2]</EM>
<A NAME="marker-59831"></A>	# return every *other* element</P>
<P CLASS="Python">
<A NAME="pgfId-36097"></A>[ 0  2  4  6  8 10]</P>
<P CLASS="Body">
<A NAME="pgfId-36098"></A>Negative strides are allowed as long as the starting index is greater than the stopping index:</P>
<P CLASS="Python">
<A NAME="pgfId-36099"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = reshape(arrayrange(9),(3,3))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36100"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36101"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36102"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36103"></A> [6 7 8]]</P>
<P CLASS="Python">
<A NAME="pgfId-36104"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[:, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36105"></A>[0 3 6]</P>
<P CLASS="Python">
<A NAME="pgfId-36106"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[0:3, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36107"></A>[0 3 6]</P>
<P CLASS="Python">
<A NAME="pgfId-36108"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[2:-1, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36109"></A>[6 3 0]</P>
<P CLASS="Body">
<A NAME="pgfId-36110"></A>If a negative stride is specified and the starting or stopping indices are omitted, they default to &quot;end of axis&quot; and &quot;beginning of axis&quot; respectively.  Thus, the following two statements are equivalent for the array given:</P>
<P CLASS="Python">
<A NAME="pgfId-36111"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[2:-1, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36112"></A>[6 3 0]</P>
<P CLASS="Python">
<A NAME="pgfId-36113"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::-1, 0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36114"></A>[6 3 0]</P>
<P CLASS="Python">
<A NAME="pgfId-36115"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::-1]</EM>
	# this reverses only the first axis</P>
<P CLASS="Python">
<A NAME="pgfId-36116"></A>[[6 7 8]</P>
<P CLASS="Python">
<A NAME="pgfId-36117"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36118"></A> [0 1 2]]</P>
<P CLASS="Python">
<A NAME="pgfId-36119"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::-1,::-1]</EM>
	# this reverses both axes  </P>
<P CLASS="Python">
<A NAME="pgfId-36120"></A>[[8 7 6]</P>
<P CLASS="Python">
<A NAME="pgfId-36121"></A> [5 4 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36122"></A> [2 1 0]]</P>
<P CLASS="Body">
<A NAME="pgfId-36123"></A>One final way of slicing arrays is with the keyword <EM CLASS="Code">
...</EM>
<A NAME="marker-59821"></A> This keyword is somewhat complicated. It stands for ``however many `:' I need depending on the rank of the object I'm indexing, so that the indices I *do* specify are at the end of the index list as opposed to the usual beginning.`` </P>
<P CLASS="Body">
<A NAME="pgfId-59823"></A>So, if one has a rank-3 array <EM CLASS="Code">
A</EM>
, then <EM CLASS="Code">
A[...,0]</EM>
 is the same thing as <EM CLASS="Code">
A[:,:,0]</EM>
 but if <EM CLASS="Code">
B</EM>
 is rank-4, then  <EM CLASS="Code">
B[...,0] </EM>
is the same thing as: <EM CLASS="Code">
B[:,:,:,0]</EM>
. Only one <EM CLASS="CodeInput">
...</EM>
 is expanded in an index expression, so if one has a rank-5 array <EM CLASS="Code">
C</EM>
, then:  <EM CLASS="Code">
C[...,0,...]</EM>
 is the same thing as  <EM CLASS="Code">
C[:,:,:,0,:]</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-36125"></A>&nbsp;</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-36126"></A>6.	 <A NAME="marker-59621"></A><A NAME="30906"></A>Ufuncs </H2>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36127"></A>What are Ufuncs?</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-36128"></A>The operations on arrays that were mentioned in the previous section (element-wise addition, multiplication, etc.) all share some features -- they all follow similar rules for broadcasting, coercion and &quot;element-wise operation&quot;.  Just like standard addition is available in Python through the add function in the operator module, array operations are available through callable objects as well.  Thus, the following objects are available in the Numeric module:</P>
<TABLE>
<CAPTION>
<H6 CLASS="TableTitle">
<A NAME="pgfId-36131"></A>Universal Functions, or <EM CLASS="Code">
ufunc</EM>
s. The operators which invoke them when applied to arrays are indicated in parentheses. The entries in slanted typeface refer to unary ufuncs, while the others refer to binary ufuncs.</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36139"></A><EM CLASS="Code">
add (+)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36141"></A><EM CLASS="Code">
subtract (-)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36143"></A><EM CLASS="Code">
multiply (*)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36145"></A><EM CLASS="Code">
divide (/)</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36147"></A><EM CLASS="Code">
remainder (%)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36149"></A><EM CLASS="Code">
power (**)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36151"></A><EM CLASS="Emphasis">
arccos</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36153"></A><EM CLASS="Emphasis">
arccosh</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36155"></A><EM CLASS="Emphasis">
arcsin</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36157"></A><EM CLASS="Emphasis">
arcsinh</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36159"></A><EM CLASS="Emphasis">
arctan</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36161"></A><EM CLASS="Emphasis">
arctanh</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36163"></A><EM CLASS="Emphasis">
cos</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36165"></A><EM CLASS="Emphasis">
cosh</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36167"></A><EM CLASS="Emphasis">
exp</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36169"></A><EM CLASS="Emphasis">
log</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36171"></A><EM CLASS="Emphasis">
log10</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36173"></A><EM CLASS="Emphasis">
sin</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36175"></A><EM CLASS="Emphasis">
sinh</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36177"></A><EM CLASS="Emphasis">
sqrt</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36179"></A><EM CLASS="Emphasis">
tan</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36181"></A><EM CLASS="Emphasis">
tanh</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36183"></A><EM CLASS="Code">
maximum</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36185"></A><EM CLASS="Code">
minimum</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36187"></A><EM CLASS="Emphasis">
conjugate</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36189"></A><EM CLASS="Code">
equal (==)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36191"></A><EM CLASS="Code">
not_equal  (!=)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36193"></A><EM CLASS="Code">
greater (&gt;)</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36195"></A><EM CLASS="Code">
greater_equal (&gt;=)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36197"></A><EM CLASS="Code">
less (&lt;)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36199"></A><EM CLASS="Code">
less_equal (&lt;=)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36201"></A><EM CLASS="Code">
logical_and (and)</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36203"></A><EM CLASS="Code">
logical_or (or)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36205"></A><EM CLASS="Code">
logical_xor</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36207"></A><EM CLASS="Code">
logical_not (not)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36209"></A><EM CLASS="Code">
bitwise_and (&amp;)</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36211"></A><EM CLASS="Code">
bitwise_or (|)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36213"></A><EM CLASS="Code">
bitwise_xor</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36215"></A><EM CLASS="Code">
bitwise_not (&#126;)</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36217"></A>&nbsp;</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-36218"></A>All of these ufuncs can be used as functions.  For example, to use <EM CLASS="Code">
add</EM>
, which is a binary ufunc (i.e. it takes two arguments), one can do either of:</P>
<P CLASS="Python">
<A NAME="pgfId-36219"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(10)<BR>
</EM>
&gt;&gt;&gt; <EM CLASS="CodeInput">
print add(a,a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36220"></A>[ 0  2  4  6  8 10 12 14 16 18]</P>
<P CLASS="Python">
<A NAME="pgfId-36221"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a + a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36222"></A>[ 0  2  4  6  8 10 12 14 16 18]</P>
<P CLASS="Body">
<A NAME="pgfId-36223"></A>In other words, the + operator on arrays performs exactly the same thing as the <EM CLASS="Code">
add</EM>
 ufunc when operated on arrays.  For a unary ufunc such as <EM CLASS="Code">
sin</EM>
, one can do, e.g.:</P>
<P CLASS="Python">
<A NAME="pgfId-36224"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(10)<BR>
</EM>
&gt;&gt;&gt; <EM CLASS="CodeInput">
print sin(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36225"></A>[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427</P>
<P CLASS="Python">
<A NAME="pgfId-36226"></A>      -0.2794155   0.6569866   0.98935825  0.41211849]</P>
<P CLASS="Body">
<A NAME="pgfId-36227"></A>Unary ufuncs return arrays with the same shape as their arguments, but with the contents corresponding to the corresponding mathematical function applied to each element (sin(0)=0, sin(1)=0.84147098, etc.).  </P>
<P CLASS="Body">
<A NAME="pgfId-36228"></A>There are three additional features of ufuncs which make them different from standard Python functions.  They can operate on any Python sequence in addition to arrays; they can take an &quot;output&quot; argument; they have attributes which are themselves callable with arrays and sequences. Each of these will be described in turn.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36229"></A>Ufuncs can operate on any Python sequence</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-36230"></A>Ufuncs have so far been described as callable objects which take either one or two arrays as arguments (depending on whether they are unary or binary).  In fact, any Python sequence which can be the input to the array() constructor can be used.  The return value from ufuncs is always an array.  Thus:</P>
<P CLASS="Python">
<A NAME="pgfId-36231"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
add([1,2,3,4], (1,2,3,4))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36232"></A>array([2, 4, 6, 8])</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36233"></A>Ufuncs can take output arguments</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-36234"></A>In many computations with large sets of numbers, arrays are often used only once.  For example, a computation on a large set of numbers could involve the following step</P>
<P CLASS="Python">
<A NAME="pgfId-36235"></A>    dataset = dataset * 1.20</P>
<P CLASS="Body">
<A NAME="pgfId-36236"></A>This operation as written needs to create a temporary array to store the results of the computation, and then eventually free the memory used by the original dataset array (provided there are no other references to the data it contains).  It is more efficient, both in terms of memory and computation time, to do an &quot;in-place&quot; operation.  This can be done by specifying an existing array as the place to store the result of the ufunc.  In this example, one can write:</P>
<P CLASS="Python">
<A NAME="pgfId-36237"></A>    multiply(dataset, 1.20, dataset)</P>
<P CLASS="Body">
<A NAME="pgfId-36238"></A>This is not a step to take lightly, however.  For example, the &quot;big and slow&quot; version (<EM CLASS="Code">
dataset = dataset * 1.20</EM>
) and the &quot;small and fast&quot; version above will yield different results in two cases:  </P>
<UL>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36239"></A>If the typecode of the target array is not that which would normally be computed, the operation will fail and raise a TypeError exception.</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-36240"></A>If the target array corresponds to a different &quot;view&quot; on the same data as either of the source arrays, inconsistencies will result.  For example, </LI>
</UL>
<P CLASS="Python">
<A NAME="pgfId-36241"></A>          &gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(5, typecode=Float64)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36242"></A>          &gt;&gt;&gt; <EM CLASS="CodeInput">
print a[::-1] * 1.2</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36243"></A>          [ 4.8  3.6  2.4  1.2  0. ]</P>
<P CLASS="Python">
<A NAME="pgfId-36244"></A>          &gt;&gt;&gt; <EM CLASS="CodeInput">
multiply(a[::-1], 1.2, a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36245"></A>          array([ 4.8 ,  3.6 ,  2.4 ,  4.32,  5.76])</P>
<P CLASS="Python">
<A NAME="pgfId-36246"></A>          &gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36247"></A>          [ 4.8   3.6   2.4   4.32  5.76]</P>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-36248"></A>This is because the ufunc does not know which arrays share which data, and in this case the overwriting of the data contents follows a different path through the shared data space of the two arrays, thus resulting in strangely distorted data.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36249"></A><A NAME="87042"></A>Ufuncs have special methods</H6>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-36250"></A>The reduce ufunc method</H6>
<P CLASS="Body">
<A NAME="pgfId-61696"></A>If you don't know about the <EM CLASS="Code">
reduce</EM>
 command in Python, review section 5.1.1 of the Python Tutorial (<EM CLASS="URL">
http://www.python.org/doc/tut/functional.html</EM>
). Briefly, <EM CLASS="Code">
reduce</EM>
 is most often used with two arguments, a callable object (such as a function), and a sequence.  It calls the callable object with the first two element of the sequence, then with the result of that operation and the third element, and so on, returning at the end the successive &quot;reduction&quot; of the specified callable object over the sequence elements.  Similarly, the <EM CLASS="Code">
reduce</EM>
 method of ufuncs is called with a sequence as an argument, and performs the reduction of that ufunc on the sequence. As an example, adding all of the elements in a rank-1 array can be done with:</P>
<P CLASS="Python">
<A NAME="pgfId-36251"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1,2,3,4])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36252"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.reduce(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36253"></A>10 </P>
<P CLASS="Body">
<A NAME="pgfId-36254"></A>When applied to arrays which are of rank greater than one, the reduction proceeds by default along the first axis:</P>
<P CLASS="Python">
<A NAME="pgfId-36255"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = array([[1,2,3,4],[6,7,8,9]])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36256"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36257"></A>[[1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36258"></A> [6 7 8 9]]</P>
<P CLASS="Python">
<A NAME="pgfId-36259"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.reduce(b)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36260"></A>[ 7  9 11 13]</P>
<P CLASS="Body">
<A NAME="pgfId-36261"></A>A different axis of reduction can be specified with a second integer argument:</P>
<P CLASS="Python">
<A NAME="pgfId-36262"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36263"></A>[[1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36264"></A> [6 7 8 9]]</P>
<P CLASS="Python">
<A NAME="pgfId-36265"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.reduce(b, 1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36266"></A>[10 30] </P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-61704"></A>The accumulate ufunc method</H6>
<P CLASS="Body">
<A NAME="pgfId-36267"></A>The <EM CLASS="Code">
accumulate</EM>
 ufunc method is simular to <EM CLASS="Code">
reduce</EM>
, except that it returns an array containing the intermediate results of the reduction: </P>
<P CLASS="Python">
<A NAME="pgfId-36268"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36269"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36270"></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P CLASS="Python">
<A NAME="pgfId-36271"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.accumulate(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36272"></A>[ 0  1  3  6 10 15 21 28 36 45]	# 0, 0+1, 0+1+2, 0+1+2+3, ... 0+...+9</P>
<P CLASS="Python">
<A NAME="pgfId-36273"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.reduce(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36274"></A>45	# same as add.accumulate(...)[-1]</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-61715"></A>The outer ufunc method</H6>
<P CLASS="Body">
<A NAME="pgfId-61718"></A>The third ufunc method is <EM CLASS="Code">
outer</EM>
, which takes two arrays as arguments and returns the &quot;outer ufunc&quot; of the two arguments. Thus the <EM CLASS="Code">
outer</EM>
 method of the <EM CLASS="Code">
multiply</EM>
 ufunc, results in the outer product. The outer method is only supported for binary methods. </P>
<P CLASS="Python">
<A NAME="pgfId-36276"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36277"></A>[0 1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36278"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36279"></A>[0 1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36280"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print add.outer(a,b)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36281"></A>[[0 1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36282"></A> [1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36283"></A> [2 3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36284"></A> [3 4 5 6]</P>
<P CLASS="Python">
<A NAME="pgfId-36285"></A> [4 5 6 7]]</P>
<P CLASS="Python">
<A NAME="pgfId-36286"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print multiply.outer(b,a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36287"></A>[[ 0  0  0  0  0]</P>
<P CLASS="Python">
<A NAME="pgfId-36288"></A> [ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-36289"></A> [ 0  2  4  6  8]</P>
<P CLASS="Python">
<A NAME="pgfId-36290"></A> [ 0  3  6  9 12]]</P>
<P CLASS="Python">
<A NAME="pgfId-36291"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print power.outer(a,b)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36292"></A>[[ 1  0  0  0]</P>
<P CLASS="Python">
<A NAME="pgfId-36293"></A> [ 1  1  1  1]</P>
<P CLASS="Python">
<A NAME="pgfId-36294"></A> [ 1  2  4  8]</P>
<P CLASS="Python">
<A NAME="pgfId-36295"></A> [ 1  3  9 27]</P>
<P CLASS="Python">
<A NAME="pgfId-36296"></A> [ 1  4 16 64]]</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-61737"></A>The reduceat ufunc method</H6>
<P CLASS="Body">
<A NAME="pgfId-61738"></A>The final ufunc method is the <EM CLASS="Code">
reduceat</EM>
 method, which I'd love to explain it, but I don't understand it (XXX).</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-61739"></A>Ufuncs always return new arrays</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-36299"></A>Except when the 'output' argument are used as described above, ufuncs always return new arrays which do not share any data with the input array.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36300"></A>Which are the Ufuncs?</H6>
<P CLASS="Body">
<A NAME="pgfId-36301"></A>Table 1 lists all the ufuncs. We will first discuss the mathematical ufuncs, which perform operations very similar to the functions in the <EM CLASS="Code">
math</EM>
 and <EM CLASS="Code">
cmath</EM>
 modules, albeit elementwise, on arrays.  These come in two forms, unary and binary:</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36302"></A><A NAME="marker-59625"></A>Unary Mathematical Ufuncs (take only one argument) </H6>
<P CLASS="Body">
<A NAME="pgfId-36303"></A>The following ufuncs apply the predictable functions on their single array arguments, one element at a time: <EM CLASS="Code">
arccos</EM>
, <EM CLASS="Code">
arccosh</EM>
, <EM CLASS="Code">
 arcsin</EM>
, <EM CLASS="Code">
 arcsinh</EM>
, <EM CLASS="Code">
 arctan</EM>
, <EM CLASS="Code">
 arctanh</EM>
, <EM CLASS="Code">
 cos</EM>
, <EM CLASS="Code">
 cosh</EM>
, <EM CLASS="Code">
 exp</EM>
, <EM CLASS="Code">
 log</EM>
, <EM CLASS="Code">
 log10</EM>
, <EM CLASS="Code">
 sin</EM>
, <EM CLASS="Code">
 sinh</EM>
, <EM CLASS="Code">
 sqrt</EM>
, <EM CLASS="Code">
 tan</EM>
, <EM CLASS="Code">
 tanh</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-36304"></A>As an example:</P>
<P CLASS="Python">
<A NAME="pgfId-36305"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36306"></A>[0 1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36307"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print cos(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36308"></A>[ 1.          0.54030231 -0.41614684 -0.9899925  -0.65364362]</P>
<P CLASS="Python">
<A NAME="pgfId-36309"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print arccos(cos(x))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36310"></A>[ 0.          1.          2.          3.          2.28318531]</P>
<P CLASS="Python">
<A NAME="pgfId-36311"></A># not a bug, but wraparound: 2*pi%4 is 2.28318531</P>
<P CLASS="Body">
<A NAME="pgfId-36312"></A>The <EM CLASS="Code">
conjugate</EM>
 ufunc takes an array of complex numbers and returns the array with entries which are the complex conjugates of the entries in the input array.  If it is called with real numbers, a copy of the array is returned unchanged.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36313"></A>Binary Mathematical Ufuncs</H6>
<P CLASS="Body">
<A NAME="pgfId-36314"></A>These ufuncs take two arrays as arguments, and perform the specified mathematical operation on them, one pair of elements at a time: <EM CLASS="Code">
add</EM>
, <EM CLASS="Code">
subtract</EM>
, <EM CLASS="Code">
multiply</EM>
, <EM CLASS="Code">
divide</EM>
, <EM CLASS="Code">
remainder</EM>
, <EM CLASS="Code">
power</EM>
. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36315"></A><A NAME="marker-59626"></A><A NAME="93991"></A>Logical Ufuncs</H6>
<P CLASS="Body">
<A NAME="pgfId-36316"></A>The ``logical'' ufuncs also perform their operations on arrays in elementwise fashion, just like the ``mathematical'' ones.</P>
<P CLASS="Body">
<A NAME="pgfId-36317"></A>Two are special (<EM CLASS="Code">
maximum</EM>
 and <EM CLASS="Code">
miminum</EM>
) in that they return arrays with entries taken from their input arrays:</P>
<P CLASS="Python">
<A NAME="pgfId-36318"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36319"></A>[0 1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36320"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print y</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36321"></A>[ 2.   2.5  3.   3.5  4. ]</P>
<P CLASS="Python">
<A NAME="pgfId-36322"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print maximum(x, y)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36323"></A>[ 2.   2.5  3.   3.5  4. ]</P>
<P CLASS="Python">
<A NAME="pgfId-36324"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print minimum(x, y)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36325"></A>[ 0.  1.  2.  3.  4.]</P>
<P CLASS="Body">
<A NAME="pgfId-36326"></A>The others all return arrays of 0's or 1's: <EM CLASS="Code">
equal</EM>
, <EM CLASS="Code">
not_equal</EM>
, <EM CLASS="Code">
greater</EM>
, <EM CLASS="Code">
greater_equal</EM>
, <EM CLASS="Code">
less</EM>
, <EM CLASS="Code">
less_equal</EM>
, <EM CLASS="Code">
logical_and</EM>
, <EM CLASS="Code">
logical_or</EM>
, <EM CLASS="Code">
logical_xor</EM>
, <EM CLASS="Code">
logical_not</EM>
, <EM CLASS="Code">
bitwise_and</EM>
, <EM CLASS="Code">
bitwise_or</EM>
, <EM CLASS="Code">
bitwise_xor</EM>
, <EM CLASS="Code">
bitwise_not</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-36327"></A>These are fairly self-explanatory, especially with the associated symbols from the standard Python version of the same operations in Table 1 above.  The <EM CLASS="Code">
logical_*</EM>
 ufuncs perform their operations (and, or, etc.) using the truth value of the elements in the array (equality to 0 for numbers and the standard truth test for PyObject arrays).  The <EM CLASS="Code">
bitwise_*</EM>
 ufuncs, on the other hand, can be used only with integer arrays (of any word size), and will return integer arrays of the larger bit size of the two input arrays:</P>
<P CLASS="Python">
<A NAME="pgfId-36328"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36329"></A>array([7, 7, 0],'1')</P>
<P CLASS="Python">
<A NAME="pgfId-36330"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
y</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36331"></A>array([4, 5, 6])</P>
<P CLASS="Python">
<A NAME="pgfId-36332"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
bitwise_and(x,y)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36333"></A>array([4, 5, 0],'i')</P>
<P CLASS="Body">
<A NAME="pgfId-36334"></A>We've already discussed how to find out about the contents of arrays based on the indices in the arrays - that's what the various slice mechanisms are for. Often, especially when dealing with the result of computations or data analysis, one needs to ``pick out'' parts of matrices based on the content of those matrices. For example, it might be useful to find out which elements of an array are negative, and which are positive. The comparison ufuncs are designed for just this type of operation. Assume an array with various positive and negative numbers in it (for the sake of the example we'll generate it from scratch): </P>
<P CLASS="Python">
<A NAME="pgfId-36335"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36336"></A>[[ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-36337"></A> [ 5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-36338"></A> [10 11 12 13 14]</P>
<P CLASS="Python">
<A NAME="pgfId-36339"></A> [15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-36340"></A> [20 21 22 23 24]]</P>
<P CLASS="Python">
<A NAME="pgfId-36341"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = sin(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36342"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36343"></A>[[ 0.          0.84147098  0.90929743  0.14112001 -0.7568025 ]</P>
<P CLASS="Python">
<A NAME="pgfId-36344"></A> [-0.95892427 -0.2794155   0.6569866   0.98935825  0.41211849]</P>
<P CLASS="Python">
<A NAME="pgfId-36345"></A> [-0.54402111 -0.99999021 -0.53657292  0.42016704  0.99060736]</P>
<P CLASS="Python">
<A NAME="pgfId-36346"></A> [ 0.65028784 -0.28790332 -0.96139749 -0.75098725  0.14987721]</P>
<P CLASS="Python">
<A NAME="pgfId-36347"></A> [ 0.91294525  0.83665564 -0.00885131 -0.8462204  -0.90557836]]</P>
<P CLASS="Python">
<A NAME="pgfId-36348"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print less_equal(b, 0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36349"></A>[[1 0 0 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-36350"></A> [1 1 0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-36351"></A> [1 1 1 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-36352"></A> [0 1 1 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-36353"></A> [0 0 1 1 1]]</P>
<P CLASS="Body">
<A NAME="pgfId-36354"></A>This last example has 1's where the corresponding elements are less than or equal to 0, and 0's everywhere else.</P>
<P CLASS="Python">
<A NAME="pgfId-36355"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(greater(greeceBW, .3))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36356"></A><EM CLASS="Emphasis">
# shows a binary image with white where the pixel value was greater than .3</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36357"></A><A NAME="marker-59630"></A>Ufunc shorthands</H6>
<P CLASS="Body">
<A NAME="pgfId-36358"></A><EM CLASS="Code">
Numeric</EM>
 defines a few functions which correspond to often-used uses of ufuncs: for example, <EM CLASS="Code">
add.reduce()</EM>
 is synonymous with the <EM CLASS="Code">
sum()</EM>
 utility function: </P>
<P CLASS="Python">
<A NAME="pgfId-36359"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(5)	</EM>
<EM CLASS="Emphasis">
# [0 1 2 3 4]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36360"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sum(a)	</EM>
<EM CLASS="Emphasis">
# 0 + 1 + 2 + 3 + 4</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36361"></A>10</P>
<P CLASS="Body">
<A NAME="pgfId-36362"></A>Similarly, <EM CLASS="Code">
cumsum</EM>
 is equivalent to <EM CLASS="Code">
add.accumulate</EM>
 (for ``cumulative sum``), <EM CLASS="Code">
product</EM>
 to <EM CLASS="Code">
multiply.reduce</EM>
, and <EM CLASS="Code">
cumproduct</EM>
 to <EM CLASS="Code">
multiply.accumulate</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-36363"></A>Additional ``utility'' functions which are often useful are <EM CLASS="Code">
alltrue</EM>
 and <EM CLASS="Code">
sometrue</EM>
, which are defined as <EM CLASS="Code">
logical_and.reduce</EM>
 and <EM CLASS="Code">
logical_or.reduce</EM>
 respectively:</P>
<P CLASS="Python">
<A NAME="pgfId-36364"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([0,1,2,3,4])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36365"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print greater(a,0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36366"></A>[0 1 1 1 1]</P>
<P CLASS="Python">
<A NAME="pgfId-36367"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
alltrue(greater(a,0))	</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36368"></A>0</P>
<P CLASS="Python">
<A NAME="pgfId-36369"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
sometrue(greater(a,0))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36370"></A>1</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-36371"></A>7.	 <A NAME="marker-59631"></A><A NAME="21398"></A>Pseudo Indices</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-51714"></A>Tbis chapter discusses pseudo-indices, which allow arrays to have their shapes modified by adding axes, sometimes only for the duration of the evaluation of a Python expression.</P>
<P CLASS="Body">
<A NAME="pgfId-36372"></A>Consider multiplication of a rank-1 array by a scalar: </P>
<P CLASS="Python">
<A NAME="pgfId-36373"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1,2,3])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36374"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a * 2</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36375"></A>[2 4 6]</P>
<P CLASS="Body">
<A NAME="pgfId-36376"></A>This should be trivial to you by now. We've just multiplied a rank-1 array by a scalar (which is converted to a rank-0 array). In other words, the rank-0 array was broadcast to the next rank. This works for adding some two rank-1 arrays as well: </P>
<P CLASS="Python">
<A NAME="pgfId-36377"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36378"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36379"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a + array([4])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36380"></A>[5 6 7]</P>
<P CLASS="Body">
<A NAME="pgfId-36381"></A>but it won't work if either of the two rank-1 arrays have non-matching dimensions which aren't 1 - put another way, broadcast only works for dimensions which are either missing (e.g. a lower-rank array) or for dimensions of 1. </P>
<P CLASS="Body">
<A NAME="pgfId-36382"></A>With this in mind, consider a classic task, matrix multiplication. Suppose we want to multiply the row vector [10,20] by the column vector [1,2,3]. </P>
<P CLASS="Python">
<A NAME="pgfId-36383"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([10,20])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36384"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b = array([1,2,3])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36385"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a * b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36386"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-36387"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-36388"></A>ValueError: frames are not aligned example </P>
<P CLASS="Body">
<A NAME="pgfId-36389"></A>This makes sense - we're trying to multiply a rank-1 array of shape (2,) with a rank-1 array of shape (3,). This violates the laws of broadcast. What we really want to do is make the second vector a vector of shape (3,1), so that the first vector can be broadcast accross the second axis of the second vector. One way to do this is to use the reshape function: </P>
<P CLASS="Python">
<A NAME="pgfId-36390"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36391"></A>(2,)</P>
<P CLASS="Python">
<A NAME="pgfId-36392"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36393"></A>(3,)</P>
<P CLASS="Python">
<A NAME="pgfId-36394"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b2 = reshape(b, (3,1))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36395"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b2</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36396"></A>[[1]</P>
<P CLASS="Python">
<A NAME="pgfId-36397"></A> [2]</P>
<P CLASS="Python">
<A NAME="pgfId-36398"></A> [3]]</P>
<P CLASS="Python">
<A NAME="pgfId-36399"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b2.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36400"></A>(3, 1)</P>
<P CLASS="Python">
<A NAME="pgfId-36401"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a * b2</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36402"></A>[[10 20]</P>
<P CLASS="Python">
<A NAME="pgfId-36403"></A> [20 40]</P>
<P CLASS="Python">
<A NAME="pgfId-36404"></A> [30 60]]</P>
<P CLASS="Body">
<A NAME="pgfId-36405"></A>This is such a common operation that a special feature was added (it turns out to be useful in many other places as well) - the <EM CLASS="Code">
NewAxis</EM>
<A NAME="marker-59833"></A> ``pseudo-index'', originally developed in the Yorick language.  <EM CLASS="Code">
NewAxis</EM>
 is an index, just like integers, so it is used inside of the slice brackets []. It can be thought of as meaning ``add a new axis here,'' in much the same ways as adding a 1 to an array's shape adds an axis. Again, examples help clarify the situation: </P>
<P CLASS="Python">
<A NAME="pgfId-36406"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36407"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36408"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
b.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36409"></A>(3,)</P>
<P CLASS="Python">
<A NAME="pgfId-36410"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
c = b[:, NewAxis]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36411"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print c</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36412"></A>[[1]</P>
<P CLASS="Python">
<A NAME="pgfId-36413"></A> [2]</P>
<P CLASS="Python">
<A NAME="pgfId-36414"></A> [3]]</P>
<P CLASS="Python">
<A NAME="pgfId-36415"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
c.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36416"></A>(3,1) </P>
<P CLASS="Body">
<A NAME="pgfId-36417"></A>Why use such a pseudo-index over the reshape function or shape assignments? Often one doesn't really want a new array with a new axis, one just wants it for an intermediate computation. Witness the array multiplication mentioned above, without and with pseudo-indices: </P>
<P CLASS="Python">
<A NAME="pgfId-36418"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
without = a * reshape(b, (3,1))</EM>
 </P>
<P CLASS="Python">
<A NAME="pgfId-36419"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
with = a * b[:,NewAxis]</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-36420"></A>The second is much more readable (once you understand how <EM CLASS="Code">
NewAxis</EM>
 works), and it's much closer to the intended meaning. Also, it's independent of the dimensions of the array b You might counter that using something like <EM CLASS="Code">
reshape(b, (-1,1))</EM>
 is also dimension-independent, but 1) would you argue that it's as readable? 2) how would you deal with rank-3 or rank-N arrays? The <EM CLASS="Code">
NewAxis</EM>
-based idiom also works nicely with higher rank arrays, and with the <EM CLASS="Code">
...</EM>
 ``rubber index'' mentioned earlier. Adding an axis before the last axis in an array can be done simply with: </P>
<P CLASS="Python">
<A NAME="pgfId-36421"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a[...,NewAxis,:]</EM>
</P>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-36422"></A>8.	 <A NAME="marker-59632"></A><A NAME="28351"></A>Array Functions </H2>
<P CLASS="Body">
<A NAME="pgfId-36423"></A>Most of the useful manipulations on arrays are done with functions. This might be surprising given Python's object-oriented framework, and that many of these functions could have been implemented using methods instead. Choosing functions means that the same procedures can be applied to arbitrary python sequences, not just to arrays. For example, while <EM CLASS="Code">
transpose([[1,2],[3,4]])</EM>
 works just fine, <EM CLASS="Code">
[[1,2],[3,4]].transpose()</EM>
 can't work. This approach also allows uniformity in interface between functions defined in the Numeric Python system, whether implemented in C or in Python, and functions defined in extension modules. The use of array methods is limited to functionality which depends critically on the implementation details of array objects.  Array methods are discussed in the next chapter. </P>
<P CLASS="Body">
<A NAME="pgfId-36424"></A>We've already covered two functions which operate on arrays,  <EM CLASS="Code">
reshape</EM>
 and <EM CLASS="Code">
resize</EM>
.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36425"></A><A NAME="marker-59633"></A>take(a, indices, axis=0) </H6>
<P CLASS="Body">
<A NAME="pgfId-36426"></A><EM CLASS="Code">
take</EM>
 is in some ways like the slice operations. It selects the elements of the array it gets as first argument based on the indices it gets as a second argument. Unlike slicing, however, the array returned by <EM CLASS="Code">
take</EM>
 has the same rank as the input array. This is again much easier to understand with an illustration: </P>
<P CLASS="Python">
<A NAME="pgfId-36427"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-36428"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36429"></A>[[ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-36430"></A> [ 5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-36431"></A> [10 11 12 13 14]</P>
<P CLASS="Python">
<A NAME="pgfId-36432"></A> [15 16 17 18 19]]</P>
<P CLASS="Python">
<A NAME="pgfId-36433"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print take(a, (0,))</EM>
	# first row </P>
<P CLASS="Python">
<A NAME="pgfId-36434"></A>[ [0 1 2 3 4]]</P>
<P CLASS="Python">
<A NAME="pgfId-36435"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print take(a, (0,1))</EM>
	# first and second row</P>
<P CLASS="Python">
<A NAME="pgfId-36436"></A>[[0 1 2 3 4]</P>
<P CLASS="Python">
<A NAME="pgfId-36437"></A> [5 6 7 8 9]]</P>
<P CLASS="Python">
<A NAME="pgfId-36438"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print take(a, (0,-1))</EM>
	# first and last row</P>
<P CLASS="Python">
<A NAME="pgfId-36439"></A>[[ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-36440"></A> [15 16 17 18 19]]</P>
<P CLASS="Body">
<A NAME="pgfId-36441"></A>The optional third argument specifies the axis along which the selection occurs, and the default value (as in the examples above) is 0, the first axis. If you want another axis, then you can specify it: </P>
<P CLASS="Python">
<A NAME="pgfId-36442"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print take(a, (0,), 1)</EM>
	# first column</P>
<P CLASS="Python">
<A NAME="pgfId-36443"></A>[[ 0]</P>
<P CLASS="Python">
<A NAME="pgfId-36444"></A> [ 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36445"></A> [10]</P>
<P CLASS="Python">
<A NAME="pgfId-36446"></A> [15]]</P>
<P CLASS="Python">
<A NAME="pgfId-36447"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print take(a, (0,1), 1)</EM>
	# first and second column</P>
<P CLASS="Python">
<A NAME="pgfId-36448"></A>[[ 0  1]</P>
<P CLASS="Python">
<A NAME="pgfId-36449"></A> [ 5  6]</P>
<P CLASS="Python">
<A NAME="pgfId-36450"></A> [10 11]</P>
<P CLASS="Python">
<A NAME="pgfId-36451"></A> [15 16]]</P>
<P CLASS="Python">
<A NAME="pgfId-36452"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print take(a, (0,-1), 1)</EM>
	# first and last column</P>
<P CLASS="Python">
<A NAME="pgfId-36453"></A>[[ 0  4]</P>
<P CLASS="Python">
<A NAME="pgfId-36454"></A> [ 5  9]</P>
<P CLASS="Python">
<A NAME="pgfId-36455"></A> [10 14]</P>
<P CLASS="Python">
<A NAME="pgfId-36456"></A> [15 19]]</P>
<P CLASS="Body">
<A NAME="pgfId-61744"></A>This is considered to be a ``structural'' operation, because its result does not depend on the content of the arrays or the result of a computation on those contents but uniquely on the structure of the array. Like all such structural operations, the default axis is 0 (the first rank). I mention it here because later in this tutorial, we will see functions which have a default axis of -1. </P>
<P CLASS="Body">
<A NAME="pgfId-61745"></A>Take is often used to create multidimensional arrays with the indices from a rank-1 array.  As in the earlier examples, the shape of the array returned by <EM CLASS="Code">
take()</EM>
 is a combination of the shape of its first argument and the shape of the array that elements are &quot;taken&quot; from -- when that array is rank-1, the shape of the returned array has the same shape as the index sequence. This, as with many other facets of Numeric, is best understood by experiment.</P>
<P CLASS="Python">
<A NAME="pgfId-36459"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = arange(10) * 100</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36460"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36461"></A>[  0 100 200 300 400 500 600 700 800 900]</P>
<P CLASS="Python">
<A NAME="pgfId-36462"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print take(x, [[2,4],[1,2]])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36463"></A>[[200 400]</P>
<P CLASS="Python">
<A NAME="pgfId-36464"></A> [100 200]]</P>
<P CLASS="Body">
<A NAME="pgfId-36465"></A>A typical example of using <EM CLASS="Code">
take()</EM>
 is to replace the grey values in an image according to a &quot;translation table&quot;.  For example, let's consider a brightening of a greyscale image.  The <EM CLASS="Code">
view()</EM>
 function defined in the NumTut package automatically scales the input arrays to use the entire range of grey values, except if the input arrays are of typecode <EM CLASS="Code">
'b'</EM>
 unsigned bytes -- thus to test this brightening function, we'll first start by converting the greyscale floating point array to a greyscale byte array:</P>
<P CLASS="Python">
<A NAME="pgfId-36466"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
BW = (greeceBW*256).astype('b')</EM>
	</P>
<P CLASS="Python">
<A NAME="pgfId-36467"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(BW)</EM>
	# shows black and white picture</P>
<P CLASS="Body">
<A NAME="pgfId-36468"></A>We then create a table mapping the integers 0-255 to integers 0-255 using a &quot;compressive nonlinearity&quot;:</P>
<P CLASS="Python">
<A NAME="pgfId-36469"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
table = (255- arange(256)**2 / 256).astype('b')</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36470"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(table)</EM>
	# shows the conversion curve</P>
<P CLASS="Body">
<A NAME="pgfId-36471"></A>To do the &quot;taking&quot; into an array of the right kind, we first create a blank image array with the same shape and typecode as the original array:</P>
<P CLASS="Python">
<A NAME="pgfId-36472"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
BW2 = zeros(BW.shape, BW.typecode())</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-36473"></A>and then perform the take() operation</P>
<P CLASS="Python">
<A NAME="pgfId-36474"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
BW2.flat[:] = take(table, BW.flat)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36475"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(BW2)</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-78510"></A><A NAME="marker-78558"></A><A NAME="marker-78559"></A>put (a, indices, values)</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-78514"></A><EM CLASS="Code">
put</EM>
 is the opposite of <EM CLASS="Code">
take</EM>
. The values of the array <EM CLASS="Code">
a</EM>
 at the locations specified in <EM CLASS="Code">
indices</EM>
 are set to the corresponding value of <EM CLASS="Code">
values</EM>
. The array <EM CLASS="Code">
a </EM>
must be a contiguous array. The argument indices can be any integer sequence object with values suitable for indexing into the flat form of <EM CLASS="Code">
a</EM>
. The argument <EM CLASS="Code">
values</EM>
 must be any sequence of values that can be converted to the typecode of <EM CLASS="Code">
a</EM>
.</P>
<P CLASS="Python">
<A NAME="pgfId-78614"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = arange(6)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-78615"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
put(x, [2,4], [20,40])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-78616"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-78617"></A>[ 0  1 20  3 40  5]</P>
<P CLASS="Body">
<A NAME="pgfId-78623"></A>Note that the target array <EM CLASS="Code">
a</EM>
 is not required to be one-dimensional. Since <EM CLASS="Code">
a</EM>
 is contiguous and stored in row-major order, the array <EM CLASS="Code">
indices</EM>
 can be treated as indexing <EM CLASS="Code">
a</EM>
's elements in storage order. </P>
<P CLASS="Body">
<A NAME="pgfId-78545"></A>The routine <EM CLASS="Code">
put</EM>
 is thus equivalent to the following (although the loop is in C for speed):</P>
<P CLASS="Python">
<A NAME="pgfId-78546"></A>ind = array(indices, copy=0)</P>
<P CLASS="Python">
<A NAME="pgfId-78550"></A>v = array(values, copy=0).astype(a.typecode())</P>
<P CLASS="Python">
<A NAME="pgfId-78551"></A>for i in len(ind): a.flat[i] = v[i]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-84177"></A>putmask (a, mask, values)</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-84185"></A>putmask sets those elements of <EM CLASS="Code">
a</EM>
 for which <EM CLASS="Code">
mask</EM>
 is true to the corresponding <EM CLASS="Code">
value</EM>
 in values. The array a must be contiguous. The argument <EM CLASS="Code">
mask</EM>
 must be an integer sequence of the same size (but not necessarily the same shape) as <EM CLASS="Code">
a</EM>
. The argument <EM CLASS="Code">
values</EM>
 will be repeated as necessary; in particular it can be a scalar. The array <EM CLASS="Code">
values</EM>
 must be convertible to the type of <EM CLASS="Code">
a</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-84210"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x=arange(5) </EM>
</H6>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-84211"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
putmask(x, [1,0,1,0,1], [10,20,30,40,50])</EM>
</H6>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-84212"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</H6>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-84213"></A>[10  1 30  3 50]</H6>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-84214"></A>&gt;&gt;&gt; <EM CLASS="Code">
putmask(x, [1,0,1,0,1], [-1,-2])</EM>
</H6>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-84215"></A>&gt;&gt;&gt; print x</H6>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-84216"></A><EM CLASS="CodeInput">
[-1  1 -1  3 -1]</EM>
</H6>
<P CLASS="Body">
<A NAME="pgfId-84204"></A>Note how in the last example, the third argument was treated as if it was [-1, -2, -1, -2, -1].</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36476"></A><A NAME="marker-59634"></A>transpose(a, axes=None) </H6>
<P CLASS="Body">
<A NAME="pgfId-36477"></A><EM CLASS="Code">
transpose</EM>
 takes an array and returns a new array which corresponds to a with the order of axes specified by the second argument. The default corresponds to flipping the order of all the axes (it is equivalent to <EM CLASS="Code">
a.shape[::-1]</EM>
 if a is the input array). </P>
<P CLASS="Python">
<A NAME="pgfId-36478"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36479"></A>[[ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-36480"></A> [ 5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-36481"></A> [10 11 12 13 14]</P>
<P CLASS="Python">
<A NAME="pgfId-36482"></A> [15 16 17 18 19]]</P>
<P CLASS="Python">
<A NAME="pgfId-36483"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print transpose(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36484"></A>[[ 0  5 10 15]</P>
<P CLASS="Python">
<A NAME="pgfId-36485"></A> [ 1  6 11 16]</P>
<P CLASS="Python">
<A NAME="pgfId-36486"></A> [ 2  7 12 17]</P>
<P CLASS="Python">
<A NAME="pgfId-36487"></A> [ 3  8 13 18]</P>
<P CLASS="Python">
<A NAME="pgfId-36488"></A> [ 4  9 14 19]]</P>
<P CLASS="Python">
<A NAME="pgfId-36489"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
greece.shape</EM>
	# it's a 355x242 RGB picture<BR>
(355, 242, 3)</P>
<P CLASS="Python">
<A NAME="pgfId-36490"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(greece)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36491"></A><EM CLASS="Emphasis">
# picture of greek street is shown</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36492"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(transpose(greece, (1,0,2)))</EM>
	<EM CLASS="Emphasis">
# swap x and y, not color axis!</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36493"></A><EM CLASS="Emphasis">
# picture of greek street is shown sideways</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36494"></A><A NAME="marker-59635"></A>repeat(a, repeats, axis=0) </H6>
<P CLASS="Body">
<A NAME="pgfId-36495"></A><EM CLASS="Code">
repeat</EM>
 takes an array and returns an array with each element in the input array repeated as often as indicated by the corresponding elements in the second array. It operates along the specified axis.  So, to stretch an array evenly, one needs the repeats array to contain as many instances of the integer scaling factor as the size of the specified axis:</P>
<P CLASS="Python">
<A NAME="pgfId-36496"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(repeat(greece, 2*ones(greece.shape[0])))</EM>
 # double in X</P>
<P CLASS="Python">
<A NAME="pgfId-36497"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
view(repeat(greece, 2*ones(greece.shape[1]), 1))</EM>
 # double in Y</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36498"></A><A NAME="marker-59484"></A>choose(a, (b0, ..., bn)) </H6>
<P CLASS="Body">
<A NAME="pgfId-36499"></A>a is an array of integers between 0 and n. The resulting array will have the same shape as a, with element selected from b0,...,bn as indicating by the value of the corresponding element in a. </P>
<P CLASS="Body">
<A NAME="pgfId-36500"></A>Assume a is an array <EM CLASS="Code">
a</EM>
 that you want to ``clip'' so that no values are greater than 100.0. </P>
<P CLASS="Python">
<A NAME="pgfId-36501"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
choose(greater(a, 100.0), (a, 100.0))  </EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-36502"></A>Everywhere that greater(a, 100.0) is false (ie. 0) this will ``choose'' the corresponding value in a. Everywhere else it will ``choose'' 100.0. </P>
<P CLASS="Body">
<A NAME="pgfId-36503"></A>This works as well with arrays. Try to figure out what the following does: </P>
<P CLASS="Python">
<A NAME="pgfId-36504"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
ret = choose(greater_than(a,b), (c,d)) </EM>
</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36512"></A><A NAME="marker-59485"></A>ravel(a) </H6>
<P CLASS="Body">
<A NAME="pgfId-36513"></A>returns the argument array <EM CLASS="Code">
a</EM>
 as a 1d array. It is equivalent to <EM CLASS="Code">
reshape(a, (-1,))</EM>
 or <EM CLASS="Code">
a.flat</EM>
. Unlike <EM CLASS="Code">
a.flat</EM>
, however, <EM CLASS="Code">
ravel</EM>
 works with non-contiguous arrays.</P>
<P CLASS="Python">
<A NAME="pgfId-58221"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58222"></A>[[ 0  1  2  3]</P>
<P CLASS="Python">
<A NAME="pgfId-58223"></A> [ 5  6  7  8]</P>
<P CLASS="Python">
<A NAME="pgfId-58224"></A> [10 11 12 13]]</P>
<P CLASS="Python">
<A NAME="pgfId-58225"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x.iscontiguous()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58226"></A>0</P>
<P CLASS="Python">
<A NAME="pgfId-58227"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x.flat</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58228"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-58229"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-58230"></A>ValueError: flattened indexing only available for contiguous array</P>
<P CLASS="Python">
<A NAME="pgfId-58231"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
ravel(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58066"></A>array([ 0,  1,  2,  3,  5,  6,  7,  8, 10, 11, 12, 13])</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58067"></A><A NAME="marker-59636"></A>nonzero(a) </H6>
<P CLASS="Body">
<A NAME="pgfId-58068"></A>nonzero() returns an array containing the indices of the elements in a that are nonzero. These indices only make sense for 1d arrays, so the function refuses to act on anything else. As of 1.0a5 this function does not work for complex arrays. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36518"></A><A NAME="marker-59637"></A>where(condition, x, y) </H6>
<P CLASS="Body">
<A NAME="pgfId-36519"></A>where(condition,x,y) returns an array shaped like condition and has elements of x and y where condition is respectively true or false </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36520"></A><A NAME="marker-59638"></A>compress(condition, a, axis=0) </H6>
<P CLASS="Body">
<A NAME="pgfId-36521"></A>returns those elements of a corresponding to those elements of condition that are nonzero. condition must be the same size as the given axis of a. </P>
<P CLASS="Python">
<A NAME="pgfId-58079"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58080"></A>[0 1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-58085"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print greater(x, 2)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58086"></A>[0 0 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-58087"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print compress(greater(x, 2), x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58077"></A>[3]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58163"></A><A NAME="marker-59639"></A>diagonal(a, k=0) </H6>
<P CLASS="Body">
<A NAME="pgfId-58164"></A>returns the entries along the k th diagonal of a (k is an offset from the main diagonal). This is designed for 2d arrays. For larger arrays, it will return the diagonal of each 2d sub-array.</P>
<P CLASS="Python">
<A NAME="pgfId-58174"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58175"></A>[[ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-58176"></A> [ 5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-58177"></A> [10 11 12 13 14]</P>
<P CLASS="Python">
<A NAME="pgfId-58178"></A> [15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-58179"></A> [20 21 22 23 24]]</P>
<P CLASS="Python">
<A NAME="pgfId-58180"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print diagonal(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58181"></A>[ 0  6 12 18 24]</P>
<P CLASS="Python">
<A NAME="pgfId-58182"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print diagonal(x, 1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58183"></A>[ 1  7 13 19]</P>
<P CLASS="Python">
<A NAME="pgfId-58184"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print diagonal(x, -1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58169"></A>[ 5 11 17 23]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36523"></A><A NAME="marker-59640"></A>trace(a, k=0) </H6>
<P CLASS="Body">
<A NAME="pgfId-36524"></A>returns the sum of the elements in a along the k th diagonal. </P>
<P CLASS="Python">
<A NAME="pgfId-58119"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58120"></A>[[ 0  1  2  3  4]</P>
<P CLASS="Python">
<A NAME="pgfId-58121"></A> [ 5  6  7  8  9]</P>
<P CLASS="Python">
<A NAME="pgfId-58122"></A> [10 11 12 13 14]</P>
<P CLASS="Python">
<A NAME="pgfId-58123"></A> [15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-58124"></A> [20 21 22 23 24]]</P>
<P CLASS="Python">
<A NAME="pgfId-58125"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print trace(x)	</EM>
<EM CLASS="Emphasis">
# 0 + 6 + 12 + 18 + 24</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58126"></A>60</P>
<P CLASS="Python">
<A NAME="pgfId-58127"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print trace(x, -1)	</EM>
<EM CLASS="Emphasis">
# 5 + 11 + 17 + 23</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58128"></A>56</P>
<P CLASS="Python">
<A NAME="pgfId-58129"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print trace(x, 1)	</EM>
<EM CLASS="Emphasis">
# 1 + 7 + 13 + 19</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58117"></A>40</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36532"></A>searchsorted(a, values) </H6>
<P CLASS="Body">
<A NAME="pgfId-36533"></A>Called with a rank-1 array sorted in ascending order, <EM CLASS="Code">
searchsorted()</EM>
 will return the indices of the positions in a where the corresponding values would fit. </P>
<P CLASS="Python">
<A NAME="pgfId-65893"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print bin_boundaries</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-65894"></A>[ 0.   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1. ]</P>
<P CLASS="Python">
<A NAME="pgfId-65895"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print data</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-65896"></A>[ 0.3029573   0.79585496  0.82714031  0.77993884  0.55069605  0.76043182</P>
<P CLASS="Python">
<A NAME="pgfId-65897"></A>       0.28511823  0.29987358  0.40286206  0.68617903]</P>
<P CLASS="Python">
<A NAME="pgfId-65898"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print searchsorted(bin_boundaries, data)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66633"></A>[4 8 9 8 6 8 3 3 5 7]</P>
<P CLASS="Body">
<A NAME="pgfId-66640"></A>This can be used for example to write a simple histogramming function:</P>
<P CLASS="Python">
<A NAME="pgfId-66651"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
def histogram(a, bins):</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66641"></A>...  <EM CLASS="CodeInput">
 n = searchsorted(sort(a), bins)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66642"></A>...   <EM CLASS="CodeInput">
n = concatenate([n, [len(a)]])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66643"></A>...   <EM CLASS="CodeInput">
return n[1:]-n[:-1]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66645"></A>...</P>
<P CLASS="Python">
<A NAME="pgfId-66671"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print histogram([0,0,0,0,0,0,0,.33,.33,.33], arange(0,1.0,.1))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66647"></A>[7 0 0 3 0 0 0 0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-66689"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print histogram(sin(arange(0,10,.2)), arange(-1.2, 1.2, .1))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66687"></A>[0 0 4 2 2 2 0 2 1 2 1 3 1 3 1 3 2 3 2 3 4 9 0 0]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-66636"></A><A NAME="marker-66635"></A>sort(a, axis=-1) </H6>
<P CLASS="FirstBody">
<A NAME="pgfId-66206"></A>This function returns an array containing a copy of the data in <EM CLASS="Code">
a</EM>
, with the same shape as <EM CLASS="Code">
a</EM>
, but with the order of the elements along the specified axis sorted. The shape of the returned array is the same as <EM CLASS="Code">
a</EM>
's. Thus, <EM CLASS="Code">
sort(a, 3)</EM>
 will be an array of the same shape as a, where the elements of a have been sorted along the fourth axis. </P>
<P CLASS="Python">
<A NAME="pgfId-65924"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print data</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-65925"></A>[[5 0 1 9 8]</P>
<P CLASS="Python">
<A NAME="pgfId-65926"></A> [2 5 8 3 2]</P>
<P CLASS="Python">
<A NAME="pgfId-65927"></A> [8 0 3 7 0]</P>
<P CLASS="Python">
<A NAME="pgfId-65928"></A> [9 6 9 5 0]</P>
<P CLASS="Python">
<A NAME="pgfId-65929"></A> [9 0 9 7 7]]</P>
<P CLASS="Python">
<A NAME="pgfId-65930"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sort(data)	</EM>
<EM CLASS="Emphasis">
# Axis -1 by default</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-65931"></A>[[0 1 5 8 9]</P>
<P CLASS="Python">
<A NAME="pgfId-65932"></A> [2 2 3 5 8]</P>
<P CLASS="Python">
<A NAME="pgfId-65933"></A> [0 0 3 7 8]</P>
<P CLASS="Python">
<A NAME="pgfId-65934"></A> [0 5 6 9 9]</P>
<P CLASS="Python">
<A NAME="pgfId-65935"></A> [0 7 7 9 9]]</P>
<P CLASS="Python">
<A NAME="pgfId-65936"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sort(data, 0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-65937"></A>[[2 0 1 3 0]</P>
<P CLASS="Python">
<A NAME="pgfId-65938"></A> [5 0 3 5 0]</P>
<P CLASS="Python">
<A NAME="pgfId-65939"></A> [8 0 8 7 2]</P>
<P CLASS="Python">
<A NAME="pgfId-65940"></A> [9 5 9 7 7]</P>
<P CLASS="Python">
<A NAME="pgfId-65876"></A> [9 6 9 9 8]] </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-65841"></A><A NAME="marker-65840"></A>argsort(a, axis=-1) </H6>
<P CLASS="Body">
<A NAME="pgfId-66005"></A><EM CLASS="Code">
argsort</EM>
 will return the indices of the elements of a needed to produce <EM CLASS="Code">
sort(a)</EM>
. In other words, for a rank-1 array, <EM CLASS="Code">
take(a, argsort(a)) == sort(a)</EM>
. </P>
<P CLASS="Python">
<A NAME="pgfId-66031"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print data</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66032"></A>[5 0 1 9 8]</P>
<P CLASS="Python">
<A NAME="pgfId-66033"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sort(data)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66034"></A>[0 1 5 8 9]</P>
<P CLASS="Python">
<A NAME="pgfId-66035"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print argsort(data)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66036"></A>[1 2 0 4 3]</P>
<P CLASS="Python">
<A NAME="pgfId-66037"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print take(data, argsort(data))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66024"></A>[0 1 5 8 9]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-66027"></A><A NAME="marker-66025"></A><A NAME="marker-66026"></A>argmax(a, axis=-1), argmin(a, axis=-1) </H6>
<P CLASS="Body">
<A NAME="pgfId-65827"></A>The <EM CLASS="Code">
argmax()</EM>
 function returns an array with the arguments of the maximum values of its input array a along the given axis. The returned array will have one less dimension than a. <EM CLASS="Code">
argmin()</EM>
 is just like <EM CLASS="Code">
argmax()</EM>
, except that it returns the indices of the minima along the given axis. </P>
<P CLASS="Python">
<A NAME="pgfId-66056"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print data</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66057"></A>[[9 6 1 3 0]</P>
<P CLASS="Python">
<A NAME="pgfId-66058"></A> [0 0 8 9 1]</P>
<P CLASS="Python">
<A NAME="pgfId-66059"></A> [7 4 5 4 0]</P>
<P CLASS="Python">
<A NAME="pgfId-66060"></A> [5 2 7 7 1]</P>
<P CLASS="Python">
<A NAME="pgfId-66061"></A> [9 9 7 9 7]]</P>
<P CLASS="Python">
<A NAME="pgfId-66062"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print argmax(data)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66063"></A>[0 3 0 2 0]</P>
<P CLASS="Python">
<A NAME="pgfId-66064"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print argmax(data, 0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66065"></A>[0 4 1 1 4]</P>
<P CLASS="Python">
<A NAME="pgfId-66066"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print argmin(data)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66067"></A>[4 0 4 4 2]</P>
<P CLASS="Python">
<A NAME="pgfId-66068"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print argmin(data, 0)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36537"></A>[1 1 0 0 0]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36538"></A><A NAME="marker-59645"></A>fromstring(string, typecode) </H6>
<P CLASS="Body">
<A NAME="pgfId-36539"></A>Will return the array formed by the binary data given in string of the specified typecode. This is mainly used for reading binary data to and from files, it can also be used to exchange binary data with other modules that use python strings as storage (<EM CLASS="Emphasis">
e.g.</EM>
 PIL). Note that this representation is dependent on the byte order. To find out the byte ordering used, use the <EM CLASS="Code">
byteswapped()</EM>
 method described on <A HREF="numdoc.html#19367" CLASS="XRef">byteswapped()</A>.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36540"></A>dot(m1, m2) </H6>
<P CLASS="Body">
<A NAME="pgfId-36541"></A>The <EM CLASS="Code">
dot()</EM>
 function returns the dot product of <EM CLASS="Code">
m1</EM>
 and <EM CLASS="Code">
m2</EM>
. This is equivalent to matrix multiply for rank-2 arrays (without the transpose). Somebody who does more linear algebra really needs to do this function right some day! </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36542"></A><A NAME="marker-59646"></A>matrixmultiply(m1, m2) </H6>
<P CLASS="Body">
<A NAME="pgfId-68306"></A>The <EM CLASS="Code">
matrixmultiply(m1, m2)</EM>
 multiplies matrices or matrices and vectors as matrices rather than elementwise. Compare:</P>
<P CLASS="Python">
<A NAME="pgfId-68371"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-68372"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-68373"></A> [3 4 5]]</P>
<P CLASS="Python">
<A NAME="pgfId-68374"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-68375"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-68376"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a*b</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-68377"></A>[[ 0  2  6]</P>
<P CLASS="Python">
<A NAME="pgfId-68378"></A> [ 3  8 15]]</P>
<P CLASS="Python">
<A NAME="pgfId-68379"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print matrixmultiply(a,b)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-68380"></A>[ 8 26]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36545"></A><A NAME="marker-59647"></A>clip(m, m_min, m_max) </H6>
<P CLASS="Body">
<A NAME="pgfId-36546"></A>The clip function creates an array with the same shape and typecode as m, but where every entry in m that is less than m_min is replaced by m_min, and every entry greater than m_max is replaced by m_max. Entries within the range [m_min, m_max] are left unchanged. </P>
<P CLASS="Python">
<A NAME="pgfId-36547"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(9, Float)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36548"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
clip(a, 1.5, 7.5)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36549"></A>1.5000 1.5000 2.0000 3.0000 4.0000 5.0000 6.0000 7.0000 7.5000 </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-66267"></A><A NAME="marker-66266"></A>indices(shape, typecode=None)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-66268"></A>The indices function returns an array corresponding to the shape given. The array returned is an array of a new shape which is based on the specified shape, but has an added dimension of length the number of dimensions in the specified shape. For example, if the shape specified by the <EM CLASS="Code">
shape</EM>
 argument is (3,4), then the shape of the array returned will be (2,3,4) since the length of (3,4) is 2. The contents of the returned arrays are such that the ith subarray (along index 0, the first dimension) contains the indices for that axis of the elements in the array. An example makes things clearer:</P>
<P CLASS="Python">
<A NAME="pgfId-66269"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
i = indices((4,3))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66270"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
i.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66271"></A>(2, 4, 3)</P>
<P CLASS="Python">
<A NAME="pgfId-66272"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print i[0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66292"></A>[[0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-66293"></A> [1 1 1]</P>
<P CLASS="Python">
<A NAME="pgfId-66294"></A> [2 2 2]</P>
<P CLASS="Python">
<A NAME="pgfId-66276"></A> [3 3 3]]</P>
<P CLASS="Python">
<A NAME="pgfId-66277"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print i[1]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66299"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-66300"></A> [0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-66301"></A> [0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-66281"></A> [0 1 2]]</P>
<P CLASS="Body">
<A NAME="pgfId-66282"></A>So, <EM CLASS="Code">
i[0]</EM>
 has an array of the specified shape, and each element in that array specifies the index of that position in the subarray for axis 0. Similarly, each element in the subarray in <EM CLASS="Code">
i[1]</EM>
 contains the index of that position in the subarray for axis 1. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58407"></A><A NAME="marker-59650"></A>swapaxes(a, axis1, axis2)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58408"></A>Returns a new array which shares the data of <EM CLASS="Code">
a</EM>
, but which has the two axes specified by <EM CLASS="Code">
axis1</EM>
 and <EM CLASS="Code">
axis2</EM>
 swapped. If <EM CLASS="Code">
a</EM>
 is of rank 0 or 1, swapaxes simply returns a new reference to <EM CLASS="Code">
a</EM>
.</P>
<P CLASS="Python">
<A NAME="pgfId-58409"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = arange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58410"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x.shape = (5,2,1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58411"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58412"></A>[[[0]</P>
<P CLASS="Python">
<A NAME="pgfId-58413"></A>  [1]]</P>
<P CLASS="Python">
<A NAME="pgfId-58414"></A> [[2]</P>
<P CLASS="Python">
<A NAME="pgfId-58415"></A>  [3]]</P>
<P CLASS="Python">
<A NAME="pgfId-58416"></A> [[4]</P>
<P CLASS="Python">
<A NAME="pgfId-58417"></A>  [5]]</P>
<P CLASS="Python">
<A NAME="pgfId-58418"></A> [[6]</P>
<P CLASS="Python">
<A NAME="pgfId-58419"></A>  [7]]</P>
<P CLASS="Python">
<A NAME="pgfId-58420"></A> [[8]</P>
<P CLASS="Python">
<A NAME="pgfId-58421"></A>  [9]]]</P>
<P CLASS="Python">
<A NAME="pgfId-58422"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
y = swapaxes(x, 0, 2)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58423"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print y.shape</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58424"></A>(1, 2, 5)</P>
<P CLASS="Python">
<A NAME="pgfId-58425"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print y</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58426"></A>[ [[0 2 4 6 8]</P>
<P CLASS="Python">
<A NAME="pgfId-58427"></A>  [1 3 5 7 9]]]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58428"></A><A NAME="marker-59651"></A>concatenate((a0, a1, ... , an), axis=0)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58429"></A>Returns a new array containing copies of the data contained in all arrays <EM CLASS="Code">
a0 ... an</EM>
. The arrays ai will be concatenated along the specified axis (0 by default). All arrays ai must have the same shape along every axis except for the one given. To concatenate arrays along a newly created axis, you can use <EM CLASS="Code">
array((a0, ..., an))</EM>
 as long as all arrays have the same shape. </P>
<P CLASS="Python">
<A NAME="pgfId-58430"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58431"></A>[[ 0  1  2  3]</P>
<P CLASS="Python">
<A NAME="pgfId-58432"></A> [ 5  6  7  8]</P>
<P CLASS="Python">
<A NAME="pgfId-58433"></A> [10 11 12 13]]</P>
<P CLASS="Python">
<A NAME="pgfId-58434"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print concatenate((x,x))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58435"></A>[[ 0  1  2  3]</P>
<P CLASS="Python">
<A NAME="pgfId-58436"></A> [ 5  6  7  8]</P>
<P CLASS="Python">
<A NAME="pgfId-58437"></A> [10 11 12 13]</P>
<P CLASS="Python">
<A NAME="pgfId-58438"></A> [ 0  1  2  3]</P>
<P CLASS="Python">
<A NAME="pgfId-58439"></A> [ 5  6  7  8]</P>
<P CLASS="Python">
<A NAME="pgfId-58440"></A> [10 11 12 13]]</P>
<P CLASS="Python">
<A NAME="pgfId-58441"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print concatenate((x,x), 1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58442"></A>[[ 0  1  2  3  0  1  2  3]</P>
<P CLASS="Python">
<A NAME="pgfId-58443"></A> [ 5  6  7  8  5  6  7  8]</P>
<P CLASS="Python">
<A NAME="pgfId-58444"></A> [10 11 12 13 10 11 12 13]]</P>
<P CLASS="Python">
<A NAME="pgfId-58445"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array((x,x)</EM>
)</P>
<P CLASS="Python">
<A NAME="pgfId-58446"></A>[[[ 0  1  2  3]</P>
<P CLASS="Python">
<A NAME="pgfId-58447"></A>  [ 5  6  7  8]</P>
<P CLASS="Python">
<A NAME="pgfId-58448"></A>  [10 11 12 13]]</P>
<P CLASS="Python">
<A NAME="pgfId-58449"></A> [[ 0  1  2  3]</P>
<P CLASS="Python">
<A NAME="pgfId-58450"></A>  [ 5  6  7  8]</P>
<P CLASS="Python">
<A NAME="pgfId-58451"></A>  [10 11 12 13]]]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58474"></A><A NAME="marker-59656"></A>innerproduct(a, b)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-68414"></A>innerproduct produces the inner product of arrays a and b. It is equivalent to matrixmultiply(a, transpose(b)).</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-84301"></A><A NAME="marker-84312"></A>outerproduct(a,b)</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-84305"></A>outerproduct(a,b) produces the outer product of vectors a and b, that is result[i, j] = a[i] * b[j]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-84308"></A><A NAME="marker-59658"></A>array_repr()		</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58478"></A>See section on Textual Representations of arrays.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58479"></A><A NAME="marker-59659"></A>array_str()		</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58480"></A>See section on Textual Representations of arrays.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58481"></A><A NAME="marker-59660"></A>resize(a, new_shape)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58482"></A>The <EM CLASS="Code">
resize</EM>
 function takes an array and a shape, and returns a new array with the specified shape, and filled with the data in the input array. Unlike the <EM CLASS="Code">
reshape</EM>
 function, the new shape does not have to yield the same size as the original array. If the new size of is less than that of the input array, the returned array contains the appropriate data from the &quot;beginning&quot; of the old array. If the new size is greater than that of the input array, the data in the input array is repeated as many times as needed to fill the new array.</P>
<P CLASS="Python">
<A NAME="pgfId-58483"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = arange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58484"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
y = resize(x, (4,2))											</EM>
# note that 4*2 &lt; 10</P>
<P CLASS="Python">
<A NAME="pgfId-58485"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58486"></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P CLASS="Python">
<A NAME="pgfId-58487"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print y</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58488"></A>[[0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-58489"></A> [2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-58490"></A> [4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-58491"></A> [6 7]]</P>
<P CLASS="Python">
<A NAME="pgfId-58492"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print resize(array((0,1)), (5,5))											</EM>
# note that 5*5 &gt; 2</P>
<P CLASS="Python">
<A NAME="pgfId-58493"></A>[[0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-58494"></A> [1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-58495"></A> [0 1 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-58496"></A> [1 0 1 0 1]</P>
<P CLASS="Python">
<A NAME="pgfId-58497"></A> [0 1 0 1 0]]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58514"></A><A NAME="marker-59662"></A>diagonal(a, offset=0, axis1=-2, axis2=-1)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58515"></A>The diagonal function takes an array a, and returns an array of rank 1 containing all of the elements of a such that the difference between their indices along the specified axes is equal to the specified offset. With the default values, this corresponds to all of the elements of the diagonal of a along the last two axes. <EM CLASS="Emphasis">
Currently this is broken for offsets other than -1, 0 and 1, and for non-square arrays.</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58523"></A><A NAME="marker-59666"></A>repeat	 (a, counts, axis=0)</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-67620"></A>The repeat function uses repeated copies of a to create a result. The axis argument refers to the axis of x which will be replicated. The counts argument tells how many copies of each element to make. The length of counts must be the len(shape(a)[axis]). </P>
<P CLASS="Body">
<A NAME="pgfId-67681"></A>In one dimension this is straightforward:</P>
<P CLASS="Python">
<A NAME="pgfId-67672"></A>&gt;&gt;&gt; y</P>
<P CLASS="Python">
<A NAME="pgfId-67673"></A>array([0, 1, 2, 3, 4, 5])</P>
<P CLASS="Python">
<A NAME="pgfId-67666"></A>&gt;&gt;&gt; repeat(y, (1,2,0,2,2,3))</P>
<P CLASS="Python">
<A NAME="pgfId-67667"></A>array([0, 1, 1, 3, 3, 4, 4, 5, 5, 5])</P>
<P CLASS="Python">
<A NAME="pgfId-67658"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-67657"></A>In more than one dimension it sometimes gets harder to understand. Consider for example this array x whose shape is (2,3).</P>
<P CLASS="Python">
<A NAME="pgfId-67626"></A>&gt;&gt;&gt; x</P>
<P CLASS="Python">
<A NAME="pgfId-67627"></A>array([[0, 1, 2],</P>
<P CLASS="Python">
<A NAME="pgfId-67628"></A>       [3, 4, 5]])</P>
<P CLASS="Python">
<A NAME="pgfId-67689"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-67629"></A>&gt;&gt;&gt; repeat(x, (2,6))</P>
<P CLASS="Python">
<A NAME="pgfId-67630"></A>array([[0, 1, 2],</P>
<P CLASS="Python">
<A NAME="pgfId-67631"></A>       [0, 1, 2],</P>
<P CLASS="Python">
<A NAME="pgfId-67632"></A>       [3, 4, 5],</P>
<P CLASS="Python">
<A NAME="pgfId-67633"></A>       [3, 4, 5],</P>
<P CLASS="Python">
<A NAME="pgfId-67634"></A>       [3, 4, 5],</P>
<P CLASS="Python">
<A NAME="pgfId-67635"></A>       [3, 4, 5],</P>
<P CLASS="Python">
<A NAME="pgfId-67636"></A>       [3, 4, 5],</P>
<P CLASS="Python">
<A NAME="pgfId-67637"></A>       [3, 4, 5]])</P>
<P CLASS="Python">
<A NAME="pgfId-67690"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-67642"></A>&gt;&gt;&gt; repeat(x, (6,3), 1)</P>
<P CLASS="Python">
<A NAME="pgfId-67643"></A>array([[0, 0, 0, 0, 0, 0, 1, 1, 1],</P>
<P CLASS="Python">
<A NAME="pgfId-67903"></A>       [2, 2, 2, 2, 2, 2, 3, 3, 3]])</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-67914"></A><A NAME="marker-67940"></A>convolve (a, v, mode=0)</H6>
<P CLASS="Body">
<A NAME="pgfId-67915"></A>The convolve function returns the linear convolution of two rank 1 arrays. The output is a rank 1 array whose length depends on the value of mode which is zero by default. Linear convolution can be used to find the response of a linear system to an arbitrary input. If the input arrays correspond to the coefficients of a polynomial and mode=2, the output of linear convolution corresponds to the coefficients of the product of the polynomials. </P>
<P CLASS="Body">
<A NAME="pgfId-67916"></A>The mode parameter requires a bit of explanation. True linear convolution is only defined over infinite sequences. As both input arrays must represent finite sequences, the convolve operation assumes that the infinite sequences represented by the finite inputs are zero outside of their domain of definition. In other words, the sequences are zero-padded. If mode is 2, then the non-zero part of the full linear convolution is returned, so the output has length len (a)+len (v)-1. Call this output f. If mode is 0, then any part of f which was affected by the zero-padding is chopped from the result. In other words, let b be the input with smallest length and let c be the other input. The output when mode is 0 is the middle len (c)-len (b)+1 elements of f. When mode is 1, the output is the same size as c and is equal to the middle len (c) elements of f.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-67917"></A><A NAME="marker-67939"></A>cross_correlate (a, v, mode=0)</H6>
<P CLASS="Body">
<A NAME="pgfId-67918"></A>The cross_correlate function computes the cross_correlation between two rank 1 arrays. The output is a rank 1 array representing the inner product of a with shifted versions of v. This is very similar to convolution. The difference is that convolution reverses the axis of one of the input sequences but cross_correlation does not. In fact it is easy to verify that convolve (a, v, mode) = cross_correlate (a, v [::-1], mode) </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-67907"></A><A NAME="marker-67905"></A><A NAME="marker-67906"></A>where (condition, x, y)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-67600"></A>The where function creates an array whose values are those of x at those indices where condition is true, and those of y otherwise. The shape of the result is the shape of condition. The type of the result is determined by the types of x and y. Either or both of x and y and be a scalar, which is then used for any element of condition which is true.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58536"></A><A NAME="marker-59693"></A>identity(n)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58537"></A>The identity function returns an n by n array where the diagonal elements are 1, and the off-diagonal elements are 0.</P>
<P CLASS="Python">
<A NAME="pgfId-58538"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print identity(5)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58539"></A>[[1 0 0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-58540"></A> [0 1 0 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-58541"></A> [0 0 1 0 0]</P>
<P CLASS="Python">
<A NAME="pgfId-58542"></A> [0 0 0 1 0]</P>
<P CLASS="Python">
<A NAME="pgfId-58543"></A> [0 0 0 0 1]]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58544"></A><A NAME="marker-59694"></A>sum(a, index=0)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58545"></A>The sum function is a synonym for the reduce method of the add ufunc. It returns the sum of all of the elements in the sequence given along the specified axis (first axis by default).</P>
<P CLASS="Python">
<A NAME="pgfId-58546"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58547"></A>[[ 0  1  2  3]</P>
<P CLASS="Python">
<A NAME="pgfId-58548"></A> [ 4  5  6  7]</P>
<P CLASS="Python">
<A NAME="pgfId-58549"></A> [ 8  9 10 11]</P>
<P CLASS="Python">
<A NAME="pgfId-58550"></A> [12 13 14 15]</P>
<P CLASS="Python">
<A NAME="pgfId-58551"></A> [16 17 18 19]]</P>
<P CLASS="Python">
<A NAME="pgfId-58552"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sum(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58553"></A>[40 45 50 55]						# 0+4+8+12+16, 1+5+9+13+17, 2+6+10+14+18, ...</P>
<P CLASS="Python">
<A NAME="pgfId-58554"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sum(x, 1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-58555"></A>[ 6 22 38 54 70]						# 0+1+2+3, 4+5+6+7, 8+9+10+11, ...</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58556"></A><A NAME="marker-59695"></A>cumsum(a, index=0)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58557"></A>The <EM CLASS="Code">
cumsum</EM>
 function is a synonym for the <EM CLASS="Code">
accumulate</EM>
 method of the <EM CLASS="Code">
add</EM>
 ufunc.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58558"></A><A NAME="marker-59696"></A>product(a, index=0)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58559"></A>The <EM CLASS="Code">
product</EM>
 function is a synonym for the <EM CLASS="Code">
reduce</EM>
 method of the <EM CLASS="Code">
multiply</EM>
 ufunc.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58560"></A><A NAME="marker-59697"></A>cumproduct(a, index=0)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58561"></A>The <EM CLASS="Code">
cumproduct</EM>
 function is a synonym for the <EM CLASS="Code">
accumulate</EM>
 method of the <EM CLASS="Code">
multiply</EM>
 ufunc.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58562"></A><A NAME="marker-59698"></A>alltrue(a, index=0)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58563"></A>The <EM CLASS="Code">
alltrue</EM>
 function is a synonym for the <EM CLASS="Code">
reduce</EM>
 method of the <EM CLASS="Code">
logical_and</EM>
 ufunc.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-58564"></A><A NAME="marker-59699"></A>sometrue(a, index=0)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-58565"></A>The <EM CLASS="Code">
sometrue</EM>
 function is a synonym for the <EM CLASS="Code">
reduce</EM>
 method of the <EM CLASS="Code">
logical_or</EM>
 ufunc.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-36552"></A>9.	 <A NAME="marker-59710"></A><A NAME="42194"></A>Array Methods </H2>
<P CLASS="Body">
<A NAME="pgfId-36553"></A>As we discussed at the beginning of the last chapter, there are very few array methods for good reasons, and these all depend on the the implementation details. They're worth knowing, though: </P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36554"></A><A NAME="marker-59704"></A>itemsize() </H6>
<P CLASS="Body">
<A NAME="pgfId-36555"></A>The itemsize() method applied to an array returns the number of bytes used by any one of its elements. </P>
<P CLASS="Python">
<A NAME="pgfId-36556"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36557"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.itemsize()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36558"></A>4</P>
<P CLASS="Python">
<A NAME="pgfId-36559"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1.0])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36560"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.itemsize()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36561"></A>8</P>
<P CLASS="Python">
<A NAME="pgfId-36562"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1], Complex)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36563"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.itemsize()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36564"></A>16</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36565"></A><A NAME="marker-59705"></A>iscontiguous() </H6>
<P CLASS="Body">
<A NAME="pgfId-36566"></A>Calling an array's iscontiguous() method returns true if the memory used by A is contiguous. A non-contiguous array can be converted to a contiguous one by the copy() method. This is useful for interfacing to C routines only, as far as I know. </P>
<P CLASS="Body">
<A NAME="pgfId-36567"></A>&gt;&gt;&gt; XXX example </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36568"></A><A NAME="marker-59706"></A>typecode() </H6>
<P CLASS="Body">
<A NAME="pgfId-36569"></A>The `typecode()' method returns the typecode of the array it is applied to. While we've been talking about them as Float, Int, etc., they are represented internally as characters, so this is what you'll get: </P>
<P CLASS="Python">
<A NAME="pgfId-36570"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1,2,3])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36571"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.typecode()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36572"></A>'l'</P>
<P CLASS="Python">
<A NAME="pgfId-36573"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = array([1], Complex)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36574"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.typecode()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36575"></A>'D'</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36576"></A><A NAME="marker-59707"></A><A NAME="19367"></A>byteswapped() </H6>
<P CLASS="Body">
<A NAME="pgfId-36577"></A>The <EM CLASS="Code">
byteswapped</EM>
 method performs a byte swapping operation on all the elements in the array.</P>
<P CLASS="Python">
<A NAME="pgfId-36578"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36579"></A>[1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-36580"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a.byteswapped()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36581"></A>[16777216 33554432 50331648] </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36582"></A><A NAME="marker-59708"></A>tostring() </H6>
<P CLASS="Body">
<A NAME="pgfId-36583"></A>The <EM CLASS="Code">
tostring</EM>
 method returns a string representation of the data portion of the array it is applied to.  </P>
<P CLASS="Python">
<A NAME="pgfId-36584"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(65,100)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36585"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a.tostring()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36586"></A>A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T</P>
<P CLASS="Python">
<A NAME="pgfId-36587"></A>U   V   W   X   Y   Z   [   &#92;   ]   ^   _   `   a   b   c </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36588"></A><A NAME="marker-59709"></A>tolist() </H6>
<P CLASS="Body">
<A NAME="pgfId-36589"></A>Calling an array's tolist() method returns a hierarchical python list version of the same array:</P>
<P CLASS="Python">
<A NAME="pgfId-36590"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36591"></A>[[65 66 67 68 69 70 71]</P>
<P CLASS="Python">
<A NAME="pgfId-36592"></A> [72 73 74 75 76 77 78]</P>
<P CLASS="Python">
<A NAME="pgfId-36593"></A> [79 80 81 82 83 84 85]</P>
<P CLASS="Python">
<A NAME="pgfId-36594"></A> [86 87 88 89 90 91 92]</P>
<P CLASS="Python">
<A NAME="pgfId-36595"></A> [93 94 95 96 97 98 99]]</P>
<P CLASS="Python">
<A NAME="pgfId-36596"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a.tolist()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36597"></A>[[65, 66, 67, 68, 69, 70, 71], [72, 73, 74, 75, 76, 77, 78], [79, 80, 81, 82, 83, 84, 85], [86, 87, 88, 89, 90, 91, 92], [93, 94, 95, 96, 97, 98, 99]] </P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-36604"></A>10.	 <A NAME="marker-59711"></A><A NAME="86746"></A>Array Attributes </H2>
<P CLASS="Body">
<A NAME="pgfId-36605"></A>We've already seen a very useful attribute of arrays, the shape attribute. There are three more, flat, real and imaginary. </P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36606"></A><EM CLASS="Emphasis">
flat</EM>
<A NAME="marker-59712"></A> </H6>
<P CLASS="Body">
<A NAME="pgfId-36607"></A>Accessing the <EM CLASS="Code">
flat</EM>
 attribute of an array returns the flattened, or <EM CLASS="Code">
ravel()</EM>
'ed version of that array, without having to do a function call. The returner array has the same number of elements as the input array, but is of rank-1.  One cannot set the flat attribute of an array, but one can use the indexing and slicing notations to modify the contents of the array:</P>
<P CLASS="Python">
<A NAME="pgfId-36608"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36609"></A>[[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-36610"></A> [3 4 5]</P>
<P CLASS="Python">
<A NAME="pgfId-36611"></A> [6 7 8]]</P>
<P CLASS="Python">
<A NAME="pgfId-36612"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a.flat</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36613"></A>[0 1 2 3 4 5 6 7 8]</P>
<P CLASS="Python">
<A NAME="pgfId-36614"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.flat = arange(9,18)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36615"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-36616"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-36617"></A>AttributeError: Attribute does not exist or cannot be set</P>
<P CLASS="Python">
<A NAME="pgfId-36618"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.flat[4] = 100</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36619"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36620"></A>[[  0   1   2]</P>
<P CLASS="Python">
<A NAME="pgfId-36621"></A> [  3 100   5]</P>
<P CLASS="Python">
<A NAME="pgfId-36622"></A> [  6   7   8]]</P>
<P CLASS="Python">
<A NAME="pgfId-36623"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.flat[:] = arange(9, 18)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36624"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36625"></A>[[ 9 10 11]</P>
<P CLASS="Python">
<A NAME="pgfId-36626"></A> [12 13 14]</P>
<P CLASS="Python">
<A NAME="pgfId-36627"></A> [15 16 17]]</P>
<P CLASS="Python">
<A NAME="pgfId-36628"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36629"></A><EM CLASS="Emphasis">
real</EM>
<A NAME="marker-59713"></A> and <EM CLASS="Emphasis">
imaginary</EM>
<A NAME="marker-59714"></A> </H6>
<P CLASS="Body">
<A NAME="pgfId-36630"></A>These attributes exist only for complex arrays. They return respectively arrays filled with the real and imaginary parts of their elements. <EM CLASS="Code">
.imag</EM>
 is a synonym for <EM CLASS="Code">
.imaginary</EM>
. The arrays returned are not contiguous (except for arrays of length 1, which are always contiguous.). <EM CLASS="Code">
.real</EM>
, <EM CLASS="Code">
.imag</EM>
 and <EM CLASS="Code">
.imaginary</EM>
 are modifiable: </P>
<P CLASS="Python">
<A NAME="pgfId-36631"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36632"></A>[ 0.        +1.j          0.84147098+0.54030231j  0.90929743-0.41614684j]</P>
<P CLASS="Python">
<A NAME="pgfId-36633"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x.real</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36634"></A>[ 0.          0.84147098  0.90929743]</P>
<P CLASS="Python">
<A NAME="pgfId-36635"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x.imag</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36636"></A>[ 1.          0.54030231 -0.41614684]</P>
<P CLASS="Python">
<A NAME="pgfId-36637"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x.imag = arange(3)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36638"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-36639"></A>[ 0.        +0.j  0.84147098+1.j  0.90929743+2.j] </P>
<P CLASS="Python">
<A NAME="pgfId-66468"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = reshape(arange(10), (2,5)) + 0j										</EM>
	# make complex array</P>
<P CLASS="Python">
<A NAME="pgfId-66469"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66470"></A>[[ 0.+0.j  1.+0.j  2.+0.j  3.+0.j  4.+0.j]</P>
<P CLASS="Python">
<A NAME="pgfId-66471"></A> [ 5.+0.j  6.+0.j  7.+0.j  8.+0.j  9.+0.j]]</P>
<P CLASS="Python">
<A NAME="pgfId-66472"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x.real</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66473"></A>[[ 0.  1.  2.  3.  4.]</P>
<P CLASS="Python">
<A NAME="pgfId-66474"></A> [ 5.  6.  7.  8.  9.]]</P>
<P CLASS="Python">
<A NAME="pgfId-66475"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x.typecode(), x.real.typecode()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66476"></A>D d</P>
<P CLASS="Python">
<A NAME="pgfId-66477"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x.itemsize(), x.imag.itemsize()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-66478"></A>16 8</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-59071"></A>11.	 <A NAME="92607"></A>Special Topics</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-59072"></A>This chapter holds miscellaneous information which did not neatly fit in any of the other chapters.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-67984"></A>Subclassing</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-68417"></A>Subclassing Numeric arrays is not possible due to a limitation of Python. The approach taken in the Masked Array facility (<A HREF="numdoc.html#48250" CLASS="XRef">Masked Arrays</A>) is one answer. UserArray.py, described below, can be subclassed, but this is often unsatisfactory unless you put in a similar effort to that in MA.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-67992"></A><A NAME="marker-67986"></A>Code Organization</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-66725"></A>Numeric.py and friends</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-66726"></A><EM CLASS="Code">
Numeric.py</EM>
 is the most commonly used interface to the Numeric extensions.  It is a Python module which imports all of the exported functions and attributes from the <EM CLASS="Code">
multiarray</EM>
 module, and then defines some utility functions.  As some of the functions defined in <EM CLASS="Code">
Numeric.py</EM>
 could someday be moved into a supporting C module, the utility functions and the <EM CLASS="Code">
multiarray</EM>
 object are documented together, in this section.  The <EM CLASS="Code">
multiarray</EM>
 objects are the core of Numeric Python - they are extension types written in C which are designed to provide both space- and time-efficiency when manipulating large arrays of homogeneous data types, with special emphasis to numeric data types.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-66711"></A>UserArray.py</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-66738"></A>In the tradition of <EM CLASS="Code">
UserList.py</EM>
 and <EM CLASS="Code">
UserDict.py</EM>
, the <EM CLASS="Code">
UserArray.py</EM>
 module defines a class whose instances act in many ways like array objects. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-66719"></A>Matrix.py</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-66782"></A>The <EM CLASS="Code">
Matrix.py</EM>
 python module defines a class <EM CLASS="Code">
Matrix</EM>
 which is a subclass of <EM CLASS="Code">
UserArray</EM>
. The only differences between <EM CLASS="Code">
Matrix</EM>
 instances and <EM CLASS="Code">
UserArray</EM>
 instances is that the <EM CLASS="Code">
*</EM>
 operator on <EM CLASS="Code">
Matrix</EM>
 performs a matrix multiplication, as opposed to element-wise multiplication, and that the power operator <EM CLASS="Code">
**</EM>
 is disallowed for <EM CLASS="Code">
Matrix</EM>
 instances.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-66783"></A>Precision.py</H6>
<P CLASS="Body">
<A NAME="pgfId-66784"></A>The Precision.py module contains the code which is used to determine the mapping between typecode names and values, by building small arrays and looking at the number of bytes they use per element.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-66787"></A>ArrayPrinter.py</H6>
<P CLASS="Body">
<A NAME="pgfId-66788"></A>The ArrayPrinter.py module defines the functions used for default printing of arrays. See the section on Textual Representations of arrays on <A HREF="numdoc.html#39358" CLASS="XRef">Textual representations of arrays</A>,</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-66808"></A>Mlab.py</H6>
<P CLASS="Body">
<A NAME="pgfId-66910"></A>The Mlab.py module provides some functions which are compatible with the functions of the same name in the MATLAB programming language. These are:</P>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66920"></A>bartlett(M)</H6>
<P CLASS="Body">
<A NAME="pgfId-66921"></A>returns the M-point Bartlett window.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66922"></A>blackman(M)</H6>
<P CLASS="Body">
<A NAME="pgfId-66923"></A>returns the M-point Blackman window.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66924"></A>corrcoef(x, y=None)</H6>
<P CLASS="Body">
<A NAME="pgfId-66925"></A>The correlation coefficient</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66926"></A>cov(m,y=None)</H6>
<P CLASS="Body">
<A NAME="pgfId-66927"></A>returns the covariance</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66928"></A>cumprod(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66929"></A>returns the cumulative product of the elments along the first dimension of m.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66930"></A>cumsum(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66931"></A>returns the cumulative sum of the elements along the first dimension of m.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66932"></A>diag(v, k=0)</H6>
<P CLASS="Body">
<A NAME="pgfId-66933"></A>returns the k-th diagonal if v is a matrix or returns a matrix with v as the k-th diagonal if v is a vector.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66934"></A>diff(x, n=1)</H6>
<P CLASS="Body">
<A NAME="pgfId-66935"></A>calculates the first-order, discrete difference approximation to the derivative.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66936"></A>eig(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66937"></A>returns the the eigenvalues of m in x and the corresponding eigenvectors in the rows of v.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66938"></A>eye(N, M=N, k=0, typecode=None)</H6>
<P CLASS="Body">
<A NAME="pgfId-66939"></A>returns a N-by-M matrix where the k-th diagonal is all ones, and everything else is zeros.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66940"></A>fliplr(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66941"></A>returns a 2-D matrix m with the rows preserved and columns flipped in the left/right direction. Only works with 2-D arrays.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66942"></A>flipud(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66943"></A>returns a 2-D matrix with the columns preserved and rows flipped in the up/down direction. Only works with 2-D arrays.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66944"></A>hamming(M)</H6>
<P CLASS="Body">
<A NAME="pgfId-66945"></A>returns the M-point Hamming window.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66946"></A>hanning(M)</H6>
<P CLASS="Body">
<A NAME="pgfId-66947"></A>returns the M-point Hanning window.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66948"></A>kaiser(M, beta)</H6>
<P CLASS="Body">
<A NAME="pgfId-66949"></A>returns a Kaiser window of length M with shape parameter beta. It depends on the cephes module for the modified bessel function i0.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66950"></A>max(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-67178"></A>returns the maximum along the first dimension of m.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-67179"></A>mean(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-67180"></A>returns the mean along the first dimension of m. Note: if m is an integer array, integer division will occur.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66954"></A>median(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66955"></A>returns a mean of m along the first dimension of m.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66956"></A>min(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66957"></A>returns the minimum along the first dimension of m.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66958"></A>msort(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66959"></A>returns a sort along the first dimension of m as in MATLAB.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66960"></A>prod(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66961"></A>returns the product of the elements along the first dimension of m.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66962"></A>ptp(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66963"></A>returns the maximum - minimum along the first dimension of m.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66964"></A>rand(d1, ..., dn)</H6>
<P CLASS="Body">
<A NAME="pgfId-66965"></A>returns a matrix of the given dimensions which is initialized to random numbers from a uniform distribution in the range [0,1).</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-67153"></A>rot90(m,k=1)</H6>
<P CLASS="Body">
<A NAME="pgfId-67154"></A>returns the matrix found by rotating m by k*90 degrees in the counterclockwise direction.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-67155"></A>sinc(x)</H6>
<P CLASS="Body">
<A NAME="pgfId-66969"></A>returns sin(pi*x)/(pi*x) at all points of array x.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66970"></A>squeeze(a)</H6>
<P CLASS="Body">
<A NAME="pgfId-66971"></A>removes any ones from the shape of a</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66972"></A>std(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66973"></A>returns the standard deviation along the first dimension of m. The result is unbiased meaning division by len(m)-1.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66974"></A>sum(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66975"></A>returns the sum of the elements along the first dimension of m.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66976"></A>svd(m)</H6>
<P CLASS="Body">
<A NAME="pgfId-66977"></A>return the singular value decomposition of m [u,x,v]</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66978"></A>trapz(y,x=None)</H6>
<P CLASS="Body">
<A NAME="pgfId-66979"></A>integrates y = f(x) using the trapezoidal rule.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66980"></A>tri(N, M=N, k=0, typecode=None)</H6>
<P CLASS="Body">
<A NAME="pgfId-66981"></A>returns a N-by-M matrix where all the diagonals starting from lower left corner up to the k-th are all ones.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66982"></A>tril(m,k=0)</H6>
<P CLASS="Body">
<A NAME="pgfId-66983"></A>returns the elements on and below the k-th diagonal of m. k=0 is the main diagonal, k &gt; 0 is above and k &lt; 0 is below the main diagonal.</P>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-66984"></A>triu(m,k=0)</H6>
<P CLASS="Body">
<A NAME="pgfId-66985"></A>returns the elements on and above the k-th diagonal of m. k=0 is the main diagonal, k &gt; 0 is above and k &lt; 0 is below the main diagonal.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-66811"></A>The <A NAME="marker-66810"></A>multiarray object</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-59077"></A>The array objects which Numeric Python manipulates is actually a multiarray object, given this name to distinguish it from the one-dimensional array object defined in the standard array module.  From here on, however, the terms array and multiarray will be used interchangeably to refer to the new object type.  multiarray objects are homogeneous multidimensional sequences.  Starting from the back, they are sequences.  This means that they are container (compound) objects, which contain references to other objects.  They are multidimensional, meaning that unlike standard Python sequences which define only a single dimension along which one can iterate through the contents, multiarray objects can have up to 40 dimensions.<A HREF="#pgfId-59080" CLASS="footnote">1</A>  Finally, they are homogeneous.  This means that every object in a multiarray must be of the same type.  This is done for efficiency reasons -- storing the type of the contained objects once in the array means that the process of finding the type-specific operation to operate on each element in the array needs to be done only once per array, as opposed to once per element.  Furthemore, as the main purpose of these arrays is to process numbers, the numbers can be stored directly, and not as full-fledged Python objects (PyObject *), thus yielding memory savings.  It is however possible to make arrays of Python objects, which relinquish both the space and time efficiencies but allow heterogeneous contents (as we shall see, these arrays are still homogeneous from the Numeric perspective, they are just arrays of Python object references).</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-59085"></A><A NAME="marker-59717"></A>Typecodes</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-59086"></A>The kind of number stored in an array is described by its typecode. This code is stored internally as a single-character Python string, but more descriptive names corresponding to the typecodes are made available to the Python programmer in the Precision.py module. The typecodes are defined as follows:</P>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="TableTitle">
<A NAME="pgfId-59089"></A>Typecode Listing</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-59095"></A>Variable defined in<BR>
<EM CLASS="Code">
Typecode</EM>
 module</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-59097"></A>Typecode<BR>
character</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-59099"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59101"></A><EM CLASS="Code">
Char</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59103"></A><EM CLASS="Code">
'c'</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59105"></A>Single-character strings</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59107"></A><EM CLASS="Code">
PyObject</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59109"></A><EM CLASS="Code">
'O'</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59111"></A>Reference to Python object</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59113"></A><EM CLASS="Code">
UnsignedInt8</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59115"></A><EM CLASS="Code">
'b'</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59117"></A>Unsigned integer using a single byte.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59119"></A><EM CLASS="Code">
Int</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59121"></A><EM CLASS="Code">
'l'</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59123"></A>Python standard integers (i.e. C long integers)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59125"></A><EM CLASS="Code">
Float</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59127"></A><EM CLASS="Code">
'd'</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59129"></A>Python standard floating point numbers<BR>
(i.e. C double-precision floats)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59131"></A>n/a</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59133"></A><EM CLASS="Code">
'f'</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59135"></A>Single-precision floating point numbers</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59137"></A><EM CLASS="Code">
Complex</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59139"></A><EM CLASS="Code">
'D'</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59141"></A>Complex numbers consisting of two double-precision floats</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59143"></A>n/a</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59145"></A><EM CLASS="Code">
'F'</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59147"></A>Complex numbers consisting of two single-precision floats</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59149"></A><EM CLASS="Code">
Int0, Int8, Int16, Int32, Int64, Int128</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59151"></A>n/a</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59153"></A>These correspond to machine-dependent typecodes: <EM CLASS="Code">
Int0</EM>
 returns the typecode corresponding to the smallest available integer, <EM CLASS="Code">
Int8</EM>
 that corresponding to the smallest available integer with at least 8 bits, <EM CLASS="Code">
Int16</EM>
 that with at least 16 bits, etc. If a typecode is not available (e.g. <EM CLASS="Code">
Int64</EM>
 on a 32-bit machine), the variable is not defined.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59155"></A><EM CLASS="Code">
Float0, Float8, Float16, Float32, Float64, Float128</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59157"></A>n/a</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59159"></A>Same as <EM CLASS="Code">
Int0</EM>
, <EM CLASS="Code">
Int8</EM>
 etc. except for floating point numbers.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59161"></A><EM CLASS="Code">
Complex0, Complex8, Complex16, Complex32, Complex64, Complex128</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59163"></A>n/a</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-59165"></A>Same as <EM CLASS="Code">
Float0</EM>
, etc., except that the number of bits refers to the precision of each of the two (real and imaginary) parts of the complex number.</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-66448"></A>Note on number fomat: the binary format used by Python is that of the underlying C library. [notes about IEEE formats, etc?]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-59290"></A><A NAME="marker-59724"></A>Indexing in and out, slicing</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-59291"></A>Indexing arrays works like indexing of other Python sequences, but supports some extensions which are as of yet not implemented for other sequence types<A HREF="#pgfId-59294" CLASS="footnote">2</A>. The standard [start:stop] notation is supported, with start defaulting to 0 (the first index position) and stop defaulting to the length of the sequence, as for lists and tuples. In addition, there is an optional stride argument, which specifies the stride size between successive indices in the slice. It is expressed by a integer following a second : immediately after the usual start:stop slice. Thus <EM CLASS="Code">
[0:11:2]</EM>
 will slice the array at indices 0, 2, 4, .. 10. The start and stop indices are optional, but the first : must be specified for the stride interpretation to occur. Therefore, <EM CLASS="Code">
[::2]</EM>
<A NAME="marker-59857"></A> means slice from beginning to end, with a stride of 2 (i.e. skip an index for each stride). If the start index is omitted and the stride is negative, the indexing starts from the end of the sequence and works towards the beginning of the sequence. If the stop index is omitted and the stride is negative, the indexing stops at the beginning of the sequence.</P>
<P CLASS="Python">
<A NAME="pgfId-59295"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59296"></A>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-59297"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[10]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59298"></A>10</P>
<P CLASS="Python">
<A NAME="pgfId-59299"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[:10]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59300"></A>[0 1 2 3 4 5 6 7 8 9]</P>
<P CLASS="Python">
<A NAME="pgfId-59301"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[5:15:3]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59302"></A>[ 5  8 11 14]</P>
<P CLASS="Python">
<A NAME="pgfId-59303"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[:10:2]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59304"></A>[0 2 4 6 8]</P>
<P CLASS="Python">
<A NAME="pgfId-59305"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[10::-2]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59306"></A>[10  8  6  4  2  0]</P>
<P CLASS="Python">
<A NAME="pgfId-59307"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[::-1]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59308"></A>[19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0]</P>
<P CLASS="Body">
<A NAME="pgfId-59309"></A>It is important to note that the out-of-bounds conditions follow the same rules as standard Python indexing, so that slices out of bounds are trimmed to the sequence boundaries, but element indexing with out-of-bound indices yields an IndexError:</P>
<P CLASS="Python">
<A NAME="pgfId-59310"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[:100]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59311"></A>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-59312"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[-200:4]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59313"></A>[0 1 2 3]</P>
<P CLASS="Python">
<A NAME="pgfId-59314"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x[100]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59315"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-59316"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-59317"></A>IndexError: index out of bounds</P>
<P CLASS="Body">
<A NAME="pgfId-59318"></A>The second difference between array indexing and other sequences is that arrays provide multidimensional indexing. An array of rank N can be indexed with up to N indices or slices (or combinations thereof. Indices should be integers (with negative integers indicating offsets from the end of the dimension, as for other Python sequences), and slices can have, as explained above, one or two :'s separating integer arguments. These indices and slies must be separated by commas, and correspond to sequential dimensions starting from the leftmost (first) index on. Thus <EM CLASS="Code">
a[3]</EM>
 means index 3 along dimension 0. <EM CLASS="Code">
a[3,:,-4]</EM>
 means the slice of a along three dimensions: index 3 along the first dimension, the entire range of indices along the second dimension, and the 4th from the end index along the third dimension. If the array being indexed has more dimensions than are specified in the multidimensional slice, those dimensions are assumed to be sliced from beginning to end. Thus, if <EM CLASS="Code">
a</EM>
 is a rank 3 array,</P>
</DIV>
<DIV>
<H6 CLASS="CodeDefinition">
<A NAME="pgfId-59319"></A><EM CLASS="Code">
a[0] == a[0,:] == a[0,:,:]</EM>
</H6>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-59320"></A><A NAME="marker-59725"></A>Ellipses</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-59321"></A>A special slice element called Ellipses (and written <EM CLASS="Code">
...</EM>
) is used to refer to a variable number of slices from beginning to end along the current dimension. It is a shorthand for a set of such slices, specifically the number of dimensions of the array being indexed minus those which are already specified. Only the first (leftmost) Ellipses in an multidimensional slice is expanded, while the others are single dimensional slices from beginning to end.</P>
<P CLASS="Body">
<A NAME="pgfId-59322"></A>Thus, if <EM CLASS="Code">
a</EM>
 is a rank-6 array,</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-59323"></A><EM CLASS="Code">
a[3,:,:,:,-1,:] == a[3,...,-1,:] == a[3,...,-1,...]</EM>
.</H6>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-59324"></A><A NAME="marker-59726"></A>NewAxis</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-59325"></A>There is another special symbol which can be used inside indexing operations to create new dimensions in the returned array. The reference NewAxis, used as one of the comma-separated slice elements, does not change the selection of the subset of the array being indexed, but changes the shape of the array returned by the indexing operation, so that an additional dimension (of length 1) is created, at the dimension position corresponding to the location of NewAxis within the indexing sequence. Thus, <EM CLASS="Code">
a[:,3,NewAxis,-3]</EM>
 will perform the indexing of a corresponding to the slice <EM CLASS="Code">
[a:,3,-3]</EM>
, but will also modify the shape of a so that the new shape of <EM CLASS="Code">
a</EM>
 is <EM CLASS="Code">
(a.shape[0], a.shape[1], 1, a.shape[2])</EM>
. This operation is especially useful in conjunction with the broadcasting feature described next, as it replaces a lengthy but common operation with a simple notation (in the example above, the same effect can be had with</P>
<P CLASS="Body">
<A NAME="pgfId-59326"></A><EM CLASS="Code">
reshape(a[:,3,-1], (a.shape[0], a.shape[1], 1, a.shape[2])).</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-59327"></A>Set-indexing and <A NAME="marker-59727"></A>Broadcasting</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-59328"></A>The indexing rules described so far specify exactly the behavior of get-indexing. For set-indexing, the rules are exactly the same, and describe the slice of the array on the left hand side of the assignment operator which is the target of the assignment. The only point left to mention is the process of assigning from the source (on the right hand side of the assignment) to the target (on the left hand side).</P>
<P CLASS="Body">
<A NAME="pgfId-59329"></A>If both source and target have the same shape, then the assignment is done element by element. The typecode of the target specifies the casting which can be applied in the case of a typecode mismatch between source and target. If the typecode of the source is &quot;lower&quot; than that of the target, then an 'up-cast' is performed and no loss in precision results. If the typecode of the source is &quot;higher&quot; than that of the target, then a downcast is performed, which may lose precision (as discussed in the description of the array call, these casts are truncating casts, not rounding casts). Complex numbers cannot be cast to non-complex numbers.</P>
<P CLASS="Body">
<A NAME="pgfId-59330"></A>If the source and the target have different shapes, Numeric Python attempts to broadcast the contents of the source over the range of the target. This broadcasting occurs for all dimensions where the source has dimension 1 or 0 (i.e., is absent). If there exists a dimension for which the two arrays have differing lengths, and the length of that dimension in the source is not 1, then the assignment fails and an exception (ValueError) is raised, notifying the user that the arrays are not aligned.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-59331"></A>Axis specifications</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-59332"></A>In many of the functions defined in this document, indices are used to refer to axes. The numbering scheme is the same as that used by indexing in Python: the first (leftmost) axis is axis 0, the second axis is axis 1, etc. Axis -1 refers to the last axis, -2 refers to the next-to-last axis, etc.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-59333"></A><A NAME="marker-59728"></A><A NAME="39358"></A>Textual representations of arrays</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-59334"></A>The algorithm used to display arrays as text strings is defined in the file ArrayPrinter.py, which defines a function array2string (imported into Numeric's namespace) which offers considerable control over how arrays are output. The range of options to the array2string function will be described first, followed by a description of which options are used by default by <EM CLASS="Code">
str</EM>
 and <EM CLASS="Code">
repr</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-84285"></A>Note that the optional package MA, if imported, modifies this process so that very long arrays are not printed; rather, a summary of their shape and type are shown. You may wish to import MA even if you do not use it otherwise, to get this effect, because without it accidentally attempting to print a very long array can take a very long time to convert, giving the appearance that the program has hung.</P>
<P CLASS="Python">
<A NAME="pgfId-59335"></A><A NAME="marker-59729"></A>array2string(a, max_line_width = None, precision = None,<BR>
suppress_small = None, separator=' ', array_output=0):</P>
<P CLASS="Body">
<A NAME="pgfId-59336"></A>The <EM CLASS="Code">
array2string</EM>
 function takes an array and returns a textual representation of it. Each dimension is indicated by a pair of matching square brackets (<EM CLASS="Code">
[]</EM>
), within which each subset of the array is output. The orientation of the dimensions is as follows: the last (rightmost) dimension is always horizontal, so that the frequent rank-1 arrays use a minimum of screen real-estate. The next-to-last dimension is displayed vertically if present, and any earlier dimension is displayed with additional bracket divisions. For example:</P>
<P CLASS="Python">
<A NAME="pgfId-59337"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = arange(24)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59338"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59339"></A>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]</P>
<P CLASS="Python">
<A NAME="pgfId-59340"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (2,10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59341"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59342"></A>[[ 0  1  2  3  4  5  6  7  8  9 10 11]</P>
<P CLASS="Python">
<A NAME="pgfId-59343"></A> [12 13 14 15 16 17 18 19 20 21 22 23]]</P>
<P CLASS="Python">
<A NAME="pgfId-59344"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a.shape = (2,3,4)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59345"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59346"></A>[[[ 0  1  2  3]</P>
<P CLASS="Python">
<A NAME="pgfId-59347"></A>  [ 4  5  6  7]</P>
<P CLASS="Python">
<A NAME="pgfId-59348"></A>  [ 8  9 10 11]]</P>
<P CLASS="Python">
<A NAME="pgfId-59349"></A> [[12 13 14 15]</P>
<P CLASS="Python">
<A NAME="pgfId-59350"></A>  [16 17 18 19]</P>
<P CLASS="Python">
<A NAME="pgfId-59351"></A>  [20 21 22 23]]]</P>
<P CLASS="Body">
<A NAME="pgfId-59352"></A>The <EM CLASS="Code">
max_line_width</EM>
 argument specifies the maximum number of characters which the array2string routine uses in a single line. If it is set to <EM CLASS="Code">
None</EM>
, then the value of the <EM CLASS="Code">
sys.output_line_width</EM>
 attribute is looked up. If it exists, it is used. If not, the default of 77 characters is used.</P>
<P CLASS="Python">
<A NAME="pgfId-59353"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59354"></A>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</P>
<P CLASS="Python">
<A NAME="pgfId-59355"></A>      26 27 28 29]</P>
<P CLASS="Python">
<A NAME="pgfId-59356"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
sys.output_line_width = 30</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59357"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59358"></A>[ 0  1  2  3  4  5  6  7  8  9</P>
<P CLASS="Python">
<A NAME="pgfId-59359"></A>      10 11 12 13 14 15 16 17</P>
<P CLASS="Python">
<A NAME="pgfId-59360"></A>      18 19 20 21 22 23 24 25</P>
<P CLASS="Python">
<A NAME="pgfId-59361"></A>      26 27 28 29]</P>
<P CLASS="Body">
<A NAME="pgfId-59362"></A>The <EM CLASS="Code">
precision</EM>
 argument specifies the number of digits after the decimal point which are used. If a value of <EM CLASS="Code">
None</EM>
 is used, the value of the <EM CLASS="Code">
sys.float_output_precision</EM>
 is looked up. If it exists, it is used. If not, the default of 8 digits is used.</P>
<P CLASS="Python">
<A NAME="pgfId-59363"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = array((10.11111111111123123111, pi))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59364"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59365"></A>[ 10.11111111   3.14159265]</P>
<P CLASS="Python">
<A NAME="pgfId-59366"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x, precision=3)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59367"></A>[ 10.111   3.142]</P>
<P CLASS="Python">
<A NAME="pgfId-59368"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
sys.float_output_precision = 2</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59369"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59370"></A>[ 10.11   3.14]</P>
<P CLASS="Body">
<A NAME="pgfId-59371"></A>The <EM CLASS="Code">
suppress_small</EM>
 argument specifies whether small values should be suppressed (and output as 0). If a value of <EM CLASS="Code">
None</EM>
 is used, the value of the <EM CLASS="Code">
sys.float_output_suppress_small</EM>
 is looked up. If it exists, it is used (all that matters is whether it evaluates to true or false). If not, the default of 0 (false) is used. This variable also interacts with the precision parameters, as it can be used to suppress the use of exponential notation.</P>
<P CLASS="Python">
<A NAME="pgfId-59372"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59373"></A>[ 1.00000000e-005  3.14159265e+000]</P>
<P CLASS="Python">
<A NAME="pgfId-59374"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59375"></A>[ 1.00000000e-005  3.14159265e+000]</P>
<P CLASS="Python">
<A NAME="pgfId-59376"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x, suppress_small=1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59377"></A>[ 0.00001     3.14159265]</P>
<P CLASS="Python">
<A NAME="pgfId-59378"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x, precision=3)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59379"></A>[ 1.000e-005  3.142e+000]</P>
<P CLASS="Python">
<A NAME="pgfId-59380"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x, precision=3, suppress_small=1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59381"></A>[ 0.     3.142]</P>
<P CLASS="Body">
<A NAME="pgfId-59382"></A>The <EM CLASS="Code">
separator</EM>
 argument is used to specify what character string should be placed between two numbers which do not straddle a dimension. The default is a single space.</P>
<P CLASS="Python">
<A NAME="pgfId-59383"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59384"></A>[   0  100  200  300  400  500  600  700  800  900 100]</P>
<P CLASS="Python">
<A NAME="pgfId-59385"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print array2string(x, separator = ', ')</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59386"></A>[   0,  100,  200,  300,  400,  500,  600,  700,  800,  900, 100]</P>
<P CLASS="Body">
<A NAME="pgfId-60840"></A>Finally, the last attribute, array_output, specifies whether to prepend the string &quot;array(&quot; and append either the string &quot;)&quot; or &quot;, 'X')&quot; where X is a typecode for non-default typecodes (in other words, the typecode will only be displayed if it is not that corresponding to Float, Complex or Int, which are the standard typecodes associated with floating point numbers, complex numbers and integers respectively). The array() is so that an eval of the returned string will return an array object (provided a comma separator is also used).</P>
<P CLASS="Python">
<A NAME="pgfId-59388"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
array2string(arange(3))						</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59389"></A>[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-59390"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
eval(array2string(arange(3), array_output=1))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59391"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-59392"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-59393"></A>  File &quot;&lt;string&gt;&quot;, line 1</P>
<P CLASS="Python">
<A NAME="pgfId-59394"></A>    array([0 1 2])</P>
<P CLASS="Python">
<A NAME="pgfId-59395"></A>             ^</P>
<P CLASS="Python">
<A NAME="pgfId-59396"></A>SyntaxError: invalid syntax</P>
<P CLASS="Python">
<A NAME="pgfId-59397"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
type(eval(array2string(arange(3), array_output=1, separator=',')))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59398"></A>&lt;type 'array'&gt;	</P>
<P CLASS="Python">
<A NAME="pgfId-59399"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
array2string(arange(3), array_output=1)										</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59400"></A>'array([0, 1, 2])'</P>
<P CLASS="Python">
<A NAME="pgfId-59401"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
array2string(zeros((3,), 'i') + arange(3), array_output=1)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59402"></A>&quot;array([0, 1, 2],'i')&quot;</P>
<P CLASS="Body">
<A NAME="pgfId-59403"></A>The <EM CLASS="Code">
str</EM>
 and <EM CLASS="Code">
repr</EM>
 operations on arrays call <EM CLASS="Code">
array2string</EM>
 with the <EM CLASS="Code">
max_line_width</EM>
, <EM CLASS="Code">
precision</EM>
 and <EM CLASS="Code">
suppress_small</EM>
 all set to None, meaning that the defaults are used, but that modifying the attributes in the <EM CLASS="Code">
sys</EM>
 module will affect array printing. str uses the default separator and does not use the array() text, while repr uses a comma as a separator and does use the array(...) text.</P>
<P CLASS="Python">
<A NAME="pgfId-59404"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = arange(3)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59405"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59406"></A>[0 1 2]</P>
<P CLASS="Python">
<A NAME="pgfId-59407"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
str(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59408"></A>'[0 1 2]'</P>
<P CLASS="Python">
<A NAME="pgfId-59409"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
repr(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59410"></A>'array([0, 1, 2])'								# note the array(...) and ,'s</P>
<P CLASS="Python">
<A NAME="pgfId-59411"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = arange(0,.01,.001)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59412"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59413"></A>[ 0.     0.001  0.002  0.003  0.004  0.005  0.006  0.007  0.008  0.009]</P>
<P CLASS="Python">
<A NAME="pgfId-59414"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
import sys</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59415"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
sys.float_output_precision = 2</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59416"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-59417"></A>[ 0.    0.    0.    0.    0.    0.01  0.01  0.01  0.01  0.01]</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-59418"></A>Comparisons</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-67224"></A>Comparisons of multiarray objects results using the normal comparison operators (such as == or &gt;) result in exceptions. Python requires that the result of a comparison be a scalar, not the vector we would want as the result of elementwise comparison. </P>
<P CLASS="Body">
<A NAME="pgfId-84161"></A>Therefore, for comparisons you must use the routines for comparison describe in <A HREF="numdoc.html#93991" CLASS="XRef">Logical Ufuncs</A>.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-67223"></A><A NAME="marker-59730"></A>Pickling and <A NAME="marker-59731"></A>Unpickling -- storing arrays on disk</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-68425"></A>This documentation has not yet been written, but pickling of Numeric arrays is possible.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-59422"></A>Dealing with <A NAME="marker-59732"></A>floating point exceptions</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-59423"></A><A NAME="marker-59733"></A>Attempts to use NaN's as missing values have proven frustrating and not very portable. Consider <A HREF="numdoc.html#48250" CLASS="XRef">Masked Arrays</A> instead.</P>
<P CLASS="Body">
<A NAME="pgfId-84172"></A>fpectl should be documented here ...</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-36640"></A>12.	 <A NAME="69650"></A>Writing a C extension to NumPy</H2>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36641"></A>Introduction</H6>
<P CLASS="Body">
<A NAME="pgfId-36642"></A>There are two applications that require using the NumPy array type in C extension modules: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-36643"></A>Access to numerical libraries: Extension modules can be used to make numerical libraries written in C (or languages linkable to C, such as Fortran) accessible to Python programs. The NumPy array type has the advantage of using the same data layout as arrays in C and Fortran. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-36644"></A>Mixed-language numerical code: In most numerical applications, only a small part of the total code is CPU time intensive. Only this part should thus be written in C, the rest can be written in Python. NumPy arrays are important for the interface between these two parts, because they provide equally simple access to their contents from Python and from C. </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-36645"></A>This document is a tutorial for using NumPy arrays in C extensions. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36646"></A>Preparing an extension module for NumPy arrays</H6>
<P CLASS="Body">
<A NAME="pgfId-36647"></A>To make NumPy arrays available to an extension module, it must include the header file <EM CLASS="Code">
arrayobject.h</EM>
<A NAME="marker-59737"></A>, after the header file Python.h that is obligatory for all extension modules. The file <EM CLASS="Code">
arrayobject.h</EM>
 comes with the NumPy distribution; depending on where it was installed on your system you might have to tell your compiler how to find it. By default <A NAME="marker-68604"></A><A NAME="marker-68605"></A>Distutils installed in a subdirectory Numeric in your Python include path, and so you should include it this way:</P>
<P CLASS="C-Code">
<A NAME="pgfId-68594"></A>#include &quot;Numeric/arrayobject.h&quot;</P>
<DIV>
<H6 CLASS="NoteTip">
<A NAME="pgfId-68429"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Note">
<A NAME="pgfId-68455"></A>Is your C extension using Numeric blowing up? Maybe you didn't call import_array().</P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-68451"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Body">
<A NAME="pgfId-68428"></A>In addition to including <EM CLASS="Code">
arrayobject.h</EM>
, the extension must call <EM CLASS="Code">
import_array()</EM>
 in its initialization function, after the call to <EM CLASS="Code">
Py_InitModule()</EM>
. This call makes sure that the module which implements the array type has been imported, and initializes a pointer array through which the NumPy functions are called. If you forget this call, your extension module will crash on the first call to a NumPy function!  If you will be manipulating ufunc objects, you should also include the file <EM CLASS="Code">
ufuncobject.h</EM>
<A NAME="marker-59738"></A>, also available as part of the NumPy distribution in the <EM CLASS="Code">
Include</EM>
 directory and usually installed in subdirectory Numeric.</P>
<P CLASS="Body">
<A NAME="pgfId-36648"></A>All of the rules related to writing extension modules for Python apply.  The reader unfamiliar with these rules is encouraged to read the standard text on the topic, &quot;Extending and Embedding the Python Interpreter,&quot; available as part of the standard Python documentation distribution.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36649"></A>Accessing NumPy arrays from C</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36650"></A>Types and Internal Structure</H6>
<P CLASS="Body">
<A NAME="pgfId-36651"></A>NumPy arrays are defined by the structure <EM CLASS="Code">
PyArrayObject</EM>
<A NAME="marker-59739"></A>, which is an extension of the structure <EM CLASS="Code">
PyObject</EM>
. Pointers to <EM CLASS="Code">
PyArrayObject</EM>
 can thus safely be cast to <EM CLASS="Code">
PyObject</EM>
 pointers, whereas the inverse is safe only if the object is known to be an array. The type structure corresponding to array objects is <EM CLASS="Code">
PyArray_Type</EM>
. The structure <EM CLASS="Code">
PyArrayObject</EM>
 has four elements that are needed in order to access the array's data from C code: </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-36652"></A><EM CLASS="Code">
int nd</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-36653"></A>The number of dimensions in the array.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-36654"></A><EM CLASS="Code">
int *dimensions</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-36655"></A>A pointer to an array of <EM CLASS="Code">
nd</EM>
 integers, describing the number of elements along each dimension. The sizes are in the conventional order, so that for any array <EM CLASS="Code">
a</EM>
, <BR>
<EM CLASS="Code">
a.shape==(dimensions[0], dimensions[1], ..., dimensions[nd])</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-36656"></A><EM CLASS="Code">
int *strides</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-36657"></A>A pointer to an array of <EM CLASS="Code">
nd</EM>
 integers, describing the address offset between two successive data elements along each dimension. Note that strides can also be negative!  Each number gives the number of bytes to add to a pointer to get to the next element in that dimension. For example, if <EM CLASS="Code">
myptr</EM>
 currently points to element of a rank-5 array at indices <EM CLASS="Code">
1,0,5,3,2</EM>
 and you want it to point to element <EM CLASS="Code">
1,0,5,4,2</EM>
 then you should add <EM CLASS="Code">
strides[3]</EM>
 to the pointer: <EM CLASS="Code">
myptr += strides[3]</EM>
. This works even if (and is especially useful when) the array is not contiguous in memory.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-36658"></A><EM CLASS="Code">
char *data</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-36659"></A>A pointer to the first data element of the array.</P>
<P CLASS="Body">
<A NAME="pgfId-36660"></A>The address of a data element can be calculated from its indices and the data and strides pointers. For example, element <EM CLASS="Code">
[i, j]</EM>
 of a two-dimensional array has the address <EM CLASS="Code">
data + i*array-&gt;strides[0] + j*array-&gt;strides[1]</EM>
. Note that the stride offsets are in bytes, not in storage units of the array elements. Therefore address calculations must be made in bytes as well, starting from the data pointer, which is always a char pointer. To access the element, the result of the address calculation must be cast to a pointer of the required type. The advantage of this arrangement is that purely structural array operations (indexing, extraction of subarrays, etc.) do not have to know the type of the array elements. </P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36661"></A>Element data types</H6>
<P CLASS="Body">
<A NAME="pgfId-36662"></A>The type of the array elements is indicated by a type number, whose possible values are defined as constants in <EM CLASS="Code">
arrayobject.h</EM>
, as given in Table 3.</P>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="TableTitle">
<A NAME="pgfId-36665"></A>C constants corresponding to storage types</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-36669"></A>Constant</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-36671"></A>element data type</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36673"></A><EM CLASS="Code">
PyArray_CHAR</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36675"></A><EM CLASS="Code">
char</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36677"></A><EM CLASS="Code">
PyArray_UBYTE</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36679"></A><EM CLASS="Code">
unsigned char</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36681"></A><EM CLASS="Code">
PyArray_SBYTE</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36683"></A><EM CLASS="Code">
signed char</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36685"></A><EM CLASS="Code">
PyArray_SHORT</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36687"></A><EM CLASS="Code">
short</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36689"></A><EM CLASS="Code">
PyArray_INT</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36691"></A><EM CLASS="Code">
int</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36693"></A><EM CLASS="Code">
PyArray_LONG</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36695"></A><EM CLASS="Code">
long</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36697"></A><EM CLASS="Code">
PyArray_FLOAT</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36699"></A><EM CLASS="Code">
float</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36701"></A><EM CLASS="Code">
PyArray_DOUBLE</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36703"></A><EM CLASS="Code">
double</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36705"></A><EM CLASS="Code">
PyArray_CFLOAT</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36707"></A><EM CLASS="Code">
float[2]</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36709"></A><EM CLASS="Code">
PyArray_CDOUBLE</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36711"></A><EM CLASS="Code">
double[2]</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36713"></A><EM CLASS="Code">
PyArray_OBJECT</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-36715"></A><EM CLASS="Code">
PyObject *</EM>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="Body">
<A NAME="pgfId-36716"></A>The type number is stored in <EM CLASS="Code">
array-&gt;descr-&gt;type_num</EM>
. Note that the names of the element type constants refer to the C data types, not the Python data types. A Python <EM CLASS="Code">
int</EM>
 is equivalent to a C <EM CLASS="Code">
long</EM>
, and a Python <EM CLASS="Code">
float</EM>
 corresponds to a C <EM CLASS="Code">
double</EM>
. Many of the element types listed above do not have corresponding Python scalar types (e.g. <EM CLASS="Code">
PyArray_INT</EM>
). </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36717"></A><A NAME="marker-59740"></A>Contiguous arrays</H6>
<P CLASS="Body">
<A NAME="pgfId-36718"></A>An important special case of a NumPy array is the contiguous array. This is an array whose elements occupy a single contiguous block of memory and have the same order as a standard C array. In a contiguous array, the value of <EM CLASS="Code">
array-&gt;strides[i]</EM>
 is equal to the size of a single array element times the product of <EM CLASS="Code">
array-&gt;dimensions[j]</EM>
 for <EM CLASS="Code">
j</EM>
 up to <EM CLASS="Code">
i-1</EM>
. Arrays that are created from scratch are always contiguous; non-contiguous arrays are the result of indexing and other structural array operations. The main advantage of contiguous arrays is easier handling in C; the pointer <EM CLASS="Code">
array-&gt;data</EM>
 is cast to the required type and then used like a C array, without any reference to the stride values. This is particularly important when interfacing to existing libraries in C or Fortran, which typically require this standard data layout. A function that requires input arrays to be contiguous must call the conversion function <EM CLASS="Code">
PyArray_ContiguousFromObject()</EM>
, described in the section &quot;Accepting input data from any sequence type&quot;.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-36719"></A><A NAME="marker-59741"></A>Zero-dimensional arrays</H6>
<P CLASS="Body">
<A NAME="pgfId-36720"></A>NumPy permits the creation and use of zero-dimensional arrays, which can be useful to treat scalars and higher-dimensional arrays in the same way. However, library routines for general use should not return zero-demensional arrays, because most Python code is not prepared to handle them. Moreover, zero-dimensional arrays can create confusion because they behave like ordinary Python scalars in many circumstances but are of a different type. A comparison between a Python scalar and a zero-dimensional array will always fail, for example, even if the values are the same. NumPy provides a conversion function from zero-dimensional arrays to Python scalars, which is described in the section &quot;Returning arrays from C functions&quot;. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36721"></A>A simple example</H6>
<P CLASS="Body">
<A NAME="pgfId-36722"></A>The following function calculates the sum of the diagonal elements of a two-dimensional array, verifying that the array is in fact two-dimensional and of type <EM CLASS="Code">
PyArray_DOUBLE</EM>
. </P>
<P CLASS="C-Code">
<A NAME="pgfId-36723"></A>static PyObject *</P>
<P CLASS="C-Code">
<A NAME="pgfId-36724"></A>trace(PyObject *self, PyObject *args)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36725"></A>{</P>
<P CLASS="C-Code">
<A NAME="pgfId-36726"></A>  PyArrayObject *array;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36727"></A>  double sum;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36728"></A>  int i, n;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36729"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36730"></A>  if (!PyArg_ParseTuple(args, &quot;O!&quot;,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36731"></A>                        &amp;PyArray_Type, &amp;array))</P>
<P CLASS="C-Code">
<A NAME="pgfId-36732"></A>    return NULL;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36733"></A>  if (array-&gt;nd != 2 || array-&gt;descr-&gt;type_num != PyArray_DOUBLE) {</P>
<P CLASS="C-Code">
<A NAME="pgfId-36734"></A>    PyErr_SetString(PyExc_ValueError,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36735"></A>                    &quot;array must be two-dimensional and of type float&quot;);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36736"></A>    return NULL;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36737"></A>  }</P>
<P CLASS="C-Code">
<A NAME="pgfId-36738"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36739"></A>  n = array-&gt;dimensions[0];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36740"></A>  if (n &gt; array-&gt;dimensions[1])</P>
<P CLASS="C-Code">
<A NAME="pgfId-36741"></A>    n = array-&gt;dimensions[1];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36742"></A>  sum = 0.;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36743"></A>  for (i = 0; i &lt; n; i++)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36744"></A>    sum += *(double *)(array-&gt;data + i*array-&gt;strides[0] + i*array-&gt;strides[1]);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36745"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36746"></A>  return PyFloat_FromDouble(sum);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36747"></A>}</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36748"></A>Accepting input data from any sequence type</H6>
<P CLASS="Body">
<A NAME="pgfId-36749"></A>The example in the last section requires its input to be an array of type double. In many circumstances this is sufficient, but often, especially in the case of library routines for general use, it would be preferable to accept input data from any sequence (lists, tuples, etc.) and to convert the element type to double automatically where possible. NumPy provides a function that accepts arbitrary sequence objects as input and returns an equivalent array of specified type (this is in fact exactly what the array constructor <EM CLASS="Code">
Numeric.array()</EM>
 does in Python code): </P>
<P CLASS="C-Code">
<A NAME="pgfId-36750"></A>PyObject *</P>
<P CLASS="C-Code">
<A NAME="pgfId-36751"></A>PyArray_ContiguousFromObject(PyObject *object,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36752"></A>                             int type_num,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36753"></A>                             int min_dimensions,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36754"></A>                             int max_dimensions);</P>
<P CLASS="Body">
<A NAME="pgfId-36755"></A>The first argument, object, is the sequence object from which the data is taken. The second argument, type_num, specifies the array element type (see the table in the section &quot;Element data types&quot;. If you want the function to the select the ``smallest'' type that is sufficient to store the data, you can pass the special value <EM CLASS="Code">
PyArray_NOTYPE</EM>
. The remaining two arguments let you specify the number of dimensions of the resulting array, which is guaranteed to be no smaller than <EM CLASS="Code">
min_dimensions</EM>
 and no larger than <EM CLASS="Code">
max_dimensions</EM>
, except for the case <EM CLASS="Code">
max_dimensions == 0</EM>
, which means that no upper limit is imposed.</P>
<P CLASS="Body">
<A NAME="pgfId-36756"></A>If the input data is not compatible with the type or dimension restrictions, an exception is raised. Since the array returned by <EM CLASS="Code">
PyArray_ContiguousFromObject()</EM>
 is guaranteed to be contiguous, this function also provides a method of converting a non-contiguous array to a contiguous one. If the input object is already a contiguous array of the specified type, it is passed on directly; there is thus no performance or memory penalty for calling the conversion function when it is not required. Using this function, the example from the last section becomes </P>
<P CLASS="C-Code">
<A NAME="pgfId-36757"></A>static PyObject *</P>
<P CLASS="C-Code">
<A NAME="pgfId-36758"></A>trace(PyObject *self, PyObject *args)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36759"></A>{</P>
<P CLASS="C-Code">
<A NAME="pgfId-36760"></A>  PyObject *input;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36761"></A>  PyArrayObject *array;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36762"></A>  double sum;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36763"></A>  int i, n;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36764"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36765"></A>  if (!PyArg_ParseTuple(args, &quot;O&quot;, &amp;input))</P>
<P CLASS="C-Code">
<A NAME="pgfId-36766"></A>    return NULL;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36767"></A>  array = (PyArrayObject *)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36768"></A>          PyArray_ContiguousFromObject(input, PyArray_DOUBLE, 2, 2);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36769"></A>  if (array == NULL)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36770"></A>    return NULL;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36771"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36772"></A>  n = array-&gt;dimensions[0];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36773"></A>  if (n &gt; array-&gt;dimensions[1])</P>
<P CLASS="C-Code">
<A NAME="pgfId-36774"></A>    n = array-&gt;dimensions[1];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36775"></A>  sum = 0.;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36776"></A>  for (i = 0; i &lt; n; i++)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36777"></A>    sum += *(double *)(array-&gt;data + i*array-&gt;strides[0] + i*array-&gt;strides[1]);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36778"></A>  </P>
<P CLASS="C-Code">
<A NAME="pgfId-36779"></A>  Py_DECREF(array);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36780"></A>  return PyFloat_FromDouble(sum);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36781"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-36782"></A>Note that no explicit error checking is necessary in this version, and that the array reference that is returned by <EM CLASS="Code">
PyArray_ContiguousFromObject()</EM>
 must be destroyed by calling <EM CLASS="Code">
Py_DECREF()</EM>
. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36783"></A>Creating NumPy arrays</H6>
<P CLASS="Body">
<A NAME="pgfId-36784"></A>NumPy arrays can be created by calling the function </P>
<P CLASS="C-Code">
<A NAME="pgfId-36785"></A>PyObject *</P>
<P CLASS="C-Code">
<A NAME="pgfId-36786"></A>PyArray_FromDims(int n_dimensions,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36787"></A>                 int dimensions[n_dimensions],</P>
<P CLASS="C-Code">
<A NAME="pgfId-36788"></A>                 int type_num);</P>
<P CLASS="Body">
<A NAME="pgfId-36789"></A>The first argument specifies the number of dimensions, the second one the length of each dimension, and the third one the element data type (see the table in the section &quot;Element data types&quot;. The array that is returned is contiguous, but the contents of its data space are undefined. There is a second function which permits the creation of an array object that uses a given memory block for its data space: </P>
<P CLASS="C-Code">
<A NAME="pgfId-36790"></A>PyObject *</P>
<P CLASS="C-Code">
<A NAME="pgfId-36791"></A>PyArray_FromDimsAndData(int n_dimensions,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36792"></A>                        int dimensions[n_dimensions]</P>
<P CLASS="C-Code">
<A NAME="pgfId-36793"></A>                        int item_type</P>
<P CLASS="C-Code">
<A NAME="pgfId-36794"></A>                        char *data);</P>
<P CLASS="Body">
<A NAME="pgfId-36795"></A>The first three arguments are the same as for <EM CLASS="Code">
PyArray_FromDims()</EM>
. The fourth argument is a pointer to the memory block that is to be used as the array's data space. It is the caller's responsibility to ensure that this memory block is not freed before the array object is destroyed. With few exceptions (such as the creation of a temporary array object to which no reference is passed to other functions), this means that the memory block may never be freed, because the lifetime of Python objects are difficult to predict. Nevertheless, this function can be useful in special cases, for example for providing Python access to arrays in Fortran common blocks. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36796"></A>Returning arrays from C functions</H6>
<P CLASS="Body">
<A NAME="pgfId-36797"></A>Array objects can of course be passed out of a C function just like any other object. However, as has been mentioned before, care should be taken not to return zero-dimensional arrays unless the receiver is known to be prepared to handle them. An equivalent Python scalar object should be returned instead. To facilitate this step, NumPy provides a special function </P>
<P CLASS="C-Code">
<A NAME="pgfId-36798"></A>PyObject *</P>
<P CLASS="C-Code">
<A NAME="pgfId-36799"></A>PyArray_Return(PyArrayObject *array);</P>
<P CLASS="Body">
<A NAME="pgfId-36800"></A>which returns the array unchanged if it has one or more dimensions, or the appropriate Python scalar object in case of a zero-dimensional array. </P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-36801"></A>A less simple example</H6>
<P CLASS="Body">
<A NAME="pgfId-36802"></A>The function shown below performs a matrix-vector multiplication by calling the <EM CLASS="Code">
BLAS</EM>
 function <EM CLASS="Code">
DGEMV</EM>
. It takes three arguments: a scalar prefactor, the matrix (a two-dimensional array), and the vector (a one-dimensional array). The return value is a one-dimensional array. The input values are checked for consistency. In addition to providing an illustration of the functions explained above, this example also demonstrates how a Fortran routine can be integrated into Python. Unfortunately, mixing Fortran and C code involves machine-specific peculiarities. In this example, two assumptions have been made: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-36803"></A>The Fortran function <EM CLASS="Code">
DGEMV</EM>
 must be called from C as <EM CLASS="Code">
dgemv_</EM>
. Many Fortran compilers apply this rule, but the C name could also be <EM CLASS="Code">
dgemv</EM>
 or <EM CLASS="Code">
DGEMV</EM>
 (or in principle anything else; there is no fixed standard). </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-36804"></A>Fortran <EM CLASS="Code">
integer</EM>
s are equivalent to C <EM CLASS="Code">
long</EM>
s, and Fortran double precision numbers are equivalent      to C doubles. This works for all systems that I have personally used, but again there is no standard.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-36805"></A>Also note that the libraries that this function must be linked to are system-dependent; on my Linux system (using <EM CLASS="Code">
gcc</EM>
/<EM CLASS="Code">
g77</EM>
), the libraries are <EM CLASS="Code">
blas</EM>
 and <EM CLASS="Code">
f2c</EM>
. So here is the code: </P>
<P CLASS="C-Code">
<A NAME="pgfId-36806"></A>static PyObject *</P>
<P CLASS="C-Code">
<A NAME="pgfId-36807"></A>matrix_vector(PyObject *self, PyObject *args)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36808"></A>{</P>
<P CLASS="C-Code">
<A NAME="pgfId-36809"></A>  PyObject *input1, *input2;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36810"></A>  PyArrayObject *matrix, *vector, *result;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36811"></A>  int dimensions[1];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36812"></A>  double factor[1];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36813"></A>  double real_zero[1] = {0.};</P>
<P CLASS="C-Code">
<A NAME="pgfId-36814"></A>  long int_one[1] = {1};</P>
<P CLASS="C-Code">
<A NAME="pgfId-36815"></A>  long dim0[1], dim1[1];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36816"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36817"></A>  extern dgemv_(char *trans, long *m, long *n,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36818"></A>                double *alpha, double *a, long  *lda,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36819"></A>                double *x, long *incx,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36820"></A>                double *beta, double *Y, long *incy);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36821"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36822"></A>  if (!PyArg_ParseTuple(args, &quot;dOO&quot;, factor, &amp;input1, &amp;input2))</P>
<P CLASS="C-Code">
<A NAME="pgfId-36823"></A>    return NULL;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36824"></A>  matrix = (PyArrayObject *)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36825"></A>            PyArray_ContiguousFromObject(input1, PyArray_DOUBLE, 2, 2);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36826"></A>  if (matrix == NULL)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36827"></A>    return NULL;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36828"></A>  vector = (PyArrayObject *)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36829"></A>            PyArray_ContiguousFromObject(input2, PyArray_DOUBLE, 1, 1);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36830"></A>  if (vector == NULL)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36831"></A>    return NULL;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36832"></A>  if (matrix-&gt;dimensions[1] != vector-&gt;dimensions[0]) {</P>
<P CLASS="C-Code">
<A NAME="pgfId-36833"></A>    PyErr_SetString(PyExc_ValueError,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36834"></A>                    &quot;array dimensions are not compatible&quot;);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36835"></A>    return NULL;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36836"></A>  }</P>
<P CLASS="C-Code">
<A NAME="pgfId-36837"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36838"></A>  dimensions[0] = matrix-&gt;dimensions[0];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36839"></A>  result = (PyArrayObject *)PyArray_FromDims(1, dimensions, PyArray_DOUBLE);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36840"></A>  if (result == NULL)</P>
<P CLASS="C-Code">
<A NAME="pgfId-36841"></A>    return NULL;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36842"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36843"></A>  dim0[0] = (long)matrix-&gt;dimensions[0];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36844"></A>  dim1[0] = (long)matrix-&gt;dimensions[1];</P>
<P CLASS="C-Code">
<A NAME="pgfId-36845"></A>  dgemv_(&quot;T&quot;, dim1, dim0, factor, (double *)matrix-&gt;data, dim1,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36846"></A>         (double *)vector-&gt;data, int_one,</P>
<P CLASS="C-Code">
<A NAME="pgfId-36847"></A>         real_zero, (double *)result-&gt;data, int_one);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36848"></A>&nbsp;</P>
<P CLASS="C-Code">
<A NAME="pgfId-36849"></A>  return PyArray_Return(result);</P>
<P CLASS="C-Code">
<A NAME="pgfId-36850"></A>}</P>
<P CLASS="Body">
<A NAME="pgfId-36851"></A>Note that <EM CLASS="Code">
PyArray_Return()</EM>
 is not really necessary in this case, since we know that the array being returned is one-dimensional. Nevertheless, it is a good habit to always use this function; its performance cost is practically zero. </P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-57398"></A>13.	 <A NAME="36241"></A>C API Reference</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-57399"></A>This chapter describes the API for ArrayObjects and Ufuncs.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-25107"></A>ArrayObject C Structure and API</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-57404"></A>Structures</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-32745"></A>The <A NAME="marker-59742"></A>PyArrayObject is, like all Python types, a kind of PyObject. Its definition is:</P>
<P CLASS="C-Code">
<A NAME="pgfId-32746"></A>typedef struct { </P>
<P CLASS="C-Code">
<A NAME="pgfId-32747"></A>  PyObject_HEAD </P>
<P CLASS="C-Code">
<A NAME="pgfId-32748"></A>  char *data; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25145"></A>  int nd; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25147"></A>  int *dimensions, *strides; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25149"></A>  PyObject *base; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25151"></A>  PyArray_Descr *descr; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25153"></A>  int flags; </P>
<P CLASS="C-Code">
<A NAME="pgfId-25155"></A>} PyArrayObject; </P>
<P CLASS="Body">
<A NAME="pgfId-25137"></A>Where <EM CLASS="Code">
PyObject_HEAD</EM>
 is the standard <EM CLASS="Code">
PyObject</EM>
 header, and the other fields are:</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-32763"></A><EM CLASS="Code">
char</EM>
 *<EM CLASS="Code">
data</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32764"></A>A pointer to the first data element of the array.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-25119"></A><EM CLASS="Code">
int nd</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-25120"></A>The number of dimensions in the array.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-25121"></A><EM CLASS="Code">
int</EM>
 *<EM CLASS="Code">
dimensions</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-25122"></A>A pointer to an array of <EM CLASS="Code">
nd</EM>
 integers, describing the number of elements along each dimension. The sizes are in the conventional order, so that for any array <EM CLASS="Code">
a</EM>
, <BR>
<EM CLASS="Code">
a.shape==(dimensions[0], dimensions[1], ..., dimensions[nd])</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-25123"></A><EM CLASS="Code">
int</EM>
 *<EM CLASS="Code">
strides</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-25124"></A>A pointer to an array of <EM CLASS="Code">
nd</EM>
 integers, describing the address offset between two successive data elements along each dimension. Note that strides can also be negative!  Each number gives the number of bytes to add to a pointer to get to the next element in that dimension. For example, if <EM CLASS="Code">
myptr</EM>
 currently points to an element in a rank-5 array at indices <EM CLASS="Code">
1,0,5,3,2</EM>
 and you want it to point to element <EM CLASS="Code">
1,0,5,4,2</EM>
 then you should add <EM CLASS="Code">
strides[3]</EM>
 to the pointer: <EM CLASS="Code">
myptr += strides[3]</EM>
. This works even if (and is especially useful when) the array is not contiguous in memory.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-32771"></A><EM CLASS="Code">
PyObject</EM>
 *<EM CLASS="Code">
base</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32784"></A>Used internally in arrays that are created as slices of other arrays. Since the new array shares its data area with the old one, the original array's reference count is incremented.  When the subarray is garbage collected, the base array's reference count is decremented.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-32775"></A><EM CLASS="Code">
PyArray_Desc</EM>
 *<EM CLASS="Code">
descr</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32830"></A>See below.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-32831"></A><EM CLASS="Code">
int flags</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32832"></A>A bitfield indicating whether the array:</P>
<UL>
<LI CLASS="BulletLev3">
<A NAME="pgfId-32835"></A>is contiguous (rightmost bit)</LI>
<LI CLASS="BulletLev3">
<A NAME="pgfId-32839"></A>owns the dimensions (next bit to the left) (???)</LI>
<LI CLASS="BulletLev3">
<A NAME="pgfId-32840"></A>owns the strides (next bit to the left) (???)</LI>
<LI CLASS="BulletLev3">
<A NAME="pgfId-32841"></A>owns the data area</LI>
</UL>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-32842"></A>The ownership bits are used by NumPy internally to manage memory allocation and deallocation. They can be false if the array is the result of e.g. a slicing operation on an existing array.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-55326"></A>PyArrayDescr *descr</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-55329"></A>a pointer to a data structure that describes the array and has some handy functions. The slots in this structure are:</P>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32848"></A>PyArray_VectorUnaryFunc *cast[]</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32885"></A>an array of function pointers which will cast this arraytype to each of the other data types.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32852"></A>PyArray_GetItemFunc *getitem </H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32853"></A>a pointer to a function which returns a PyObject of the appropriate type given a (char) pointer to the data to get.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32856"></A>PyArray_SetItemFunc *setitem</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32857"></A>a pointer to a function which sets the element pointed to by the second argument to converted Python Ojbect given as the first argument. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32860"></A>int type_num</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32900"></A>A number indicating the datatype of the array (i.e. a <EM CLASS="Code">
PyArray_XXXX</EM>
)</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32863"></A>char *one</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32905"></A>A pointer to a representation of one for this datatype.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32866"></A>char *zero </H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32910"></A>A pointer to a representation of zero for this datatype (especially useful for PyArray_OBJECT types)</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-32870"></A>char type</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-32917"></A>A character representing the array's typecode (one of <EM CLASS="Code">
'cb1silfdFDO'</EM>
). </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-34282"></A>The ArrayObject API</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-34283"></A>In the following <EM CLASS="Code">
op</EM>
 is a pointer to a <EM CLASS="Code">
PyObject</EM>
 and <EM CLASS="Code">
arp</EM>
 is a pointer to a <EM CLASS="Code">
PyArrayObject</EM>
. Routines which return <EM CLASS="Code">
PyObject</EM>
 * return <EM CLASS="Code">
NULL</EM>
 to indicate failure (and follow the standard exception-setting mechanism). Functions followed by a dagger (|) are functions which return PyObjects whose reference count has been increased by one (new references). See the Python Extending/Embedding manual for details on reference-count management.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34284"></A>int <A NAME="marker-59743"></A>PyArray_Check(op) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34285"></A>returns <EM CLASS="Code">
1</EM>
 if <EM CLASS="Code">
op</EM>
 is a <EM CLASS="Code">
PyArrayObject</EM>
 or <EM CLASS="Code">
0</EM>
 if it is not.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34286"></A>int <A NAME="marker-59744"></A>PyArray_SetNumericOps(d) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34287"></A>internally used by <EM CLASS="Code">
umath</EM>
 to setup some of its functions.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34288"></A>int <A NAME="marker-59745"></A>PyArray_INCREF(op)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34289"></A>Used for arrays of python objects (<EM CLASS="Code">
PyArray_OBJECT</EM>
) to increment the reference count of every python object in the array <EM CLASS="Code">
op</EM>
. User code does not typically need to call this.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34290"></A>int <A NAME="marker-59746"></A>PyArray_XDECREF(op)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34291"></A>Used for arrays of python objects (<EM CLASS="Code">
PyArray_OBJECT</EM>
) to decrement the reference count of every python object in the array <EM CLASS="Code">
op</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34292"></A><A NAME="marker-59747"></A>PyArrayError</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34293"></A>Exports the array error object. I don't know its use.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34294"></A>void <A NAME="marker-59748"></A>PyArray_SetStringFunction(op,repr)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34295"></A>Sets the function for representation of all arrays to <EM CLASS="Code">
op </EM>
which should be a callable <EM CLASS="Code">
PyObject</EM>
. If <EM CLASS="Code">
repr</EM>
 is non-zero then the function corresponding to the <EM CLASS="Code">
repr</EM>
 string representationis set, otherwise, that for the <EM CLASS="Code">
str</EM>
 string representation is set.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34296"></A>PyArray_Descr <A NAME="marker-59749"></A>PyArray_DescrFromType(type)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34297"></A>returns a <EM CLASS="Code">
PyArray_Descr</EM>
 structure for the datatype given by <EM CLASS="Code">
type</EM>
. The input type can be either the enumerated types (<EM CLASS="Code">
PyArray_Float</EM>
, etc.) or a character (<EM CLASS="Code">
'cb1silfdFDO'</EM>
).</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-55586"></A>PyObject *<A NAME="marker-59750"></A>PyArray_Cast(arp, type) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34298"></A>returns a pointer to a <EM CLASS="Code">
PyArrayObject</EM>
 that is <EM CLASS="Code">
arp</EM>
 cast to the array type specified by <EM CLASS="Code">
type</EM>
. It is just a wrapper around the function defined in <EM CLASS="Code">
arp-&gt;descr-&gt;cast</EM>
 that handles non-contiguous arrays and arrays of Python objects appropriately.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34299"></A>int <A NAME="marker-59751"></A>PyArray_CanCastSafely(fromtype,totype)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34300"></A>returns <EM CLASS="Code">
1</EM>
 if the array with type <EM CLASS="Code">
fromtype</EM>
 can be cast to an array of type <EM CLASS="Code">
totype</EM>
 without loss of accuracy, otherwise it returns <EM CLASS="Code">
0</EM>
. It allows conversion of <EM CLASS="Code">
long</EM>
s to <EM CLASS="Code">
int</EM>
s which is not safe on 64-bit machines. The inputs <EM CLASS="Code">
fromtype</EM>
 and <EM CLASS="Code">
totype</EM>
 are the enumerated array types (e.g. <EM CLASS="Code">
PyArray_SBYTE</EM>
).</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34301"></A>int <A NAME="marker-59752"></A>PyArray_ObjectType(op, min_type)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34302"></A>returns the typecode to use for a call to an array creation function given an input python sequence object <EM CLASS="Code">
op</EM>
 and a minimum type value, <EM CLASS="Code">
min_type</EM>
. It looks at the datatypes used in <EM CLASS="Code">
op</EM>
, compares this with <EM CLASS="Code">
min_type</EM>
 and returns a consistent type value that can be used to store all of the data in <EM CLASS="Code">
op</EM>
 and satisfying at the minimum the precision of <EM CLASS="Code">
min_type</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34303"></A>int <A NAME="marker-59753"></A>_PyArray_multiply_list(list,n) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34304"></A>is a utility routine to multiply an array of <EM CLASS="Code">
n</EM>
 integers pointed to by <EM CLASS="Code">
list</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34305"></A>int <A NAME="marker-59754"></A>PyArray_Size(op) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34306"></A>is a useful function for returning the total number of elements in <EM CLASS="Code">
op</EM>
 if <EM CLASS="Code">
op</EM>
 is a <EM CLASS="Code">
PyArrayObject</EM>
, <EM CLASS="Code">
0</EM>
 otherwise.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34307"></A>PyObject *<A NAME="marker-59755"></A>PyArray_FromDims(nd,dims,type) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34308"></A>returns a pointer to a newly constructed <EM CLASS="Code">
PyArrayObject</EM>
 (returned as a <EM CLASS="Code">
PyObject</EM>
) given the number of dimensions in <EM CLASS="Code">
nd</EM>
, an array <EM CLASS="Code">
dims</EM>
 of <EM CLASS="Code">
nd</EM>
 integers specifying the size of the array, and the enumerated type of the array in <EM CLASS="Code">
type</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34309"></A>PyObject *<A NAME="marker-59756"></A>PyArray_FromDimsAndData(nd,dims,type,data) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34310"></A>This function should only be used to access global data that will never be freed (like FORTRAN common blocks). It builds a <EM CLASS="Code">
PyArrayObject</EM>
 in the same way as <EM CLASS="Code">
PyArray_FromDims</EM>
 but instead of allocating new memory for the array elements it uses the bytes pointed to by <EM CLASS="Code">
data</EM>
 (a <EM CLASS="Code">
char *</EM>
).</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34311"></A>PyObject *<A NAME="marker-59757"></A>PyArray_ContiguousFromObject(op,type,min_dim,max_dim) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34312"></A>returns a contiguous array of type <EM CLASS="Code">
type</EM>
 from the (possibly nested) sequence object <EM CLASS="Code">
op</EM>
. If <EM CLASS="Code">
op</EM>
 is a contiguous <EM CLASS="Code">
PyArrayObject</EM>
 then a reference is made; if <EM CLASS="Code">
op</EM>
 is a non-contiguous then a copy is performed to get a contiguous array; if <EM CLASS="Code">
op</EM>
 is not a <EM CLASS="Code">
PyArrayObject</EM>
 then a new <EM CLASS="Code">
PyArrayObject</EM>
 is created from the sequence object and returned. The two parameters <EM CLASS="Code">
min_dim</EM>
 and <EM CLASS="Code">
max_dim</EM>
 let you specify the expected rank of the input sequence. An error will result if the resulting <EM CLASS="Code">
PyArrayObject</EM>
 does not have rank bounded by these limits. To specify an exact rank requirement set <EM CLASS="Code">
min_dim = max_dim</EM>
. To allow for an arbitrary number of dimensions specify <EM CLASS="Code">
min_dim = max_dim = 0</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34315"></A>PyObject *<A NAME="marker-59758"></A>PyArray_CopyFromObject(op,type,min_dim,max_dim) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34316"></A>returns a contiguous array similar to <EM CLASS="Code">
PyArray_ContiguousFromObject</EM>
 except that a copy of <EM CLASS="Code">
op</EM>
 is performed even if a shared array could have been used.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34317"></A>PyObject *<A NAME="marker-59759"></A>PyArray_FromObject(op,type,min_dim,max_dim) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-55829"></A>returns a reference to <EM CLASS="Code">
op</EM>
 if <EM CLASS="Code">
op</EM>
 is a <EM CLASS="Code">
PyArrayObject</EM>
 and a newly constructed <EM CLASS="Code">
PyArrayObject</EM>
 if <EM CLASS="Code">
op</EM>
 is any other (nested) sequence object. You must use strides to access the elements of this possibly discontiguous array correctly.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-55830"></A>PyObject *<A NAME="marker-59760"></A>PyArray_Return(apr) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34320"></A>returns a pointer to <EM CLASS="Code">
apr</EM>
 with some extra code to check for errors and be sure that zero-dimensional arrays are returned as scalars. If a scalar is returned instead of <EM CLASS="Code">
apr</EM>
 then <EM CLASS="Code">
apr</EM>
's reference count is decremented, so it is safe to use this function in the form :<BR>
<EM CLASS="Code">
return PyArray_Return (apr);</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34321"></A>PyObject *<A NAME="marker-59761"></A>PyArray_Reshape(apr,op) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34322"></A>returns a reference to <EM CLASS="Code">
apr</EM>
 with a new shape specified by <EM CLASS="Code">
op</EM>
 which must be a one dimensional sequence object. One dimension may be specified as unknown by giving a value less than zero, its value will be calculated from the size of <EM CLASS="Code">
apr</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34323"></A>PyObject *<A NAME="marker-59762"></A>PyArray_Copy(apr) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34324"></A>returns an element-for-element copy of <EM CLASS="Code">
apr</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34325"></A>PyObject *<A NAME="marker-59763"></A>PyArray_Take(a,indices,axis) |</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34326"></A>the equivalent of <EM CLASS="Code">
take(a, indices, axis)</EM>
 which is a method defined in the Numeric module that just calls this function. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-55910"></A>int <A NAME="marker-59764"></A>PyArray_As1D(*op, char **ptr, int *n, int type)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-55911"></A>This function replaces <EM CLASS="Code">
op</EM>
 with a pointer to a contiguous 1-D <EM CLASS="Code">
PyArrayObject</EM>
 (using <EM CLASS="Code">
PyArray_ContiguousFromObject</EM>
) and sets as output parameters a pointer to the first byte of the array in <EM CLASS="Code">
ptr</EM>
 and the number of elements in the array in <EM CLASS="Code">
n</EM>
. It returns <EM CLASS="Code">
-1</EM>
 on failure (<EM CLASS="Code">
op</EM>
 is not a 1-D array or sequence object that can be cast to type <EM CLASS="Code">
type</EM>
) and <EM CLASS="Code">
0</EM>
 on success. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34329"></A>int <A NAME="marker-59765"></A>PyArray_As2D(*op, char **ptr, int *m, int *n, int type) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34330"></A>This function replaces <EM CLASS="Code">
op</EM>
 with a pointer to a contiguous 2-D <EM CLASS="Code">
PyArrayObject</EM>
 (using <EM CLASS="Code">
PyArray_ContiguousFromObject</EM>
). It returns -1 on failure (op is not a 2-D array or nested sequence object that can be cast to type type) and 0 on success. It also sets as output parameters: an array of pointers in <EM CLASS="Code">
ptr</EM>
 which can be used to access the data as a 2-D array so that ptr[i][j] is a pointer to the first byte of element [i,j] in the array; <EM CLASS="Code">
m</EM>
 and <EM CLASS="Code">
n</EM>
 are set to respectively the number of rows and columns of the array. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34331"></A>int <A NAME="marker-59766"></A>PyArray_Free(op,ptr) </H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34280"></A>is supposed to free the allocated data structures and decrease object references when using <EM CLASS="Code">
PyArray_As1D</EM>
 and <EM CLASS="Code">
PyArray_As2D</EM>
 but there are suspicions that this code is buggy.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-586"></A>Notes</H6>
<P CLASS="Body">
<A NAME="pgfId-17649"></A>Number formats, overflow issues, NaN/Inf representations, fpectl module, how to deal with 'missing' values.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-587"></A><A NAME="marker-59767"></A>UfuncObject C Structure and API</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-589"></A>C Structure</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-33025"></A>The ufuncobject is a generic function object that can be used to perform fast operations over Numeric Arrays with very useful broadcasting rules and type conversions performed automatically. The ufuncobject and its API make it easy and graceful to add arbitrary functions to Python which operate over Numeric arrays. All of the unary and binary operators currently available in the Numerical extensions (like sin, cos, +, logical_or, etc.) are implemented using this object. The hooks are all in place to make it very easy to add any function that takes one or two (double) arguments and returns a single (double) argument.  It is not difficult to add support routines in order to handle arbitrary functions whose total number of input/output arguments is less than some maximum number (currently 10).</P>
<P CLASS="C-Code">
<A NAME="pgfId-33047"></A>typedef struct { </P>
<P CLASS="C-Code">
<A NAME="pgfId-33049"></A>  PyObject_HEAD </P>
<P CLASS="C-Code">
<A NAME="pgfId-33051"></A>  int *ranks, *canonical_ranks; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33109"></A>  int nin, nout, nargs; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33110"></A>  int identity; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33111"></A>  PyUFuncGenericFunction *functions; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33059"></A>  void **data; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33061"></A>  int ntypes, nranks, attributes; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33063"></A>  char *name, *types; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33065"></A>  int check_return; </P>
<P CLASS="C-Code">
<A NAME="pgfId-33022"></A>} PyUFuncObject;</P>
<P CLASS="Body">
<A NAME="pgfId-33134"></A>where:</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33140"></A>int *ranks</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35227"></A>unused.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-35249"></A>int *canonical_ranks</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35250"></A>unused</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-35251"></A>int nin</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-33145"></A>the number of input arguments to function</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33147"></A>int nout</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-33148"></A>the number of output arguments for the function</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33150"></A>int nargs</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-33151"></A>the total number of arguments  <EM CLASS="Code">
= nin + nout</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33153"></A>int identity</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35255"></A>a flag telling whether the identity for this function is <EM CLASS="Code">
0</EM>
 or <EM CLASS="Code">
1</EM>
 for use in the <EM CLASS="Code">
reduce</EM>
 method for a zero size array input.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33155"></A>PyUFuncGenericFunction *functions</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35267"></A>an array of functions that perform the innermost looping over the input and output arrays (I think this is over a single axis). These functions call the underlying math function with the data from the input arguments along this axis and return the outputs of the function into the correct place in the output arrayobject (with appropriate typecasting). These functions are called by the general looping code. There is one function for each of the supported datatypes. Function pointers to do this looping for types <EM CLASS="Code">
'f'</EM>
, <EM CLASS="Code">
'd'</EM>
, <EM CLASS="Code">
'F'</EM>
, and <EM CLASS="Code">
'D'</EM>
, are provided in the C-API for functions that take one or two arguments and return one argument. Each <EM CLASS="Code">
PyUFuncGenericFunction</EM>
 returns <EM CLASS="Code">
void</EM>
 and has the following argument list (in order):</P>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-33157"></A>args</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-35318"></A>an array of pointers to the data for each of the input and output arguments with input arguments first and output arguments immediately following. Each element of <EM CLASS="Code">
args</EM>
 is a <EM CLASS="Code">
char</EM>
 * to the first byte in the corresponding input or output array.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-35344"></A>dimensions</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-35348"></A>a pointer to a single <EM CLASS="Code">
int</EM>
 giving the size of the axis being looped over.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-35351"></A>steps</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-35371"></A>an array of <EM CLASS="Code">
int</EM>
s giving the number of bytes to skip to go to the next element of the array for this loop. There is an entry in the array for each of the input and output arguments, with input arguments first and output arguments immediately following.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-35352"></A>func</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-35387"></A>a pointer to the underlying math function to be called at each point in this inner loop. This is a <EM CLASS="Code">
void</EM>
 * and must be recast to the required type before actually calling the function e.g. to a pointer to a function that takes two <EM CLASS="Code">
double</EM>
s and returns a <EM CLASS="Code">
double</EM>
). If you need to write your own <EM CLASS="Code">
PyUFuncGenericFunction</EM>
, it is most readable to also have a <EM CLASS="Code">
typedef</EM>
 statement that defines your specific underlying function type so the function pointer cast is somewhat readable.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33159"></A>void **data</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35429"></A>a pointer to an array of functions (each cast to <EM CLASS="Code">
void</EM>
 *) that compute the actual mathematical function for each set of inputs and outputs. There should be a function in the array for each supported data type. This function will be called from the <EM CLASS="Code">
PyUFuncGenericFunction</EM>
 for the corresponding type.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-35336"></A>int ntypes</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35460"></A>the number of datatypes supported by this function. For datatypes that are not directly supported, a coercion will be performed if possible safely, otherwise an error will be reported.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33161"></A>int nranks</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-33162"></A>unused.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33163"></A>int attributes</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35470"></A>unused.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33165"></A>char *name</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35481"></A>the name of this function (not the same as the dictionary label for this function object, but it is usually set to the same string). It is printed when <EM CLASS="Code">
__repr__</EM>
 is called for this object, defaults to <EM CLASS="Code">
&quot;?&quot;</EM>
 if set to <EM CLASS="Code">
NULL</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33167"></A>char *types</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35503"></A>an array of supported types for this function object. I'm not sure why but each supported datatype (<EM CLASS="Code">
PyArray_FLOAT</EM>
, etc.) is entered as many times as there are arguments for this function. (<EM CLASS="Code">
nargs</EM>
)</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-33169"></A>int check_return</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-35528"></A>Usually best to set to 1. If this is non-zero then returned matrices will be cleaned up so that rank-0 arrays will be returned as python scalars. Also, if non-zero, then any math error that sets the <EM CLASS="Code">
errno</EM>
 global variable will cause an appropriate Python exception to be raised.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-590"></A>UfuncObject C API</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-34384"></A>There are currently 15 pointers in the C-API array for the ufuncobject which is loaded by <EM CLASS="Code">
import_ufunc()</EM>
. The macros implemented by this API, available by including the file <EM CLASS="Code">
ufuncobject.h</EM>
,' are given below. The only function normally called by user code is the ufuncobject creation function <EM CLASS="Code">
PyUFunc_FromFuncAndData</EM>
. Some of the other functions can be used as elements of an array to be passed to this creation function.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34392"></A>int <A NAME="marker-59768"></A>PyUFunc_Check(op)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34554"></A>returns <EM CLASS="Code">
1</EM>
 if op is a ufunc object otherwise returns <EM CLASS="Code">
0</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34555"></A>PyObject *<A NAME="marker-59769"></A>PyUFunc_FromFuncAndData(functions, data, types, ntypes, nin, nout, identity, name, check_return)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34561"></A>returns the ufunc object given its parameters. This is the most important function call. It requires defining three arrays to be passed as parameters: <EM CLASS="Code">
functions</EM>
, <EM CLASS="Code">
data</EM>
, and <EM CLASS="Code">
types</EM>
. The arguments to be passed are:</P>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34402"></A>functions</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34570"></A>an array of functions of type <EM CLASS="Code">
PyUFuncGenericFunction</EM>
, there should be one function for each supported datatype. The functions should be in order so that datatypes listed toward the beginning of the array could be cast as datatypes listed toward the end.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34406"></A>data</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34577"></A>an array of pointers to void* the same size as the functions array and in the same datatype order. Each element of this array is the actual underlying math function (recast to a <EM CLASS="Code">
void</EM>
 *) that will be called from one of the <EM CLASS="Code">
PyUFuncGenericFunctions</EM>
. It will operate on each element of the input NumPy <EM CLASS="Code">
arrayobject</EM>
(s) and return its element-by-element result in the output NumPy arrayobject(s). There is one function call for each datatype supported, (though functions can be repeated if you handle the typecasting appropriately with the <EM CLASS="Code">
PyUFuncGenericFunction</EM>
).</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34415"></A>types</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34594"></A>an array of<EM CLASS="Code">
 PyArray_Type</EM>
s. The size of this array should be (<EM CLASS="Code">
nin+nout</EM>
) times the size of one of the previous two arrays. There should be <EM CLASS="Code">
nin+nout</EM>
 copies of <EM CLASS="Code">
PyArray_XXXXX</EM>
 for each datatype explicitly supported. (Remember datatypes not explicitly supported will still be accepted as input arguments to the ufunc if they can be cast safely to a supported type.) </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34422"></A>ntypes</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34607"></A>the number of supported types for this ufunc.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34424"></A>nin</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34610"></A>the number of input arguments</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34426"></A>nout</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34427"></A>the number of output arguments</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34429"></A>identity</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34615"></A><EM CLASS="Code">
PyUFunc_One</EM>
, <EM CLASS="Code">
PyUFunc_Zero</EM>
, or <EM CLASS="Code">
PyUFunc_None</EM>
, depending on the desired value for the identity. This is only relevant for functions that take two input arguments and return one output argument. If not relevant use <EM CLASS="Code">
PyUFunc_None</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34434"></A>name</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34435"></A>the name of this <EM CLASS="Code">
ufuncobject</EM>
 for use in the <EM CLASS="Code">
__repr__</EM>
 method.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34437"></A>check_return</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34626"></A>the desired value for check_return for this ufuncobject.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34631"></A>int <A NAME="marker-59770"></A>PyUFunc_GenericFunction(self,args,mps)</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34668"></A>allows calling the ufunc from user C routine. It returns 0 on success and -1 on any failures. This is the core of what happens when a ufunc is called from Python. Its arguments are:</P>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34446"></A>self</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34675"></A>the ufunc object to be called. INPUT</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34447"></A>args</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34676"></A>a Python tuple object containing the input arguments to the ufunc (should be Python sequence objects). INPUT</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel3">
<A NAME="pgfId-34449"></A>mps</H6>
<P CLASS="BulletLevel3Continuation">
<A NAME="pgfId-34679"></A>an array of pointers to PyArrayObjects for the input and output arguments to this function. The input NumPy arrays are elements <EM CLASS="Code">
mps[0]...mps[self-&gt;nin-1]</EM>
. The output NumPy arrays are elements <EM CLASS="Code">
mps[self-&gt;nin]...mps[self-&gt;nargs-1]</EM>
. OUTPUT</P>
<P CLASS="FirstBody">
<A NAME="pgfId-34455"></A>The following are all functions of type <EM CLASS="Code">
PyUFuncGenericFunction</EM>
 and are suitable for use in the <EM CLASS="Code">
functions</EM>
 argument passed to <EM CLASS="Code">
PyUFunc_FromFuncAndData</EM>
:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34458"></A>PyUFunc_f_f_As_d_d</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34792"></A>for a unary function that takes a <EM CLASS="Code">
double</EM>
 input and returns a <EM CLASS="Code">
double</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_FLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_FLOAT</EM>
 output. </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-56074"></A>PyUFunc_d_d</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-56075"></A>for a using a unary function that takes a <EM CLASS="Code">
double</EM>
 input and returns a <EM CLASS="Code">
double</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_DOUBLE</EM>
 input and returns <EM CLASS="Code">
PyArray_DOUBLE</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34466"></A>PyUFunc_F_F_As_D_D</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34790"></A>for a unary function that takes a <EM CLASS="Code">
Py_complex</EM>
 input and returns a <EM CLASS="Code">
Py_complex</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_CFLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_CFLOAT</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34470"></A>PyUFunc_D_D</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34789"></A>for a unary function that takes a <EM CLASS="Code">
Py_complex</EM>
 input and returns a <EM CLASS="Code">
Py_complex</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_CFLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_CFLOAT</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34474"></A>PyUFunc_O_O</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34786"></A>for a unary function that takes a <EM CLASS="Code">
Py_Object</EM>
 * input and returns a <EM CLASS="Code">
Py_Object</EM>
 * output as a ufunc that takes <EM CLASS="Code">
PyArray_OBJECT</EM>
 input and returns <EM CLASS="Code">
PyArray_OBJECT</EM>
 output</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34731"></A>PyUFunc_ff_f_As_dd_d</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34785"></A>for a binary function that takes two <EM CLASS="Code">
double</EM>
 inputs and returns one <EM CLASS="Code">
double</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_FLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_FLOAT</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34482"></A>PyUFunc_dd_d</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34784"></A>for a binary function that takes two <EM CLASS="Code">
double</EM>
 inputs and returns one <EM CLASS="Code">
double</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_DOUBLE</EM>
 input and returns <EM CLASS="Code">
PyArray_DOUBLE</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34486"></A>PyUFunc_FF_F_As_DD_D</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34783"></A>for a binary function that takes two <EM CLASS="Code">
Py_complex</EM>
 inputs and returns a <EM CLASS="Code">
Py_complex</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_CFLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_CFLOAT</EM>
 output.</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34490"></A>PyUFunc_DD_D</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34782"></A>for a binary function that takes two <EM CLASS="Code">
Py_complex</EM>
 inputs and returns a <EM CLASS="Code">
Py_complex</EM>
 output as a ufunc that takes <EM CLASS="Code">
PyArray_CFLOAT</EM>
 input and returns <EM CLASS="Code">
PyArray_CFLOAT</EM>
 output </P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-56204"></A><EM CLASS="Code">
PyUFunc_OO_O</EM>
</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-56200"></A>for a unary function that takes two <EM CLASS="Code">
Py_Object</EM>
 * input and returns a <EM CLASS="Code">
Py_Object</EM>
 *<EM CLASS="Code">
 </EM>
output as a ufunc that takes <EM CLASS="Code">
PyArray_OBJECT</EM>
 input and returns <EM CLASS="Code">
PyArray_OBJECT</EM>
 output</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34498"></A>PyUFunc_O_O_method</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34775"></A>for a unary function that takes a <EM CLASS="Code">
Py_Object</EM>
 * input and returns a <EM CLASS="Code">
Py_Object *</EM>
 output and is pointed to by a Python method as a ufunc that takes PyArray_OBJECT input and returns PyArray_OBJECT output</P>
</DIV>
<DIV>
<H6 CLASS="CodeBulletLevel2">
<A NAME="pgfId-34503"></A>PyArrayMap</H6>
<P CLASS="BulletLev2Continuation">
<A NAME="pgfId-34774"></A>an exported API that was apparently considered but never implemented probably because the functionality is already available with Python's <EM CLASS="Code">
map</EM>
 function. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-57323"></A>14.	 <A NAME="92539"></A>Glossary</H2>
<P CLASS="Body">
<A NAME="pgfId-57324"></A>This section will define a few of the technical words used throughout this document.  [Please let us know of any additions to this list which you feel would be helpful -- the authors]</P>
<P CLASS="Definition">
<A NAME="pgfId-57325"></A><A NAME="marker-59791"></A>typecode: a single character describing the format of the data stored in an array.  For example, 'b' refers to unsigned byte-sized integers (0-255).</P>
<P CLASS="Definition">
<A NAME="pgfId-57326"></A><A NAME="marker-59792"></A>ufunc / <A NAME="marker-59793"></A>universal function: a ufunc is a callable object which performs operations on all of the elements of its arguments, which can be lists, tuples, or arrays.  Many ufuncs are defined in the <EM CLASS="Code">
umath</EM>
 module.</P>
<P CLASS="Definition">
<A NAME="pgfId-57327"></A><A NAME="marker-59794"></A>array / <A NAME="marker-59795"></A>multiarray: an array refers to the Python object type defined by the NumPy extensions to store and manipulate numbers efficiently.</P>
<P CLASS="Definition">
<A NAME="pgfId-57328"></A><A NAME="marker-59796"></A>UserArray: The UserArray module defines a UserArray class which should be subclassed by users wishing to have classes which behave similarly to the array object type.</P>
<P CLASS="Definition">
<A NAME="pgfId-57329"></A><A NAME="marker-59797"></A>Matrix: The Matrix module defines a subclass Matrix of the UserArray class which is specialized for linear algebra matrices.  Most notably, it overrides the multiplication operator on Matrix instances to perform matrix multiplication instead of element-wise multiplication.</P>
<P CLASS="Definition">
<A NAME="pgfId-57330"></A><A NAME="marker-59798"></A>rank: the rank of an array is the number of dimensions it has, or the number of integers in its shape tuple.</P>
<P CLASS="Definition">
<A NAME="pgfId-57331"></A><A NAME="marker-59799"></A>shape: array objects have an attribute called shape which is necessarily a tuple.  An array with an empty tuple shape is treated like a scalar (it holds one element).</P>
<P CLASS="Body">
<A NAME="pgfId-57345"></A>&nbsp;</P>
</DIV>
<DIV>
<H2 CLASS="ChapterSet">
<A NAME="pgfId-304408"></A></h2>
<DIV>
</DIV>
Part II: <A NAME="90799"></A>Optional Packages<DIV>
</DIV>
<P CLASS="ChapterDescription">
<A NAME="pgfId-304409"></A>This part contains descriptions of the packages that are included with the distribution but which are not necessary for using Numeric arrays. The packages are for the most part in the Packages subdirectory of the source distribution, and can be installed anywhere in the Python module search path. Each has its own &quot;setup.py&quot; to use to build and install the package.<BR>
<BR>
For historical reasons, some of these packages are currently installed inside the Numeric package rather than on their own. We hope to remedy this in the future.</P>
<P CLASS="FirstBody">
<A NAME="pgfId-305577"></A>The subdirectory Packages contains directories, each of which contains its own installation script setup.py. As with the main directory, these packages are generally compiled and installed using the command </P>
<P CLASS="Body">
<A NAME="pgfId-305578"></A>python setup.py install</P>
<P CLASS="Body">
<A NAME="pgfId-305579"></A>The Makefile in the main directory will do this for all the packages provided. </P>
<P CLASS="Body">
<A NAME="pgfId-305580"></A>In addition, many people make available libraries that use Numeric. At the moment a centralized reference for these does not exist, but they are usually announced on the discussion list; also check the project web page.<A NAME="13771"></A></P>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="TableTitle">
<A NAME="pgfId-305588"></A>Descriptions of the Optional Packages</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-305594"></A>Package Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-305596"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-305598"></A>Reference</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305600"></A>FFT</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305602"></A>Fast Fourier Transforms</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305607"></A><A HREF="numdoc.html#FFT" CLASS="XRef">FFT Reference</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305609"></A>LinearAlgebra</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305611"></A>Basic linear algebra</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305615"></A><A HREF="numdoc.html#32826" CLASS="XRef">LinearAlgebra Reference</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305618"></A>RandomArray</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305620"></A>Arrays of random numbers.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305624"></A><A HREF="numdoc.html#40886" CLASS="XRef">RandomArray Reference</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305627"></A>RNG</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305629"></A>Generators for independent streams of random numbers from various distributions and arrays of same.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305633"></A><A HREF="numdoc.html#71863" CLASS="XRef">Independent Random Streams</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305636"></A>MA</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305638"></A>Masked arrays, that is, arrays that have missing or invalid entries.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305643"></A><A HREF="numdoc.html#48250" CLASS="XRef">Masked Arrays</A></P>
</TD>
</TR>
</TABLE>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-304744"></A><A NAME="66303"></A>License and disclaimer for packages MA and RNG</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-304767"></A>Package MA was written by Paul Dubois, LLNL. Package RNG was written by Konrad Hinsen after modifying an earlier package UNRG by Paul Dubois and Fred Fritsch.</P>
<P CLASS="Body">
<A NAME="pgfId-304757"></A>Copyright (c) 1999, 2000. The Regents of the University of California. All rights reserved. </P>
<P CLASS="Body">
<A NAME="pgfId-304724"></A>Permission to use, copy, modify, and distribute this software for any purpose without fee is hereby granted, provided that this entire notice is included in all copies of any software which is or includes a copy or modification of this software and in all copies of the supporting documentation for such software.</P>
<P CLASS="Body">
<A NAME="pgfId-304725"></A>This work was produced at the University of California, Lawrence Livermore National Laboratory under contract no. W-7405-ENG-48 between the U.S. Department of Energy and The Regents of the University of California for the operation of UC LLNL. </P>
<P CLASS="Body">
<A NAME="pgfId-304726"></A>DISCLAIMER</P>
<P CLASS="Body">
<A NAME="pgfId-304727"></A>This software was prepared as an account of work sponsored by an agency of the United States Government. Neither the United States Government nor the University of California nor any of their employees, makes any warranty, express or implied, or assumes any liability or responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately-owned rights. Reference herein to any specific commercial products, process, or service by trade name, trademark, manufacturer, or otherwise, does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States Government or the University of California. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States Government or the University of California, and shall not be used for advertising or product endorsement purposes.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-304711"></A>15.	 <A NAME="FFT"></A>FFT Reference</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-302951"></A>The <A NAME="marker-302950"></A>FFT.py module provides a simple interface to the FFTPACK FORTRAN library, which is a powerful standard library for doing fast Fourier transforms of real and complex data sets, or the C fftpack library, which is algorithmically based on FFTPACK and provides a compatible interface.  On some platforms, optimized version of one of these libraries may be available, and can be used to provide optimal performance (see <A HREF="numdoc.html#41147" CLASS="XRef">Compilation Notes</A>).</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-302955"></A>Python Interface</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302956"></A>The Python user imports the FFT module, which provides a set of utility functions which provide access to the most commonly used FFT routines, and allows the specification of which axes (dimensions) of the input arrays are to be used for the FFT's.  These routines are:</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302958"></A><A NAME="marker-302957"></A>fft(data, n=None, axis=-1)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302959"></A>Performs a n-point discrete Fourier transform of the array data.  <EM CLASS="Code">
n</EM>
 defaults to the size of data.  It is most efficient for n a power of two.   If n is larger than <EM CLASS="Code">
data</EM>
, then <EM CLASS="Code">
data</EM>
 will be zero-padded to make up the difference. If n is smaller than data, then <EM CLASS="Code">
data</EM>
 will be aliased to reduce its size. This also stores a cache of working memory for different sizes of fft's, so you could theoretically run into memory problems if you call this too many times with too many different n's.</P>
<P CLASS="Body">
<A NAME="pgfId-302960"></A>The FFT is performed along the axis indicated by the <EM CLASS="Code">
axis</EM>
 argument, which defaults to be the last dimension of <EM CLASS="Code">
data</EM>
.</P>
<P CLASS="Body">
<A NAME="pgfId-302961"></A>The format of the returned array is a complex array of the same shape as <EM CLASS="Code">
data</EM>
, where the first element in the result array contains the DC (steady-state) value of the FFT, and where each successive ...XXX</P>
<P CLASS="Body">
<A NAME="pgfId-302962"></A>Example of use:</P>
<P CLASS="Python">
<A NAME="pgfId-302963"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print fft(array((1,0,1,0,1,0,1,0))+ 10).real</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302964"></A>[ 84.   0.   0.   0.   4.   0.   0.   0.]</P>
<P CLASS="Python">
<A NAME="pgfId-302965"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print fft(array((0,1,0,1,0,1,0,1))+ 10).real</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302966"></A>[ 84.   0.   0.   0.  -4.   0.   0.   0.]</P>
<P CLASS="Python">
<A NAME="pgfId-302967"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print fft(array((0,1,0,0,0,1,0,0))+ 10).real</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302968"></A>[ 82.   0.   0.   0.  -2.   0.   0.   0.]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302970"></A><A NAME="marker-302969"></A>inverse_fft(data, n=None, axis=-1)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302971"></A>Will return the <EM CLASS="Code">
n</EM>
 point inverse discrete Fourier transform of <EM CLASS="Code">
data</EM>
. <EM CLASS="Code">
n</EM>
 defaults to the length of <EM CLASS="Code">
data</EM>
. This is most efficient for <EM CLASS="Code">
n</EM>
 a power of two. If <EM CLASS="Code">
n</EM>
 is larger than <EM CLASS="Code">
data</EM>
, then <EM CLASS="Code">
data</EM>
 will be zero-padded to make up the difference. If <EM CLASS="Code">
n</EM>
 is smaller than <EM CLASS="Code">
data</EM>
, then <EM CLASS="Code">
data</EM>
 will be aliased to reduce its size. This also stores a cache of working memory for different sizes of FFT's, so you could theoretically run into memory problems if you call this too many times with too many different <EM CLASS="Code">
n</EM>
's. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302973"></A><A NAME="marker-302972"></A>real_fft(data, n=None, axis=-1)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302974"></A>Will return the <EM CLASS="Code">
n</EM>
 point discrete Fourier transform of the real valued array <EM CLASS="Code">
data</EM>
. <EM CLASS="Code">
n</EM>
 defaults to the length of <EM CLASS="Code">
data</EM>
. This is most efficient for <EM CLASS="Code">
n</EM>
 a power of two. The returned array will be one half of the symmetric complex transform of the real array. </P>
<P CLASS="Python">
<A NAME="pgfId-302975"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = cos(arange(30.0)/30.0*2*pi)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302976"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print real_fft(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-302977"></A>[ -1.        +0.j          13.69406641+2.91076367j</P>
<P CLASS="Python">
<A NAME="pgfId-302978"></A>       -0.91354546-0.40673664j  -0.80901699-0.58778525j</P>
<P CLASS="Python">
<A NAME="pgfId-302979"></A>       -0.66913061-0.74314483j  -0.5       -0.8660254j</P>
<P CLASS="Python">
<A NAME="pgfId-302980"></A>       -0.30901699-0.95105652j  -0.10452846-0.9945219j</P>
<P CLASS="Python">
<A NAME="pgfId-302981"></A>        0.10452846-0.9945219j    0.30901699-0.95105652j</P>
<P CLASS="Python">
<A NAME="pgfId-302982"></A>        0.5       -0.8660254j    0.66913061-0.74314483j</P>
<P CLASS="Python">
<A NAME="pgfId-302983"></A>        0.80901699-0.58778525j   0.91354546-0.40673664j</P>
<P CLASS="Python">
<A NAME="pgfId-302984"></A>        0.9781476 -0.20791169j   1.        +0.j        ]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302986"></A><A NAME="marker-302985"></A>inverse_real_fft(data, n=None, axis=-1)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302987"></A>Will return the inverse FFT of the real valued array <EM CLASS="Code">
data</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302988"></A>fft2d(data, s=None, axes=(-2,-1))	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302989"></A>Will return the 2-dimensional FFT of the array <EM CLASS="Code">
data</EM>
.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-302990"></A>real_fft2d(data, s=None, axes=(-2,-1))	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302991"></A>Will return the 2d FFT of the real valued array <EM CLASS="Code">
data</EM>
. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-302992"></A>C API</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-302993"></A>The interface to the FFTPACK library is performed via the fftpackmodule module, which is responsible for making sure that the arrays sent to the FFTPACK routines are in the right format (contiguous memory locations, right numerical storage format, etc).  It provides interfaces to the following FFTPACK routines, which are also the names of the Python functions:</P>
<UL>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302994"></A><EM CLASS="Code">
cffti(i)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302995"></A><EM CLASS="Code">
cfftf(data, savearea)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302996"></A><EM CLASS="Code">
cfftb(data, savearea)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302997"></A><EM CLASS="Code">
rffti(i)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302998"></A><EM CLASS="Code">
rfftf(data, savearea)</EM>
</LI>
<LI CLASS="BulletLev2">
<A NAME="pgfId-302999"></A><EM CLASS="Code">
rfftb(data, savearea)</EM>
</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-303000"></A>The routines which start with <EM CLASS="Code">
c</EM>
 expect arrays of complex numbers, the routines which start with <EM CLASS="Code">
r</EM>
 expect real numbers only. The routines which end with <EM CLASS="Code">
i</EM>
 are the initalization functions, those which end with <EM CLASS="Code">
f</EM>
 perform the forward FFTs and those which end with <EM CLASS="Code">
b</EM>
 perform the backwards FFTs.</P>
<P CLASS="Body">
<A NAME="pgfId-303001"></A>The initialization functions require a single integer argument corresponding to the size of the dataset, and returns a work array. The forward and backwards FFTs require two array arguments -- the first is the data array, the second is the work array returned by the initialization function. They return arrays corresponding to the coefficients of the FFT, with the first element in the returned array corresponding to the DC component, the second one to the first fundamental, etc.The length of the returned array is 1 + half the length of the input array in the case of real FFTs, and the same size as the input array in the case of complex data.</P>
<P CLASS="Python">
<A NAME="pgfId-303002"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = cos(arange(30.0)/30.0*2*pi)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303003"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
w = rffti(30)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303004"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
f = rfftf(x, w)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303005"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
f[0]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303006"></A>(-1+0j)</P>
<P CLASS="Python">
<A NAME="pgfId-303007"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
f[1]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303008"></A>(13.6940664103+2.91076367145j)</P>
<P CLASS="Python">
<A NAME="pgfId-303009"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
f[2]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303010"></A>(-0.913545457643-0.406736643076j)</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-303012"></A><A NAME="41147"></A>Compilation Notes</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303013"></A>On some platforms, precompiled optimized versions of the FFTPACK library are preinstalled on the operating system, and the compilation procedure needs to be modified to force the fftpackmodule file to be linked against those rather than the fftpacklite.c file which is shipped with NumPy.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-303015"></A>16.	 <A NAME="32826"></A>LinearAlgebra Reference</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-303016"></A>The LinearAlgebra.py module provides a simple interface to the low-level linear algebra routines provided by either the LAPACK FORTRAN library or the compatible lapack_lite C library.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-303017"></A>Python Interface</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303019"></A><A NAME="marker-303018"></A>solve_linear_equations(a, b)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303020"></A>This function solves a system of linear equations with a square non-singular matrix a and a right-hand-side vector b. Several right-hand-side vectors can be treated simultaneously by making b a two-dimensional array (i.e. a sequence of vectors). The function inverse(a) calculates the inverse of the square non-singular matrix a by calling solve_linear_equations(a, b) with a suitable b. </P>
<P CLASS="FirstBody">
<A NAME="pgfId-303021"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303023"></A><A NAME="marker-303022"></A>inverse(a)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303024"></A>This function returns the inverse of the specified matrix a which must be square and non-singular. To within floating point precision, it should always be true that:</P>
<P CLASS="Python">
<A NAME="pgfId-303025"></A>matrixmultiply(a, inverse(a)) == identity(len(a))</P>
<P CLASS="Body">
<A NAME="pgfId-303026"></A>To test this claim, one can do e.g.:</P>
<P CLASS="Python">
<A NAME="pgfId-303027"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
a = reshape(arange(25.0), (5,5)) + identity(5)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303028"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303029"></A>[[  1.   1.   2.   3.   4.]</P>
<P CLASS="Python">
<A NAME="pgfId-303030"></A> [  5.   7.   7.   8.   9.]</P>
<P CLASS="Python">
<A NAME="pgfId-303031"></A> [ 10.  11.  13.  13.  14.]</P>
<P CLASS="Python">
<A NAME="pgfId-303032"></A> [ 15.  16.  17.  19.  19.]</P>
<P CLASS="Python">
<A NAME="pgfId-303033"></A> [ 20.  21.  22.  23.  25.]]</P>
<P CLASS="Python">
<A NAME="pgfId-303034"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
inv_a = inverse(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303035"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print inv_a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303036"></A>[[ 0.20634921 -0.52380952 -0.25396825  0.01587302  0.28571429]</P>
<P CLASS="Python">
<A NAME="pgfId-303037"></A> [-0.5026455   0.63492063 -0.22751323 -0.08994709  0.04761905]</P>
<P CLASS="Python">
<A NAME="pgfId-303038"></A> [-0.21164021 -0.20634921  0.7989418  -0.1957672  -0.19047619]</P>
<P CLASS="Python">
<A NAME="pgfId-303039"></A> [ 0.07936508 -0.04761905 -0.17460317  0.6984127  -0.42857143]</P>
<P CLASS="Python">
<A NAME="pgfId-303040"></A> [ 0.37037037  0.11111111 -0.14814815 -0.40740741  0.33333333]]</P>
<P CLASS="Python">
<A NAME="pgfId-303041"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
# Verify the inverse by printing the largest absolute element</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303042"></A>... <EM CLASS="CodeInput">
# of a * a^{-1} - identity(5)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303043"></A>... <EM CLASS="CodeInput">
print &quot;Inversion error:&quot;, &#92;</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303044"></A>... <EM CLASS="CodeInput">
maximum.reduce(fabs(ravel(dot(a, inv_a)-identity(5))))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303045"></A>Inversion error: 2.6645352591e-015</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303047"></A><A NAME="marker-303046"></A>eigenvalues(a)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303048"></A>This function returns the eigenvalues of the square matrix a. </P>
<P CLASS="Python">
<A NAME="pgfId-303049"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303050"></A>[[ 1.  0.  0.  0.  0.]</P>
<P CLASS="Python">
<A NAME="pgfId-303051"></A> [ 0.  2.  0.  0.  1.]</P>
<P CLASS="Python">
<A NAME="pgfId-303052"></A> [ 0.  0.  3.  0.  0.]</P>
<P CLASS="Python">
<A NAME="pgfId-303053"></A> [ 0.  0.  0.  4.  0.]</P>
<P CLASS="Python">
<A NAME="pgfId-303054"></A> [ 0.  0.  0.  0.  1.]]</P>
<P CLASS="Python">
<A NAME="pgfId-303055"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print eigenvalues(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303056"></A>[ 1.  2.  3.  4.  1.]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303058"></A><A NAME="marker-303057"></A>eigenvectors(a)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303059"></A>This function returns both the eigenvalues and the eigenvectors, the latter as a two-dimensional array (i.e. a sequence of vectors).</P>
<P CLASS="Python">
<A NAME="pgfId-303060"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print a</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303061"></A>[[ 1.  0.  0.  0.  0.]</P>
<P CLASS="Python">
<A NAME="pgfId-303062"></A> [ 0.  2.  0.  0.  1.]</P>
<P CLASS="Python">
<A NAME="pgfId-303063"></A> [ 0.  0.  3.  0.  0.]</P>
<P CLASS="Python">
<A NAME="pgfId-303064"></A> [ 0.  0.  0.  4.  0.]</P>
<P CLASS="Python">
<A NAME="pgfId-303065"></A> [ 0.  0.  0.  0.  1.]]</P>
<P CLASS="Python">
<A NAME="pgfId-303066"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
evalues, evectors = eigenvectors(a)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303067"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print evalues</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303068"></A>[ 1.  2.  3.  4.  1.]</P>
<P CLASS="Python">
<A NAME="pgfId-303069"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print evectors</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303070"></A>[[ 1.          0.          0.          0.          0.        ]</P>
<P CLASS="Python">
<A NAME="pgfId-303071"></A> [ 0.          1.          0.          0.          0.        ]</P>
<P CLASS="Python">
<A NAME="pgfId-303072"></A> [ 0.          0.          1.          0.          0.        ]</P>
<P CLASS="Python">
<A NAME="pgfId-303073"></A> [ 0.          0.          0.          1.          0.        ]</P>
<P CLASS="Python">
<A NAME="pgfId-303074"></A> [ 0.         -0.70710678  0.          0.          0.70710678]]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303076"></A><A NAME="marker-303075"></A>singular_value_decomposition(a, full_matrices=0)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303077"></A>This function returns three arrays V, S, and WT whose matrix product is the original matrix a. V and WT are unitary matrices (rank-2 arrays), whereas S is the vector (rank-1 array) of diagonal elements of the singular-value matrix. This function is mainly used to check whether (and in what way) a matrix is ill-conditioned.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303079"></A><A NAME="marker-303078"></A>generalized_inverse(a, rcond=1e-10)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303080"></A>This function returns the generalized inverse (also known as pseudo-inverse or Moore-Penrose-inverse) of the matrix a. It has numerous applications related to linear equations and least-squares problems.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303082"></A><A NAME="marker-303081"></A>determinant(a)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303083"></A>This function returns the determinant of the square matrix a.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303085"></A><A NAME="marker-303084"></A>linear_least_squares(a, b, rcond=e-10)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303086"></A>This function returns the least-squares solution of an overdetermined system of linear equations. An optional third argument indicates the cutoff for the range of singular values (defaults to 10-10). There are four return values: the least-squares solution itself, the sum of the squared residuals (i.e. the quantity minimized by the solution), the rank of the matrix a, and the singular values of a in descending order.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-303088"></A>Compilation Notes</H6>
<P CLASS="Body">
<A NAME="pgfId-303089"></A>On some platforms, precompiled optimized versions of the LAPACK library are preinstalled on the operating system, and the setup procedure needs to be modified to force the lapackmodule.c file to be linked against those rather than the lapack_lite library.</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-303091"></A>17.	 <A NAME="40886"></A>RandomArray Reference</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-303093"></A>The <A NAME="marker-303092"></A>RandomArray.py module (in conjunction with the ranlibmodule.c file) provides a high-level interface to the ranlib module, which provides a good quality C implementation of a random-number generator.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-303094"></A>Python Interface</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303096"></A><A NAME="marker-303095"></A>seed(x=0, y=0)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303097"></A>The <EM CLASS="Code">
seed()</EM>
 function takes two integers and sets the two seeds of the random number generator to those values. If the default values of 0 are used for both x and y, then a seed is generated from the current time, providing a pseudo-random seed.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303099"></A><A NAME="marker-303098"></A>get_seed()	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303100"></A>The <EM CLASS="Code">
get_seed()</EM>
 function returns the two seeds used by the current random-number generator. It is most often used to find out what seeds the seed() function chose at the last iteration. [thread-safety issue?]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303102"></A><A NAME="marker-303101"></A>random(shape=<EM CLASS="Emphasis">
ReturnFloat</EM>
)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303103"></A>The <EM CLASS="Code">
random()</EM>
 function takes a shape, and returns an array of double-precision floatings point numbers between 0.0 and 1.0. Neither 0.0 nor 1.0 is ever returned by this function. If no argument is specified, the function returns a single floating point number (not an array). The array is filled from the generator following the canonical array organization (see discussion of the <EM CLASS="Code">
.flat</EM>
 attribute)</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303105"></A><A NAME="marker-303104"></A>uniform(minimum, maximum, shape=ReturnFloat)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303106"></A>The <EM CLASS="Code">
uniform()</EM>
 function returns an array of the specified shape and containing double-precision floating point random numbers strictly between minimum and maximum. If no shape is specified, a single number is returned.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303108"></A><A NAME="marker-303107"></A>randint(minimum, maximum, shape=ReturnFloat)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303109"></A>The <EM CLASS="Code">
randint()</EM>
 function returns an array of the specified shape and containing random (standard) integers greater than or equal to <EM CLASS="Code">
minimum</EM>
 and strictly less than <EM CLASS="Code">
maximum</EM>
. If no shape is specified, a single number is returned.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-303111"></A><A NAME="marker-303110"></A>permutation(n)	</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-303112"></A>The <EM CLASS="Code">
permutation()</EM>
 function returns an array of the integers between <EM CLASS="Code">
0</EM>
 and <EM CLASS="Code">
n-1</EM>
, in an array of shape <EM CLASS="Code">
(n,)</EM>
, and with its elements randomly permuted.</P>
<P CLASS="Body">
<A NAME="pgfId-303113"></A>An example use of the RandomArray module (exact output will be different each time!):</P>
<P CLASS="Python">
<A NAME="pgfId-303114"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
from RandomArray import *</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303115"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
seed()								</EM>
# Set seed based on current time</P>
<P CLASS="Python">
<A NAME="pgfId-303116"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print get_seed()								</EM>
# Find out what seeds were used</P>
<P CLASS="Python">
<A NAME="pgfId-303117"></A>(897800491, 192000)</P>
<P CLASS="Python">
<A NAME="pgfId-303118"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print random()</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303119"></A>0.0528018975065</P>
<P CLASS="Python">
<A NAME="pgfId-303120"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print random((5,2))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303121"></A>[[ 0.14833829  0.99031458]</P>
<P CLASS="Python">
<A NAME="pgfId-303122"></A> [ 0.7526806   0.09601787]</P>
<P CLASS="Python">
<A NAME="pgfId-303123"></A> [ 0.1895229   0.97674777]</P>
<P CLASS="Python">
<A NAME="pgfId-303124"></A> [ 0.46134511  0.25420982]</P>
<P CLASS="Python">
<A NAME="pgfId-303125"></A> [ 0.66132009  0.24864472]]</P>
<P CLASS="Python">
<A NAME="pgfId-303126"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print uniform(-1,1,(10,))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303127"></A>[ 0.72168852 -0.75374185 -0.73590945  0.50488248 -0.74462822  0.09293685</P>
<P CLASS="Python">
<A NAME="pgfId-303128"></A>      -0.65898308  0.9718067  -0.03252475  0.99611011]</P>
<P CLASS="Python">
<A NAME="pgfId-303129"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print randint(0,100, (12,))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303130"></A>[28  5 96 19  1 32 69 40 56 69 53 44]</P>
<P CLASS="Python">
<A NAME="pgfId-303131"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print permutation(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-303132"></A>[4 2 8 9 1 7 3 6 5 0]</P>
<P CLASS="Python">
<A NAME="pgfId-303133"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
seed(897800491, 192000)								</EM>
# resetting the same seeds</P>
<P CLASS="Python">
<A NAME="pgfId-303134"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print random()								</EM>
# yields the same numbers</P>
<P CLASS="Python">
<A NAME="pgfId-303135"></A>0.0528018975065</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-305397"></A>Floating point random arrays</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305398"></A>standard_normal (shape=ReturnFloat) </H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305399"></A>The standard_normal () function returns an array of the specified shape that contains double precision floating point numbers normally (Gaussian) distributed with mean zero and variance and standard deviation one. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305400"></A>normal (mean, stddev, shape=ReturnFloat) </H6>
<P CLASS="Body">
<A NAME="pgfId-305401"></A>The normal () function returns an array of the specified shape that contains double precision floating point numbers normally distributed with the specified mean and standard deviation. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305402"></A>multivariate_normal (mean, covariance) or <BR>
multivariate_normal (mean, covariance, leadingAxesShape) </H6>
<P CLASS="Body">
<A NAME="pgfId-305403"></A>The multivariate_normal () function takes a one dimensional array argument mean and a two dimensional array argument covariance. Suppose the shape of mean is (n,). Then the shape of covariance must be (n,n). The multivariate_normal () function returns a double precision floating point array. The effect of the leadingAxesShape parameter is: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-305404"></A>If no leadingAxesShape is specified, then an array with shape (n,) is returned containing a vector of numbers with a multivariate normal distribution with the specified mean and covariance.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305405"></A>If leadingAxesShape is specified, then an array of such vectors is returned. The shape of the output is leadingAxesShape.append ((n,)). The leading indices into the output array select a multivariate normal from the array. The final index selects one number from within the multivariate normal.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-305406"></A>In either case, the behavior of multivariate_normal () is undefined if covariance is not symmetric and positive definite. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305407"></A>exponential (mean, shape=ReturnFloat) </H6>
<P CLASS="Body">
<A NAME="pgfId-305408"></A>The exponential () function returns an array of the specified shape that contains double precision floating point numbers exponentially distributed with the specified mean. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305409"></A>beta (a, b, shape=ReturnFloat) </H6>
<P CLASS="Body">
<A NAME="pgfId-305410"></A>The beta () function returns an array of the specified shape that contains double precision floating point numbers beta distributed with alpha parameter a and beta parameter b. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305411"></A>gamma (a, r, shape=ReturnFloat) </H6>
<P CLASS="Body">
<A NAME="pgfId-305412"></A>The gamma () function returns an array of the specified shape that contains double precision floating point numbers beta distributed with location parameter a and distribution shape parameter r. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305413"></A>chi_square (df, shape=ReturnFloat) </H6>
<P CLASS="Body">
<A NAME="pgfId-305414"></A>The chi_square() function returns an array of the specified shape that contains double precision floating point numbers with the chi square distribution with df degrees of freedom. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305415"></A>noncentral_chi_square (df, nonc, shape=ReturnFloat) </H6>
<P CLASS="Body">
<A NAME="pgfId-305416"></A>The noncentral_chi_square() function returns an array of the specified shape that contains double precision floating point numbers with the chi square distribution with df degrees of freedom and noncentrality parameter nconc. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305417"></A>F (dfn, dfd, shape=ReturnFloat) </H6>
<P CLASS="Body">
<A NAME="pgfId-305418"></A>The F () function returns an array of the specified shape that contains double precision floating point numbers with the F distribution with dfn degrees of freedom in the numerator and dfd degrees of freedom in the denominator. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305419"></A>noncentral_F (dfn, dfd, nconc, shape=ReturnFloat) </H6>
<P CLASS="Body">
<A NAME="pgfId-305420"></A>The noncentral_F () function returns an array of the specified shape that contains double precision floating point numbers with the F distribution with dfn degrees of freedom in the numerator, dfd degrees of freedom in the denominator, and noncentrality parameter nconc. If no shape is specified, a single number is returned. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-305421"></A>Integer random arrays</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305422"></A>binomial (trials, prob, shape=ReturnInt) </H6>
<P CLASS="Body">
<A NAME="pgfId-305423"></A>The binomial () function returns an array with the specified shape that contains integer numbers with the binomial distribution with trials trials and event probability prob. In other words, each value in the returned array is the number of times an event with probability prob occurred within trials repeated trials. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305424"></A>negative_binomial (trials, prob, shape=ReturnInt)</H6>
<P CLASS="Body">
<A NAME="pgfId-305425"></A>The negative_binomial () function returns an array with the specified shape that contains integer numbers with the negative binomial distribution with trials trials and event probability prob. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305426"></A>poisson (mean, shape=ReturnInt) </H6>
<P CLASS="Body">
<A NAME="pgfId-305427"></A>The poisson () function returns an array with the specified shape that contains integer numbers with the Poisson distribution with the specified mean. If no shape is specified, a single number is returned. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305428"></A>multinomial (trials, probs) or multinomial (trials, probs, leadingAxesShape) </H6>
<P CLASS="Body">
<A NAME="pgfId-305429"></A>The multinomial () function returns an array with that contains integer numbers with the multinomial distribution with trials trials and event probabilities given in probs. probs must be a one dimensional array. There are len(probs)+1 events. probs[i] is the probability of the i-th event for 0&lt;=i&lt;len(probs). The probability of event len(probs) is 1.-Numeric.sum(prob). </P>
<P CLASS="Body">
<A NAME="pgfId-305430"></A>The first form returns an integer array of shape (len(probs)+1,) containing one multinomially distributed vector. The second form returns an array of shape (m, n, ..., len(probs)+1) where (m, n, ...) is leadingAxesShape. In this case, each output[i,j,...,:] is an integer array of shape (len(prob)+1,) containing one multinomially distributed vector.. </P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-305431"></A>Examples</H6>
<P CLASS="Body">
<A NAME="pgfId-305432"></A>Most of the functions in this package take zero or more distribution specific parameters plus an optional shape parameter. The shape parameter gives the shape of the output array: </P>
<P CLASS="Python">
<A NAME="pgfId-305433"></A><EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
from RandomArray import *</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
print standard_normal()</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
-0.435568600893</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
print standard_normal(5)</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
[-1.36134553 0.78617644 -0.45038718 0.18508556 0.05941355]</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
print standard_normal((5,2))</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
[[ 1.33448863 -0.10125473]</EM>
 <BR>
 <EM CLASS="HTML-Typewriter">
[ 0.66838062 0.24691346]</EM>
 <BR>
 <EM CLASS="HTML-Typewriter">
[-0.95092064 0.94168913]</EM>
 <BR>
 <EM CLASS="HTML-Typewriter">
[-0.23919107 1.89288616]</EM>
 <BR>
 <EM CLASS="HTML-Typewriter">
[ 0.87651485 0.96400219]]</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
print normal(7., 4., (5,2)) #mean=7, std. dev.=4 <BR>
</EM>
<EM CLASS="HTML-Typewriter">
[[ 2.66997623 11.65832615]</EM>
 <BR>
 <EM CLASS="HTML-Typewriter">
[ 6.73916003 6.58162862]</EM>
 <BR>
 <EM CLASS="HTML-Typewriter">
[ 8.47180378 4.30354905]</EM>
 <BR>
 <EM CLASS="HTML-Typewriter">
[ 1.35531998 -2.80886841]</EM>
 <BR>
 <EM CLASS="HTML-Typewriter">
[ 7.07408469 11.39024973]]</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
print exponential(10., 5) #mean=10 <BR>
</EM>
<EM CLASS="HTML-Typewriter">
[ 18.03347754 7.11702306 9.8587961 32.49231603 28.55408891]</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
print beta(3.1, 9.1, 5) # alpha=3.1, beta=9.1 <BR>
</EM>
<EM CLASS="HTML-Typewriter">
[ 0.1175056 0.17504358 0.3517828 0.06965593 0.43898219]</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
print chi_square(7, 5)</EM>
<EM CLASS="HTML-Typewriter">
 </EM>
<EM CLASS="CodeInput">
# 7 degrees of freedom (dfs) <BR>
</EM>
<EM CLASS="HTML-Typewriter">
[ 11.99046516 3.00741053 4.72235727 6.17056274 8.50756836]</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
print noncentral_chi_square(7, 3, 5) # 7 dfs, noncentrality 3</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
[ 18.28332138 4.07550335 16.0425396 9.51192093 9.80156231]</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
F(5, 7, 5) # 5 and 7 dfs</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
array([ 0.24693671, 3.76726145, 0.66883826, 0.59169068, 1.90763224])</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
noncentral_F(5, 7, 3., 5) # 5 and 7 dfs, noncentrality 3</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
array([ 1.17992553, 0.7500126 , 0.77389943, 9.26798989, 1.35719634])</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
binomial(32, .5, 5) # 32 trials, prob of an event = .5 <BR>
</EM>
<EM CLASS="HTML-Typewriter">
array([12, 20, 21, 19, 17])</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
negative_binomial(32, .5, 5) # 32 trials: prob of an event = .5</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
array([21, 38, 29, 32, 36])</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-305434"></A>Two functions that return generate multivariate random numbers (that is, random vectors with some known relationship between the elements of each vector, defined by the distribution). They are multivariate_normal () and multinomial (). For these two functions, the lengths of the leading axes of the output may be specified. The length of the last axis is determined by the length of some other parameter. </P>
<P CLASS="Python">
<A NAME="pgfId-305435"></A><EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
multivariate_normal([1,2], [[1,2],[2,1]], [2,3])</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
array([[[ 0.14157988, 1.46232224],</EM>
 <BR>
       <EM CLASS="HTML-Typewriter">
 [-1.11820295, -0.82796288],</EM>
 <BR>
       <EM CLASS="HTML-Typewriter">
 [ 1.35251635, -0.2575901 ]],</EM>
 <BR>
      <EM CLASS="HTML-Typewriter">
 [[-0.61142141, 1.0230465 ],</EM>
 <BR>
       <EM CLASS="HTML-Typewriter">
 [-1.08280948, -0.55567217],</EM>
 <BR>
       <EM CLASS="HTML-Typewriter">
 [ 2.49873002, 3.28136372]]])</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
x = multivariate_normal([10,100], [[1,2],[2,1]], 10000)</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
x_mean = sum(x)/10000</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
print x_mean</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
[ 9.98599893 100.00032416]</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
x_minus_mean = x - x_mean</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
cov = matrixmultiply(transpose(x_minus_mean), x_minus_mean) / 9999.</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
cov</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
array([[ 2.01737122, 1.00474408],</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
[ 1.00474408, 2.0009806 ]])</EM>
</P>
<P CLASS="Body">
<A NAME="pgfId-305436"></A>The a priori probabilities for a multinomial distribution must sum to one. The prior probability argument to multinomial () doesn't give the prior probability of the last event: it is computed to be one minus the sum of the others. </P>
<P CLASS="Python">
<A NAME="pgfId-305437"></A><EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
multinomial(16, [.1, .4, .2]) # prior probabilities [.1, .4, .2, .3] <BR>
</EM>
<EM CLASS="HTML-Typewriter">
array([2, 7, 1, 6])</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
&gt;&gt;&gt; </EM>
<EM CLASS="CodeInput">
multinomial(16, [.1, .4, .2], [2,3]) # output shape [2,3,4]</EM>
 <BR>
<EM CLASS="HTML-Typewriter">
array([[[ 1, 9, 1, 5],</EM>
 <BR>
       <EM CLASS="HTML-Typewriter">
 [ 0, 10, 3, 3],</EM>
 <BR>
       <EM CLASS="HTML-Typewriter">
 [ 4, 9, 3, 0]],</EM>
 <BR>
      <EM CLASS="HTML-Typewriter">
 [[ 1, 6, 1, 8],</EM>
 <BR>
       <EM CLASS="HTML-Typewriter">
 [ 3, 4, 5, 4],</EM>
 <BR>
       <EM CLASS="HTML-Typewriter">
 [ 1, 5, 2, 8]]])</EM>
</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-290702"></A>18.	 <A NAME="46054"></A><A NAME="71863"></A>Independent Random Streams</H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-304418"></A>The RNG package provides any number of independent random number generators tied to a distribution. Distributions include exponential, normal, and log-normal distributions, but adding others is not difficult. Contributions of code for other distributions are welcome! </P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-304780"></A>Background</H6>
<P CLASS="Body">
<A NAME="pgfId-304786"></A>RNG was written by Konrad Hinsen based on the package URNG by Paul Dubois and Fred Fritsch of LLNL. This package has been released for unlimited redistribution. Please see <A HREF="numdoc.html#66303" CLASS="XRef">License and disclaimer for packages MA and RNG</A>.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-304419"></A>Usage</H6>
<P CLASS="Body">
<A NAME="pgfId-304420"></A>Package RNG installs two modules: RNG.RNG, and RNG.ranf. The former is a C extension that does the generation. The latter is an easy-to-use interface for a single uniform distribution.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-304559"></A>Module RNG</H6>
<P CLASS="Body">
<A NAME="pgfId-304558"></A>Module RNG defines the function:</P>
<P CLASS="Body">
<A NAME="pgfId-304421"></A>CreateGenerator(s, distribution=UniformDistribution(0., 1.)) </P>
<P CLASS="Body">
<A NAME="pgfId-304422"></A>creates a new random number generator with a distribution. The random numbers produced by the generator sample the distribution and are independent of other generators created earlier or later. Its first argument, an integer, determines the initial state: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-304423"></A> 0 ; Use the default initial seed value. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304462"></A>&lt;0: ; Set a random value for the seed from the system clock. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304463"></A>&gt;0 ; Set seed directly (32 bits only). </LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-304424"></A>The default distribution is a uniform distribution on [0., 1.); other distributions are obtained by supplying a second argument which must be a distribution. Currently RNG defines the following distribution types: </P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-304425"></A>UniformDistribution(a, b) -- a uniform distribution of numbers in the interval [a, b) </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304482"></A>NormalDistribution(mu, sigma) -- a normal distribution with mean mu and standard deviation sigma </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304483"></A>ExponentialDistribution(l) -- an exponential distribution of positive numbers with decay constant l. </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304484"></A>LogNormalDistribution(mean, std) -- a log normal distribution with given mean and standard deviation.</LI>
</UL>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-304635"></A>Generator objects</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-304639"></A>Once a generator is created, it contains these methods:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-304644"></A>sample(n) will return an array of n samples from the generator.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304654"></A>ranf() will return one sample from the generator.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-304493"></A>Module ranf</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-304568"></A>Module ranf, whose main function ranf() is equivalent to the old ranf generator on Cray 1 computers, defines these facilities.</P>
<P CLASS="FirstBody">
<A NAME="pgfId-304497"></A>Attribute standard_generator is an instance of RNG.UniformDistribution(0., 1.).</P>
<P CLASS="Body">
<A NAME="pgfId-304534"></A>ranf(): returns a random number from the standard_generator.</P>
<P CLASS="Body">
<A NAME="pgfId-304545"></A>random_sample(*n) returns a Numeric array of samples from the standard_generator.</P>
<P CLASS="Python">
<A NAME="pgfId-304508"></A>random_sample(n) = array of n random numbers;</P>
<P CLASS="Python">
<A NAME="pgfId-304509"></A>random_sample(n1, n2, ...)= array of shape (n1, n2, ..)</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-304426"></A>Examples</H6>
<P CLASS="Body">
<A NAME="pgfId-304427"></A>The test routine Demo/RNGdemo.py illustrates some common usage of both RNG and Numeric.</P>
<P CLASS="Body">
<A NAME="pgfId-304428"></A>The test routine RNGtest2.py combines RNG with Konrad Hinsen's Statistics package to do a test of the log normal distribution.</P>
<P CLASS="Body">
<A NAME="pgfId-304616"></A>Here is one function from RNGdemo.py, showing a test of a normal distribution.</P>
<P CLASS="Python">
<A NAME="pgfId-304574"></A>from Numeric import *</P>
<P CLASS="Python">
<A NAME="pgfId-304579"></A>import RNG</P>
<P CLASS="Python">
<A NAME="pgfId-304580"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-304581"></A>def test_normal (mean, std, n=10000):</P>
<P CLASS="Python">
<A NAME="pgfId-304582"></A>    dist = RNG.NormalDistribution(mean, std)</P>
<P CLASS="Python">
<A NAME="pgfId-304583"></A>    rng = RNG.CreateGenerator(0, dist)</P>
<P CLASS="Python">
<A NAME="pgfId-304584"></A>    values = rng.sample(n)</P>
<P CLASS="Python">
<A NAME="pgfId-304585"></A>    m = sum(values)/n</P>
<P CLASS="Python">
<A NAME="pgfId-304586"></A>    s = sqrt(sum((values-m)**2)/n)</P>
<P CLASS="Python">
<A NAME="pgfId-304587"></A>    return (m, s)</P>
<P CLASS="Body">
<A NAME="pgfId-304172"></A>&nbsp;</P>
</DIV>
</DIV>
<DIV>
<H2 CLASS="Chapter">
<A NAME="pgfId-303698"></A>19.	 <A NAME="48250"></A>Masked Arrays<A NAME="marker-308206"></A></H2>
<P CLASS="ChapterDescription">
<A NAME="pgfId-303702"></A><A NAME="marker-308207"></A>Masked arrays are arrays that may have missing or invalid entries. Module MA provides a work-alike replacement for Numeric that supports data arrays with masks.</P>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-296294"></A>What is a <A NAME="masked array"></A>masked array?</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-305401"></A>Masked arrays are arrays that may have missing or invalid entries. Module MA provides a work-alike replacement for Numeric that supports data arrays with masks. A mask is either None or an array of ones and zeros, that determines for each element of the masked array whether or not it contains an invalid entry. The package assures that invalid entries are not used in calculations. </P>
<P CLASS="Body">
<A NAME="pgfId-296293"></A>A particular element is said to be masked (<A NAME="marker-305508"></A>invalid) if the mask is not None and the corresponding element of the mask is 1; otherwise it is unmasked (valid). </P>
<P CLASS="Body">
<A NAME="pgfId-304710"></A>This package was written by <A NAME="marker-305509"></A>Paul F. Dubois at Lawrence Livermore National Laboratory. Please see the legal notice in the software and on <A HREF="numdoc.html#66303" CLASS="XRef">License and disclaimer for packages MA and RNG</A>.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-304772"></A><A NAME="marker-305507"></A>Installing and using MA</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-296302"></A>MA is one of the optional Packages and installing it requires a separate step as explained in the Numeric README. To install just the MA package using Distutils, in the MA top directory enter:</P>
<P CLASS="C-Code">
<A NAME="pgfId-305192"></A>python setup.py install</P>
<P CLASS="FirstBody">
<A NAME="pgfId-304662"></A>Use MA as a replacement for Numeric:</P>
<P CLASS="Python">
<A NAME="pgfId-304660"></A>from MA import *</P>
<P CLASS="Python">
<A NAME="pgfId-305467"></A>x = array([1, 2, 3])</P>
<P CLASS="Body">
<A NAME="pgfId-304661"></A>To create an array with the second element invalid, we would do:</P>
<P CLASS="Python">
<A NAME="pgfId-305471"></A>y = array([1, 2, 3], mask = [0, 1, 0])</P>
<P CLASS="Body">
<A NAME="pgfId-305491"></A>To create a masked array where all values &quot;near&quot; 1.e20 are invalid, we can do:</P>
<P CLASS="Python">
<A NAME="pgfId-305495"></A>z = <A NAME="marker-305506"></A>masked_values ([1.0, 1.e20, 3.0, 4.0], 1.e20)</P>
<P CLASS="Body">
<A NAME="pgfId-305502"></A>For a complete discussion of creation methods for masked arrays please see <A HREF="numdoc.html#73354" CLASS="XRef">Constructing masked arrays</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-305470"></A>The Numeric module is an attribute in MA, so to execute a method foo from Numeric, you can reference it as Numeric.foo(...).</P>
<P CLASS="Body">
<A NAME="pgfId-304673"></A>Usually people use both MA and Numeric this way, but of course you can always fully-qualify the names:</P>
<P CLASS="Python">
<A NAME="pgfId-304674"></A>import MA</P>
<P CLASS="Python">
<A NAME="pgfId-304685"></A>x = MA.array([1, 2, 3])</P>
<P CLASS="Body">
<A NAME="pgfId-305234"></A>The principal feature of module MA is class MaskedArray, the class whose instances are returned by the array constructors and most functions in module MA. We will discuss this class first, and later cover the attributes and functions in module MA. For now suffice it to say that among the attributes of the module are the constants from module Numeric including those for declaring typecodes, NewAxis, and the mathematical constants such as pi and e. An additional typecode, MaskType, is the typecode used for masks.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-296950"></A>Class MaskedArray</H6>
<P CLASS="Body">
<A NAME="pgfId-304137"></A>In Module MA, an array is an instance of class MaskedArray, which is defined in the module MA. An instance of class MaskedArray can be thought of as containing the following parts:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-304138"></A>An array of data, of any shape;</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304139"></A>A mask of ones and zeros of the same shape as the data; and,</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-304140"></A>A &quot;fill value&quot; -- this is a value that may be used to replace the invalid entries in order to return a plain Numeric array. The chief method that does this is the method filled discussed below.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-304141"></A>We will use the terms &quot;invalid value&quot; and &quot;invalid entry&quot; to refer to the data value at a place corresponding to a mask value of 1. It should be emphasized that the invalid values are <EM CLASS="Emphasis">
never</EM>
 used in any computation, and that the fill value is not used for <EM CLASS="Emphasis">
any</EM>
 computational purpose. When an instance x of class MaskedArray is converted to its string representation, it is the result returned by filled (x) that is converted to a string.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305213"></A>Attributes of masked arrays</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305939"></A>flat: (deprecated) returns the masked array as one-dimensional. This is provided for compatibility with Numeric. ravel (x) is preferred.</P>
<P CLASS="Body">
<A NAME="pgfId-305943"></A>real: returns the real part of the array if complex.</P>
<P CLASS="Body">
<A NAME="pgfId-305944"></A>imaginary: returns the imaginary part of the array if complex.</P>
<P CLASS="FirstBody">
<A NAME="pgfId-305250"></A>shape: The shape of a masked array can be accessed or changed by using the special attribute shape, as with Numerical arrays.</P>
<P CLASS="Body">
<A NAME="pgfId-305520"></A>shared_data: This read-only flag if true indicates that the masked array shared a reference with the original data used to construct it at the time of construction. Changes to the original array will affect the masked array. (This is not the default behavior; see <A HREF="numdoc.html#72295" CLASS="XRef">Copying or not?</A>.) This flag is informational only.</P>
<P CLASS="Body">
<A NAME="pgfId-305536"></A><A NAME="MA"></A>shared_mask: This read-only flag if true indicates that the masked array currently shares a reference to the mask used to create it. Unlike shared_data, this flag may change as the result of modifying the array contents, as the mask uses copy on write semantics if it is shared.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305217"></A>Methods on masked arrays. </H6>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="TableTitle">
<A NAME="pgfId-298191"></A>Methods on masked arrays; attributes, constructors and operations discussed separately.<A NAME="36299"></A></H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-298197"></A>Method</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-298199"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="CellHeading">
<A NAME="pgfId-298201"></A>Sample syntax</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298203"></A>astype (typecode)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298205"></A>return self as array of given type.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298207"></A>y = x.astype (Float32)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306731"></A>compressed ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306733"></A>return an array of the valid elements. Result is one-dimensional.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306735"></A>y = x.compressed()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320226"></A>count(axis=None)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320228"></A>count the number of non-masked elements in the array, if axis is None. Otherwise return an array of such counts along the axis given.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320230"></A>n=x.count()</P>
<P CLASS="CellBody">
<A NAME="pgfId-320234"></A>y=x.count(0)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320194"></A>itemsize()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320196"></A>size of individual data items in bytes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320198"></A>n = x.itemsize()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306685"></A>filled (fill_value=None)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306687"></A>filled(self, self.fill_value()); see description of module method filled.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306689"></A>y = x.filled()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298209"></A>fill_value ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298211"></A>Get the current fill value.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298213"></A>v = x.fill_value ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306721"></A>filled (value = None)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306723"></A>Same as filled(self, value); see <A HREF="numdoc.html#16670" CLASS="XRef">Filling in the missing data</A>.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306725"></A>numar = x.filled ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298227"></A>ids ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298229"></A>Return the ids of the data and mask areas</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298231"></A>id1, id2 = x.ids ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298233"></A>iscontiguous ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298235"></A>Is the data area contiguous? See Numeric manual.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298237"></A>if x.iscontiguous ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298239"></A>mask ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298241"></A>Return the data mask, or None.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298243"></A>m = x.mask ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306691"></A>put (values)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306693"></A>Set the value at each non-masked entry to the corresponding entry in values. The mask is unchanged. See also module method put.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306695"></A>x.put (values)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306700"></A>putmask (values)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306702"></A>Eliminate any masked values by setting the value at each masked entry to the corresponding entry in values. Set the mask to None.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-306704"></A>x.putmask(values)</P>
<P CLASS="CellBody">
<A NAME="pgfId-306719"></A>assert getmask(x) is None</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298245"></A>raw_data ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298247"></A>A reference to the non-filled data; portions may be meaningless. Expert use only.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298249"></A>d = x.raw_data ()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305255"></A>savespace (v)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305257"></A>Set the spacesaver attribute to v.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305259"></A>x.savespace (1)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298251"></A>set_fill_value ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298253"></A>Set the fill value to v. Omit v to restore default.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298255"></A>x.set_fill_value (1.e21)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298263"></A>set_shape (args...)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298265"></A>shape (n, m, ...) sets the shape.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298267"></A>x.set_shape (3, 12)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298269"></A>size (axis)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298271"></A>Number of elements in array, or in a particular axis.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298273"></A>totalsize = x.size ()</P>
<P CLASS="CellBody">
<A NAME="pgfId-298303"></A>col_len = x.size (1)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305261"></A>spacesaver()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305263"></A>Query the spacesave flag.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305265"></A>flag = x.spacesaver()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320209"></A>tolist(fill_value=None)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320211"></A>Return the Python list self.filled(fill_value).tolist(); note that masked values are filled.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320213"></A>alist=x.tolist()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320203"></A>tostring(fill_value=None)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320205"></A>Return the string self.filled(fill_value).tostring()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-320207"></A>s = x.tostring()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305551"></A>unshare_mask()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305553"></A>If shared_mask is currently true, replaces the reference to it with a copy.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305555"></A>x.unshare_mask()</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298275"></A>typecode ()</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-298277"></A>Return the type of the data. See module Precision.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="CellBody">
<A NAME="pgfId-305953"></A>z = x.typecode()</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320251"></A><A NAME="73354"></A>Constructing masked arrays</H6>
<OL>
<LI CLASS="Numbered1">
<A NAME="pgfId-308231"></A><A NAME="marker-308230"></A>array (data, typecode = None, copy = 1, savespace = 0, mask = None, fill_value = None) <BR>
Creates a masked array with the given data and mask. The name array is simply an alias for the class name, MaskedArray, The fill value is set to fill_value, and the savespace flag is applied. If data is a MaskedArray, its mask, typecode, spacesaver flag, and fill value will be used unless specifically specified by one of the remaining arguments. In particular, if d is a masked array, array(d, copy=0) is d. </LI>
<LI CLASS="Numbered">
<A NAME="pgfId-308233"></A><A NAME="marker-308232"></A>masked_array (data, mask = None, fill_value = None)<BR>
This is an easier-to-use version of array, for the common case of typecode = None, copy = 0. When data is newly-created this function can be used to make it a masked array without copying the data if data is already a Numeric array.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-303765"></A><A NAME="marker-304072"></A>masked_values (data, value, rtol=1.e-5, atol=1.e-8, typecode = None, copy = 1, savespace = 0) <BR>
Constructs a masked array whose mask is set at those places where <BR>
abs (data - value) &lt; atol + rtol * abs (data). <BR>
That is a careful way of saying that those elements of the data that have value = value (to within a tolerance) are to be treated as invalid. If data is not of a floating point type, calls masked_object instead.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-305796"></A><A NAME="marker-305802"></A>masked_object (data, value, copy=1, savespace=0) <BR>
Creates a masked array with those entries marked invalid that are equal to value. Again, copy and savespace are passed on to the Numeric array constructor.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-313038"></A>asarray(data, typecode=None)<BR>
This is the same as array(data, typecode, copy=0). This is a short way of ensuring that something is an instance of MaskedArray of a given type before proceeding, as in <BR>
data = asarray(data). <BR>
<BR>
If data already is a masked array and typecode is None then the return value is data; nothing is copied in that case.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-307728"></A><A NAME="marker-307732"></A>masked_where (condition, data, copy=1) <BR>
Creates a masked array whose shape is that of condition, whose values are those of data, and which is masked where elements of condition are true.</LI>
</OL>
<P CLASS="Body">
<A NAME="pgfId-313044"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-313063"></A>The following additional constructors are provided for convenience.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-307764"></A><A NAME="marker-307789"></A>masked_greater (data, value, copy=1) is equivalent to masked_where (greater(data, value), data)). Similarly, <A NAME="marker-307793"></A>masked_greater_equal, <A NAME="marker-307797"></A>masked_equal, <A NAME="marker-307801"></A>masked_not_equal, <A NAME="marker-307805"></A>masked_less, <A NAME="marker-307809"></A>masked_less_equal are called in the same way with the obvious meanings. Note that for floating point data, <A NAME="marker-307810"></A>masked_values is preferable to masked_equal in most cases.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-313024"></A>masked_inside (data, v1, v2, copy=1) creates an array with values in the closed interval [v1, v2] masked. v1 and v2 may be in either order.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-313028"></A>masked_outside (data, v1, v2, copy=1) creates an array with values outside the closed interval [v1, v2] masked. v1 and v2 may be in either order.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-313074"></A>&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-305283"></A>On entry to any of these constructors, data must be any object which the Numeric package can accept to create an array (with the desired typecode, if specified). The mask if given must be None or any object that can be turned into a Numeric array of integer type (it will be converted to typecode MaskType, if necessary), have the same shape as data, and contain only values of 0 or 1.</P>
<P CLASS="Body">
<A NAME="pgfId-306531"></A>If the mask is not None but its shape does not match that of data, an exception will be thrown, unless one of the two is of length 1, in which case the scalar will be resized (using Numeric.resize) to match the other.</P>
<P CLASS="Body">
<A NAME="pgfId-306530"></A>See <A HREF="numdoc.html#72295" CLASS="XRef">Copying or not?</A> for a discussion of whether or not the resulting array shares its data or its mask with the arguments given to these constructors.</P>
<DIV>
<H6 CLASS="NoteTip">
<A NAME="pgfId-313009"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Note">
<A NAME="pgfId-305623"></A><A NAME="35793"></A>filled is very important. It converts its argument to a plain Numeric array.</P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-313013"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="FirstBody">
<A NAME="pgfId-304255"></A>filled (x, value = None) returns x with any invalid locations replaced by a fill value. filled is guaranteed to return a plain Numeric array. The argument x does not have to be a masked array or even an array, just something that Numeric can turn into one.</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-305156"></A>If x is not a masked array, and not a Numeric array, Numeric.array (x) is returned.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305647"></A>If x is a contiguous Numeric array then x is returned. (A Numeric array is contiguous if its data storage region is layed out in column-major order; Numeric allows non-contiguous arrays to exist but they are not allowed in certain operations). </LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305648"></A>If x is a masked array, but the mask is None, and x's data array is contiguous, then it is returned. If the data array is not contiguous, a (contiguous) copy of it is returned.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305649"></A>If x is a masked array with an actual mask, then an array formed by replacing the invalid entries with value, or fill_value (x) if value is None, is returned. If the fill value used is of a different type or precision than x, the result may be of a different type or precision than x.</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-308305"></A>Note that a new array is created only if necessary to create a correctly filled contiguous Numeric array.</P>
<P CLASS="FirstBody">
<A NAME="pgfId-305154"></A>The function filled plays a central role in our design. It is the &quot;exit&quot; back to Numeric, and is used whenever the invalid values must be replaced before an operation. For example, adding two masked arrays a and b is roughly:</P>
<P CLASS="Python">
<A NAME="pgfId-304389"></A>masked_array(filled(a, 0)+filled(b, 0), mask_or(getmask(a), getmask(b))</P>
<P CLASS="Body">
<A NAME="pgfId-304394"></A>That is, fill the invalid entries a and b with zeros, add them up, and declare any entry of the result invalid if either a or b was invalid at that spot. The functions getmask and mask_or are discussed later.</P>
<P CLASS="Body">
<A NAME="pgfId-305057"></A>filled (x) also can be used to simply be certain that some expression is a contiguous Numerical array at little cost. If its argument is a Numeric array already, it is returned without copying. </P>
<P CLASS="Body">
<A NAME="pgfId-305142"></A><A NAME="marker-305346"></A>fill_value (x), and the method x.fill_value() of the same name on masked arrays, returns a value suitable for filling x based on its type. If x is a masked array, then x.fill_value () results. The returned value for a given type can be changed by assigning to these names in module MA: They should be set to scalars or one element arrays. </P>
<P CLASS="Python">
<A NAME="pgfId-305143"></A><A NAME="marker-305365"></A>default_real_fill_value = Numeric.array([1.0e20], Float32)</P>
<P CLASS="Python">
<A NAME="pgfId-305144"></A><A NAME="marker-305348"></A>default_complex_fill_value = Numeric.array([1.0e20 + 0.0j], Complex32)</P>
<P CLASS="Python">
<A NAME="pgfId-305145"></A><A NAME="marker-305349"></A>default_character_fill_value = masked</P>
<P CLASS="Python">
<A NAME="pgfId-306195"></A><A NAME="marker-305350"></A>default_integer_fill_value = Numeric.array([0]).astype(UnsignedInt8)</P>
<P CLASS="Python">
<A NAME="pgfId-305148"></A><A NAME="marker-305352"></A>default_object_fill_value = masked</P>
<P CLASS="Body">
<A NAME="pgfId-305671"></A>The variable <A NAME="marker-306591"></A>masked is a module variable of MA and is discussed in <A HREF="numdoc.html#42703" CLASS="XRef">The constant masked</A>. Calling filled with a fill_value of masked sometimes produces a useful printed representation of a masked array. The function fill_value works on any kind of object.</P>
<P CLASS="Body">
<A NAME="pgfId-320344"></A><A NAME="marker-320343"></A>set_fill_value (a, fill_value) is the same as a.set_fill_value (fill_value) if a is a masked array; otherwise it does nothing. Please note that the fill value is mostly cosmetic; it is used when it is needed to convert the masked array to a plain Numeric array but not involved in most operations. In particular, setting the fill value to 1.e20 will <EM CLASS="Emphasis">
not, repeat not, </EM>
cause elements of the array whose values are currently 1.e20 to be masked. For that sort of behavior use the masked_value constructor.</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320302"></A>What are masks?<A NAME="marker-320328"></A></H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320306"></A>Masks are either None or 1-byte Numerical arrays of 1's and 0's. To avoid excessive performance penalties, mask arrays are never checked to be sure that the values are 1's and 0's, and supplying a mask= argument to a constructor with an illegal mask will have undefined consequences later. </P>
<P CLASS="Body">
<A NAME="pgfId-320308"></A><EM CLASS="Emphasis">
Masks have the savespace attribute set</EM>
. This attribute, discussed in the Numeric Python manual, may have surprising consequences if you attempt to do any operations on them other than those supplied by this package. In particular, do not add or multiply a quantity involving a mask. For example, if m is a mask consisting of 1080 1 values, sum(m) is 56, not 1080. Oops.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320312"></A>Working with masks</H6>
<P CLASS="Body">
<A NAME="pgfId-308208"></A>create_mask(ashape) returns an array suitable for use as a mask, having the given shape and initialized to zeros.</P>
<P CLASS="Body">
<A NAME="pgfId-304996"></A><A NAME="marker-305354"></A>is_mask (m) is true if m is of a type and precision that would be allowed as the mask field of a masked array (that is, it is an array of integers with Numeric's typecode MaskType, or it is None). To be a legal mask, m should contain only zeros or ones, but this is not checked.</P>
<P CLASS="Body">
<A NAME="pgfId-305010"></A><A NAME="marker-305355"></A>make_mask (m, copy=0, flag=0) returns an object whose entries are equal to m and for which is_mask would return true. If m is already a mask or None, it returns m or a copy of it. Otherwise it will attempt to make a mask, so it will accept any sequence of integers of for m. If flag is true, make_mask returns None if its return value otherwise would contain no true elements. To make a legal mask, m should contain only zeros or ones, but this is not checked.</P>
<P CLASS="Body">
<A NAME="pgfId-305014"></A><A NAME="marker-305356"></A>getmask (x) returns x.<A NAME="marker-305366"></A>mask(), the mask of x, if x is a masked array, and None otherwise. Note that getmask may return None if x is a masked array but has a mask of None. (Please see caution above about operating on the result).</P>
<P CLASS="Body">
<A NAME="pgfId-304965"></A><A NAME="marker-305367"></A>getmaskarray (x) returns x.mask() if x is a masked array and has a mask that is not None; otherwise it returns a zero mask array of the same shape as x. Unlike getmask, getmaskarray always returns an Numeric array of typecode MaskType. (Please see caution above about operating on the result).</P>
<P CLASS="Body">
<A NAME="pgfId-304917"></A><A NAME="marker-305370"></A>mask_or (m1, m2) returns an object which when used as a mask behaves like the element-wise &quot;logical or&quot; of m1 and m2, where m1 and m2 are either masks or None (e.g., they are the results of calling getmask). A None is treated as everywhere false. If both m1 and m2 are None, it returns None. If just one of them is None, it returns the other. If m1 and m2 refer to the same object, a reference to that object is returned.</P>
<P CLASS="Body">
<A NAME="pgfId-306560"></A>masked is a module constant equal to an instance of a class that prints as the word `masked' and which will throw an exception of type MAError if any attempt is made to do arithmetic upon it. This constant is returned when an indexing operation results in a scalar result at a masked location.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320257"></A>Operations</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320263"></A>Masked arrays support the operators +, *, /, -, **, and unary plus and minus. The other operand can be another masked array, a scalar, a Numeric array, or something Numeric.array() can convert to a Numeric array. The results are masked arrays.</P>
<P CLASS="Body">
<A NAME="pgfId-320287"></A>In addition masked arrays support the in-place operators +=, -=, *=, and /=. Implementation of in-place operators differs from Numeric semantics in being more generous about converting the right-hand side to the required type: any kind or lesser type accepted via an astype conversion. In-place operators truly operate in-place when the target is not masked. </P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305173"></A><A NAME="72295"></A>Copying or not?</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305179"></A>Depending on the arguments results of constructors may or may not contain a separate copy of the data or mask arguments. The easiest way to think about this is as follows: the given field, be it data or a mask, is required to be a Numerical array, possibly with a given typecode, and a mask's shape must match that of the data. If the copy argument is zero, and the candidate array otherwise qualifies, a reference will be made instead of a copy. If for any reason the data is unsuitable as is, an attempt will be made to make a copy that is suitable. Should that fail, an exception will be thrown. Thus, a copy=0 argument is more of a hope than a command.</P>
<P CLASS="Body">
<A NAME="pgfId-308218"></A>If the basic array constructor is given a masked array as the first argument, its mask, typecode, spacesaver flag, and fill value will be used unless specifically specified by one of the remaining arguments. In particular, if d is a masked array, array(d, copy=0) is d.</P>
<P CLASS="Body">
<A NAME="pgfId-305700"></A>Since the default behavior for masks is to use a reference if possible, rather than a copy, which produces a sizeable time and space savings, it is especially important not to modify something you used as a mask argument to a masked array creation routine, if it was a Numeric array of typecode MaskType.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305435"></A>Behaviors</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305439"></A>A masked array defines the conversion operators str (x), repr (x), float (x), and int (x) by applying the corresponding operator to the Numeric array filled (x)</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-304210"></A><A NAME="marker-304071"></A><A NAME="40659"></A>Indexing and Slicing</H6>
<P CLASS="Body">
<A NAME="pgfId-304211"></A>Indexing and slicing differ from Numeric: while generally the same, they return a copy, not a reference, when used in an expression that produces a non-scalar result. Consider this example:</P>
<P CLASS="Python">
<A NAME="pgfId-304212"></A>from Numeric import *</P>
<P CLASS="Python">
<A NAME="pgfId-304213"></A>x = array([1.,2.,3.])</P>
<P CLASS="Python">
<A NAME="pgfId-304214"></A>y = x[1:]</P>
<P CLASS="Python">
<A NAME="pgfId-304215"></A>y[0] = 9.</P>
<P CLASS="Python">
<A NAME="pgfId-304216"></A>print x</P>
<P CLASS="Body">
<A NAME="pgfId-304217"></A>This will print [1., 9., 3.] since x[1:] returns a reference to a portion of x. Doing the same operation using MA, </P>
<P CLASS="Python">
<A NAME="pgfId-304218"></A>from MA import *</P>
<P CLASS="Python">
<A NAME="pgfId-304219"></A>x = array([1.,2.,3.])</P>
<P CLASS="Python">
<A NAME="pgfId-304220"></A>y = x[1:]</P>
<P CLASS="Python">
<A NAME="pgfId-304221"></A>y[0] = 9.</P>
<P CLASS="Python">
<A NAME="pgfId-304222"></A>print x</P>
<P CLASS="Body">
<A NAME="pgfId-304223"></A>will print [1., 2., 3.], while y will be a separate array whose present value would be [9., 3.]. While sentiment on the correct semantics here is divided amongst the Numeric community as a whole, it is not divided amongst the author's community, on whose behalf this package is written.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306592"></A>Indexing that produces a scalar result</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306598"></A>If indexing into a masked array with one or more indices produces a scalar result, then a scalar value is returned rather than a one-element masked array. This raises the issue of what to return if that location is masked. The answer is that the module constant masked, discussed above, is returned.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-304229"></A>Assignment to elements and slices</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-304233"></A>Assignment of a normal value to a single element or slice of a masked array has the effect of clearing the mask in those locations. In this way previously invalid elements become valid. The value being assigned is filled first, so that you are guaranteed that all the elements on the left-hand side are now valid. </P>
<P CLASS="Body">
<A NAME="pgfId-305698"></A>Assignment of None to a single element or slice of a masked array has the effect of setting the mask in those locations, and the locations become invalid.</P>
<P CLASS="Body">
<A NAME="pgfId-305699"></A>Since these operations change the mask, the result afterwards will no longer share a mask, since masks have copy-on-write semantics.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-297249"></A>Module MA: Attributes</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305713"></A>Constants e, pi, NewAxis from Numeric, and the constants from module Precision that define nice names for the typecodes. </P>
<P CLASS="Body">
<A NAME="pgfId-306942"></A>The special variable <A NAME="marker-306618"></A>masked is discussed in <A HREF="numdoc.html#42703" CLASS="XRef">The constant masked</A>. </P>
<P CLASS="Body">
<A NAME="pgfId-306941"></A>The module Numeric is an element of MA, so after from MA import *, you can refer to the functions in Numeric such as Numeric.ones.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-305706"></A>Module MA: Functions</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-298310"></A>Each of the operations discussed below returns an instance of <A NAME="marker-306622"></A>class MaskedArray, having performed the desired operation element-wise. In most cases the array arguments can be masked arrays or Numeric arrays or something that Numeric can turn into a Numeric array, such as a list of real numbers.</P>
<P CLASS="Body">
<A NAME="pgfId-305885"></A>In most cases, if Numeric has a function of the same name, the behavior of the one in MA is the same, except that it &quot;respects&quot; the mask.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-298306"></A>Unary functions</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-298311"></A>The result of a unary operation will be masked wherever the original operand was masked. It may also be masked if the argument is not in the domain of the function. Functions available are: </P>
<P CLASS="Body">
<A NAME="pgfId-298322"></A><A NAME="marker-307861"></A>sqrt, <A NAME="marker-307862"></A>log, <A NAME="marker-307863"></A>log10, <A NAME="marker-307864"></A>exp, <A NAME="marker-307865"></A>conjugate, <A NAME="marker-307866"></A>sin, <A NAME="marker-307867"></A>cos, <A NAME="marker-307868"></A>tan, <A NAME="marker-307869"></A>arcsin, <A NAME="marker-307870"></A>arccos, <A NAME="marker-307871"></A>arctan, <A NAME="marker-307872"></A>sinh, <A NAME="marker-307873"></A>cosh, <A NAME="marker-307874"></A>tanh, <A NAME="marker-307875"></A>absolute, <A NAME="marker-307876"></A>fabs, <A NAME="marker-307877"></A>negative (also as operator -x), <A NAME="marker-307878"></A>nonzero, <A NAME="marker-307879"></A>around, <A NAME="marker-307880"></A>floor</P>
<P CLASS="Body">
<A NAME="pgfId-306090"></A><A NAME="marker-307881"></A>fabs (x) is the absolute value of x as a Float32 array. The other functions have their standard meaning.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-298312"></A>Binary functions</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-298333"></A>Binary functions return a result that is masked wherever either of the operands were masked; it may also be masked where the arguments are not in the domain of the function.</P>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-297747"></A><A NAME="marker-307882"></A>add (also as operator +), <A NAME="marker-307883"></A>subtract (also as operator -), <A NAME="marker-307884"></A>multiply (also as operator *), <A NAME="marker-307885"></A>divide (also as operator /), <A NAME="marker-307886"></A>power (also as operator **), <A NAME="marker-307887"></A>remainder, <A NAME="marker-307888"></A>fmod, <A NAME="marker-307889"></A>hypot, <A NAME="marker-307890"></A>arctan2, <A NAME="marker-307891"></A>bitwise_and, <A NAME="marker-307892"></A>bitwise_or, <A NAME="marker-307893"></A>bitwise_xor.</P>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-298340"></A>Comparison operators</H6>
<DIV>
<H6 CLASS="NoteTip">
<A NAME="pgfId-313084"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Note">
<A NAME="pgfId-304038"></A>Due to limitations in Python, it is not meaningful to compare arrays using the symbolic comparison operators such as &quot;&lt;&quot;. Unfortunately, you can do it; the result just won't mean anything.</P>
<DIV>
<H6 CLASS="NoteBottom">
<A NAME="pgfId-313088"></A></h6>
<DIV>
</DIV>
&nbsp;
<P CLASS="Body">
<A NAME="pgfId-298345"></A>To compare arrays, use the following binary functions. Each of them returns a masked array of 1's and 0's.</P>
<P CLASS="Body">
<A NAME="pgfId-304047"></A><A NAME="marker-307894"></A>equal, <A NAME="marker-307895"></A>not_equal, <A NAME="marker-307896"></A>less_equal, <A NAME="marker-307897"></A>greater_equal, <A NAME="marker-307898"></A>less, <A NAME="marker-307899"></A>greater</P>
<P CLASS="Body">
<A NAME="pgfId-305376"></A>Note that as in Numeric, you can use a scalar for one argument and an array for the other. </P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-298353"></A>Logical operators</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-298357"></A>Arrays of logical values can be manipulated with:</P>
<P CLASS="Body">
<A NAME="pgfId-298358"></A><A NAME="marker-307900"></A>l<A NAME="marker-308197"></A>ogical_not (unary), <A NAME="marker-307901"></A>logical_or, <A NAME="marker-307902"></A>logical_and, <A NAME="marker-307903"></A>logical_xor.</P>
<P CLASS="Body">
<A NAME="pgfId-298359"></A><A NAME="marker-307904"></A>alltrue (x) returns 1 if all elements of x are true. Masked elements are treated as true.</P>
<P CLASS="Body">
<A NAME="pgfId-298360"></A><A NAME="marker-307905"></A>sometrue (x) returns 1 if any element of x is true. Masked elements are treated as false.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-298365"></A><A NAME="14948"></A>Special array operators</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305827"></A><A NAME="marker-305831"></A>isarray (x), <A NAME="marker-305832"></A>isMA (x) return true if x is a masked array.</P>
<P CLASS="Body">
<A NAME="pgfId-298407"></A><A NAME="marker-307906"></A>rank (x) is the number of dimensions in x. </P>
<P CLASS="Body">
<A NAME="pgfId-305842"></A><A NAME="marker-307907"></A>shape (x) returns the shape of x, a tuple of array extents.</P>
<P CLASS="Body">
<A NAME="pgfId-305846"></A><A NAME="marker-307908"></A>resize (x, new_shape) returns a new array with specified shape.</P>
<P CLASS="Body">
<A NAME="pgfId-305865"></A><A NAME="marker-307909"></A>reshape (x, new_shape) returns a copy of x with the given new shape. </P>
<P CLASS="Body">
<A NAME="pgfId-305869"></A><A NAME="marker-307910"></A>ravel (x) returns x as one-dimensional.</P>
<P CLASS="Body">
<A NAME="pgfId-305877"></A><A NAME="marker-307911"></A>concatenate (arrays, axis=0) concatenates the arrays along the specified axis.</P>
<P CLASS="Body">
<A NAME="pgfId-319938"></A>repeat (array, repeats, axis = 0) repeat elements of a repeats times along axis. repeats is a sequence of length a.shape[axis] telling how many times to repeat each element.</P>
<P CLASS="Body">
<A NAME="pgfId-305850"></A><A NAME="marker-307912"></A>identity (n) returns the identity matrix of shape n by n.</P>
<P CLASS="Body">
<A NAME="pgfId-305854"></A><A NAME="marker-307913"></A>indices (dimensions, typecode = None) returns an array representing a grid of indices with row-only and column-only variation.</P>
<P CLASS="Body">
<A NAME="pgfId-298408"></A><A NAME="marker-307914"></A>len (x) is defined to be the length of the first dimension of x. This definition, peculiar from the array point of view, is required by the way Python implements slicing. Use size (x) for the total length of x.</P>
<P CLASS="Body">
<A NAME="pgfId-298465"></A><A NAME="marker-307915"></A>size (x, axis = None) is the total size of x, or the length of a particular dimension axis whose index is given. When axis is given the dimension of the result is one less than the dimension of x.</P>
<P CLASS="Body">
<A NAME="pgfId-298461"></A><A NAME="marker-307916"></A>count (x, axis = None) counts the number of (non-masked) elements in the array, or in the array along a certain axis.When axis is given the dimension of the result is one less than the dimension of x.</P>
<P CLASS="Body">
<A NAME="pgfId-305809"></A><A NAME="marker-305810"></A>arange, <A NAME="marker-305817"></A><A NAME="marker-305818"></A>arrayrange, <A NAME="marker-305822"></A>ones, and <A NAME="marker-305826"></A>zeros are the same as in Numeric, but return masked arrays.</P>
<P CLASS="Body">
<A NAME="pgfId-298470"></A><A NAME="marker-307917"></A>sum, and <A NAME="marker-307918"></A>product are called the same way as count; the difference is that the result is the sum, product, or average respectively of the unmasked element.</P>
<P CLASS="Body">
<A NAME="pgfId-307970"></A><A NAME="marker-308029"></A>average (x, axis=0, weights=None) computes the average value of the non-masked elements of x along the selected axis. If weights is given, it must match the size and shape of x, and the value returned is:</P>
<P CLASS="CBlockIndent">
&nbsp;</P>
<P CLASS="Body">
<A NAME="pgfId-308008"></A>In computing these sums, elements that correspond to those that are masked in x or weights are ignored.</P>
<P CLASS="Body">
<A NAME="pgfId-298369"></A><A NAME="marker-307920"></A>allclose (x, y, fill_value = 1, rtol = 1.e-5, atol = 1.e-8) tests whether or not arrays x and y are equal subject to the given relative and absolute tolerances. If fill_value is 1, masked values are considered equal, otherwise they are considered different. The formula used for elements where both x and y have a valid value is:</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Code">
<A NAME="pgfId-298386"></A>| x - y | &lt; atol + rtol * | y |</H6>
<P CLASS="Body">
<A NAME="pgfId-298393"></A>This means essentially that both elements are small compared to atol or their difference divided by their value is small compared to rtol.</P>
<P CLASS="Body">
<A NAME="pgfId-298403"></A><A NAME="marker-307921"></A>allequal (x, y, fill_value = 1) is similar to allclose, except that exact equality is demanded.</P>
<P CLASS="Body">
<A NAME="pgfId-305881"></A><A NAME="marker-307922"></A>take (a, indices, axis=0) returns a selection of items from a. See the documentation in the Numeric manual.</P>
<P CLASS="Body">
<A NAME="pgfId-307667"></A><A NAME="marker-307923"></A>transpose (a, axes=None) performs a reordering of the axes depending on the tuple of indices <EM CLASS="Code">
axes</EM>
; the default is to reverse the order of the axes.</P>
<P CLASS="Body">
<A NAME="pgfId-306637"></A><A NAME="marker-307924"></A>put (a, indices, values) is the opposite of <EM CLASS="Code">
take</EM>
. The values of the array <EM CLASS="Code">
a</EM>
 at the locations specified in <EM CLASS="Code">
indices</EM>
 are set to the corresponding value of <EM CLASS="Code">
values</EM>
. The array <EM CLASS="Code">
a </EM>
must be a contiguous array. The argument indices can be any integer sequence object with values suitable for indexing into the flat form of <EM CLASS="Code">
a</EM>
. The argument v must be any sequence of values that can be converted to the typecode of <EM CLASS="Code">
a</EM>
.</P>
<P CLASS="Python">
<A NAME="pgfId-306639"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x = arange(6)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306640"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
put(x, [2,4], [20,40])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306641"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306642"></A>[ 0  1 20  3 40  5 ]</P>
<P CLASS="Body">
<A NAME="pgfId-306666"></A>Note that the target array <EM CLASS="Code">
a</EM>
 is not required to be one-dimensional. Since it is contiguous and stored in row-major order, the array <EM CLASS="Code">
indices</EM>
 can be treated as indexing <EM CLASS="Code">
a</EM>
's elements in storage order. </P>
<P CLASS="Body">
<A NAME="pgfId-306676"></A>The wrinkle on this for masked arrays is that if the locations being set by put are masked, the mask is cleared in those locations.</P>
<P CLASS="Body">
<A NAME="pgfId-307940"></A><A NAME="marker-307939"></A>choose (condition, t) has a result shaped like condition. t must be a tuple. Each element of the tuple can be an array, a scalar, or the constant element <EM CLASS="Callout">
masked (</EM>
See<EM CLASS="Callout">
 </EM>
<A HREF="numdoc.html#42703" CLASS="XRef">The constant masked</A><EM CLASS="Callout">
)</EM>
. Each element of the result is the corresponding element of t[i] where condition has the value i. The result is masked where condition is masked or where the selected element is masked or the selected element of t is the constant <EM CLASS="Callout">
masked</EM>
. </P>
<P CLASS="Body">
<A NAME="pgfId-305858"></A><A NAME="marker-307860"></A>where (condition, x, y) returns an array that is filled (x) where condition is true, filled (y) where the condition is false. One of x or y can be the constant element <EM CLASS="Callout">
masked (</EM>
See<EM CLASS="Callout">
 </EM>
<A HREF="numdoc.html#42703" CLASS="XRef">The constant masked</A><EM CLASS="Callout">
)</EM>
. The result is masked where condition is masked, where the element selected from x or y is masked, or where x or y itself is the constant <EM CLASS="Callout">
masked</EM>
 and it is selected.</P>
<P CLASS="Body">
<A NAME="pgfId-305886"></A><A NAME="marker-307925"></A>innerproduct (a, b) and dot (a, b) work as in Numeric, but missing values don't contribute. The result is always a masked array, possibly of length one, because of the possibility that one or more entries in it may be invalid since all the data contributing to that entry was invalid.</P>
<P CLASS="Body">
<A NAME="pgfId-307701"></A><A NAME="marker-307926"></A>outerproduct (a, b) produces a masked array such that result[i, j] = a[i] * b[j]. The result will be masked where a[i] or b[j] is masked.</P>
<P CLASS="Body">
<A NAME="pgfId-305887"></A><A NAME="marker-307928"></A>compress (condition, x, dimension=-1) compresses out only those valid values where condition is true.</P>
<P CLASS="Body">
<A NAME="pgfId-305907"></A><A NAME="marker-307929"></A>maximum (x, y = None) and <A NAME="marker-307930"></A>minimum (x, y = None) compute the minimum and maximum valid values of x if y is None; with two arguments, they return the element-wise larger or smaller of valid values, and mask the result where either x or y is masked.</P>
<P CLASS="Body">
<A NAME="pgfId-305914"></A><A NAME="marker-307931"></A>sort (x, axis=-1, value = None) returns the array x sorted along the given axis, with masked values treated as if they have a sort value of value but locations containing value are masked in the result if x had a mask to start with. Thus if x contains value at a non-masked spot, but has other spots masked, the result may not be what you want.</P>
<P CLASS="Body">
<A NAME="pgfId-305918"></A><A NAME="marker-307932"></A>argsort (x, axis = -1, fill_value = None) is unusual in that it returns a Numeric array, equal to <BR>
Numeric.argsort (filled (x, fill_value), axis); this is an array of indices for sorting along a given axis.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305726"></A>Controlling the size of the string representations</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305730"></A>The functions <A NAME="marker-307933"></A>get_print_limit () and <A NAME="marker-307934"></A>set_print_limit (n=0) query and set the limit for converting arrays using str() or repr (). If an array is printed that is larger than this, the values are not printed; rather you are informed of the type and size of the array. If n is zero, the standard Numeric conversion functions are used.</P>
<P CLASS="Body">
<A NAME="pgfId-306167"></A>When imported, MA sets this limit to 300, and the limit is also made to apply to standard Numeric arrays as well.</P>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-304172"></A>Helper classes</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305725"></A>This section discusses other classes defined in module MA.</P>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306892"></A>MAError</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306893"></A>Class <A NAME="marker-307935"></A>MAError inherits from Exception, used to raise exceptions in the MA module. Other exceptions are possible, such as errors from the underlying Numeric module.</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306894"></A><A NAME="42703"></A>The constant <A NAME="marker-307936"></A>masked</H6>
<P CLASS="Body">
<A NAME="pgfId-306895"></A>A constant named masked, in Module MA, serves several purposes.</P>
<OL>
<LI CLASS="Numbered1">
<A NAME="pgfId-306896"></A>When a indexing operation on an MaskedArray instance returns a scalar result, but the location indexed was masked, then masked is returned. For example, given a one-dimensional array x such that x.mask(3) is 1, then x[3] is masked.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306897"></A>When masked is assigned to elements of an array via indexing or slicing, those elements become masked. So after x[3] = masked, x[3] is masked.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306898"></A>masked.display() is a string that may be used to indicate those elements of an array that are masked when the array is converted to a string, as happens with the print statement. </LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306899"></A><A NAME="marker-307957"></A>masked.set_display (string) can be used to change the value; the default is `--'.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306900"></A>masked.enable(flag) can be used to enable (flag = 1, default) the use of the display string. If disabled (flag=0), the conversion to string becomes equivalent to str(self.filled()).</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306901"></A>masked.enabled() returns the state of the display-enabling flag.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-306902"></A>Most operations on masked will result in an exception being raised.</LI>
</OL>
<DIV>
<H6 CLASS="FM3Heading">
<A NAME="pgfId-306903"></A>Example of masked behavior</H6>
<P CLASS="Python">
<A NAME="pgfId-306904"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
from MA import *</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306905"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x=arange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306906"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x[3] = masked</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306907"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306908"></A>[0 ,1 ,2 ,-- ,4 ,5 ,6 ,7 ,8 ,9 ,]</P>
<P CLASS="Python">
<A NAME="pgfId-306909"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print repr(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306910"></A>*** Masked array, mask present ***</P>
<P CLASS="Python">
<A NAME="pgfId-306911"></A>Data:</P>
<P CLASS="Python">
<A NAME="pgfId-306912"></A>[0 ,1 ,2 ,-- ,4 ,5 ,6 ,7 ,8 ,9 ,]</P>
<P CLASS="Python">
<A NAME="pgfId-306913"></A>Mask (fill value [0,])</P>
<P CLASS="Python">
<A NAME="pgfId-306914"></A>[0,0,0,1,0,0,0,0,0,0,]</P>
<P CLASS="Python">
<A NAME="pgfId-306915"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-306916"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[3]</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306917"></A>--</P>
<P CLASS="Python">
<A NAME="pgfId-306918"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x[3] + 1.0</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306919"></A>Traceback (innermost last):</P>
<P CLASS="Python">
<A NAME="pgfId-306920"></A>  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</P>
<P CLASS="Python">
<A NAME="pgfId-306921"></A>  File &quot;/pcmdi/dubois/prerelease/linux/lib/python1.5/site-packages/MA/__init__.py&quot;, line 62, in nope</P>
<P CLASS="Python">
<A NAME="pgfId-306922"></A>    raise MAError, 'Cannot do requested operation with a masked value.'</P>
<P CLASS="Python">
<A NAME="pgfId-306923"></A>MA.MAError: Cannot do requested operation with a masked value.</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305737"></A>Class masked_unary_function</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-305741"></A>Given a unary array function f (x), <A NAME="marker-305745"></A>masked_unary_function (f, fill = 0, domain = None) is a function which when applied to an argument x returns f applied to the array filled (x, fill), with a mask equal to <BR>
mask_or (getmask (x), domain (x)). </P>
<P CLASS="Body">
<A NAME="pgfId-305744"></A>The argument domain therefore should be a callable object that returns true where x is not in the domain of f. The following domains are also supplied as members of module MA:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-305749"></A>domain_check_interval (a, b) (x) = true where x &lt; a or y &gt; b.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305753"></A>domain_tan (eps) (x) is true where abs (cos (x)) &lt; eps, that is, a domain suitable for the tangent function.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305754"></A>domain_greater (v) (x) is true where x &lt;= v.</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305755"></A>domain_greater_equal (v) (x) is true where x &lt; v.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-305759"></A>Class masked_binary_function</H6>
<P CLASS="BodyAfterHead">
<A NAME="pgfId-305766"></A>Given a binary array function f (x, y), masked_binary_function (f, fillx=0, filly=0, domain=None) defines a function whose value at x is f (filled (x, fillx), filled (y, filly)) with a resulting mask of mask_or (getmask (x), getmask (y), mask_or'd again with those locations where domain (x, y) is true. The values fillx and filly must be chosen so that (fillx, filly) is in the domain of f. </P>
<P CLASS="Body">
<A NAME="pgfId-305771"></A>In addition, an instance of masked_binary_function has two methods defined upon it:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-305772"></A>reduce (target, axis = 0)</LI>
<LI CLASS="Bullet">
<A NAME="pgfId-305776"></A>accumulate (target, axis = 0)</LI>
</UL>
<P CLASS="Body">
<A NAME="pgfId-305780"></A>These methods perform reduction and accumulation as discussed in the section <A HREF="numdoc.html#87042" CLASS="XRef">Ufuncs have special methods</A>.</P>
<P CLASS="Body">
<A NAME="pgfId-305787"></A>The following domains are available for use as the domain argument:</P>
<UL>
<LI CLASS="Bullet">
<A NAME="pgfId-305788"></A>domain_safe_divide () (x, y) is true where absolute(x)*1.e-35 &gt; absolute (y). As the comments in the code say, &quot;better ideas welcome&quot;. This domain is used for the divide operator.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306950"></A>ActiveAttributes</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306954"></A>MA contains a subpackage, MA.activeattr, which defines the class ActiveAttributes. Class MaskedArray inherits from ActiveAttributes. </P>
<P CLASS="Body">
<A NAME="pgfId-306961"></A>An active attribute is a name, say active, that appears to be an attribute of a class instance but which in fact is implemented by a triplet of functions, one each corresponding to the operations x.active, x.active = value, and del x.active. To create such an attribute, you inherit from ActiveAttributes and in your classes' initialization routine you do:</P>
<P CLASS="Python">
<A NAME="pgfId-306968"></A>ActiveAttributes.__init__(self) # safe for multiple inheritance</P>
<P CLASS="Python">
<A NAME="pgfId-306972"></A>self.add_active_attribute_handler (&quot;active&quot;, self.actg, </P>
<P CLASS="Python">
<A NAME="pgfId-306989"></A>	self.acts, self.actd)</P>
<P CLASS="Body">
<A NAME="pgfId-306973"></A>Here actg, acts, and actd are the three handlers, which should be methods of this class with signatures actg(self), acts(self, value), and actd(self). The last two arguments to add_active_attribute_handler can be None, in which case the &quot;active&quot; attribute will behave as if it is read-only.</P>
<P CLASS="Body">
<A NAME="pgfId-306990"></A>The &quot;attributes&quot; shape, flat, real, and imag in class MaskedArray are actually &quot;active&quot; attributes.</P>
<P CLASS="Body">
<A NAME="pgfId-306991"></A>ActiveAttributes also contains methods:</P>
<P CLASS="Python">
<A NAME="pgfId-306994"></A>def get_active_attribute_handler (self, name):</P>
<P CLASS="Python">
<A NAME="pgfId-306995"></A>        &quot;Get current attribute handler associated with a name.&quot;</P>
<P CLASS="Python">
<A NAME="pgfId-306998"></A>def get_active_attributes (self):</P>
<P CLASS="Python">
<A NAME="pgfId-306999"></A>        &quot;Return the list of attributes that have handlers.&quot;</P>
<P CLASS="Python">
<A NAME="pgfId-307002"></A>def get_attribute_mode (self, name):</P>
<P CLASS="Python">
<A NAME="pgfId-307003"></A>        &quot;Get the mode of an attribute readonly ('r') or writeable ('w').&quot;</P>
<P CLASS="Python">
<A NAME="pgfId-307006"></A>def get_basic_attribute_handler (self):</P>
<P CLASS="Python">
<A NAME="pgfId-307046"></A>	&quot;Returns the underlying methods that handle the three events.&quot;</P>
<P CLASS="Python">
<A NAME="pgfId-307071"></A>def remove_active_attribute_handler (self, name):</P>
<P CLASS="Python">
<A NAME="pgfId-307356"></A>	&quot;Remove the `active' behavior for name.&quot;</P>
</DIV>
</DIV>
<DIV>
<H6 CLASS="FM1Heading">
<A NAME="pgfId-306123"></A>Examples of Using MA</H6>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306127"></A>Data with a given value representing missing data</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306131"></A>Suppose we have read a one-dimensional list of elements named x. We also know that if any of the values are 1.e20, they represent missing data. We want to compute the average value of the data and the vector of deviations from average.</P>
<P CLASS="Python">
<A NAME="pgfId-306443"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
from MA import *</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306505"></A>&gt;&gt;&gt; x = arange(5)</P>
<P CLASS="Python">
<A NAME="pgfId-306511"></A>&gt;&gt;&gt; x[2] = 1.e20</P>
<P CLASS="Python">
<A NAME="pgfId-306508"></A>&gt;&gt;&gt; y = masked_values (x, 1.e20)</P>
<P CLASS="Python">
<A NAME="pgfId-306477"></A>&gt;&gt;&gt; print average(y)</P>
<P CLASS="Python">
<A NAME="pgfId-306478"></A>2.0</P>
<P CLASS="Python">
<A NAME="pgfId-306479"></A>&gt;&gt;&gt; print y-average(y)</P>
<P CLASS="Python">
<A NAME="pgfId-306482"></A>[ -2.00000000e+00, -1.00000000e+00,  --,  1.00000000e+00,</P>
<P CLASS="Python">
<A NAME="pgfId-306483"></A>        2.00000000e+00,]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306145"></A><A NAME="16670"></A>Filling in the missing data</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306155"></A>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</P>
<P CLASS="Python">
<A NAME="pgfId-306156"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print filled (y, average(y))</EM>
</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306378"></A>Numerical operations</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306382"></A>We can do numerical operations without worrying about missing values, dividing by zero, square roots of negative numbers, etc.</P>
<P CLASS="Python">
<A NAME="pgfId-306388"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
from MA import *</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306389"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x=array([1., -1., 3., 4., 5., 6.], mask=[0,0,0,0,1,0])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306390"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
y=array([1., 2., 0., 4., 5., 6.], mask=[0,0,0,0,0,1])</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306391"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print sqrt(x/y)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-306392"></A>[  1.00000000e+00,  --,  --,  1.00000000e+00, --,  --,]</P>
<P CLASS="Body">
<A NAME="pgfId-306383"></A>Note that four values in the result are invalid: one from a negative square root, one from a divide by zero, and two more where the two arrays x and y had invalid data. Since the result was of a real type, the print command printed str (filled (sqrt (x/y))).</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306406"></A>Seeing the mask</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306410"></A>There are various ways to see the mask. One is to print is directly, the other is to convert to the repr representation, and a third is get the mask itself. Use of getmask(x) is more robust than x.mask(), since it will work (returning None) if x is a Numeric array or list.</P>
<P CLASS="Python">
<A NAME="pgfId-307389"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x=arange(10)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307390"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
x[3:5] = masked</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307391"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307392"></A>[0 ,1 ,2 ,-- ,-- ,5 ,6 ,7 ,8 ,9 ,]</P>
<P CLASS="Python">
<A NAME="pgfId-307393"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print repr(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307394"></A>*** Masked array, mask present ***</P>
<P CLASS="Python">
<A NAME="pgfId-307395"></A>Data:</P>
<P CLASS="Python">
<A NAME="pgfId-307396"></A>[0 ,1 ,2 ,-- ,-- ,5 ,6 ,7 ,8 ,9 ,]</P>
<P CLASS="Python">
<A NAME="pgfId-307397"></A>Mask (fill value [0,])</P>
<P CLASS="Python">
<A NAME="pgfId-307398"></A>[0,0,0,1,1,0,0,0,0,0,]</P>
<P CLASS="Python">
<A NAME="pgfId-307399"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-307400"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print getmask(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-307401"></A>[0,0,0,1,1,0,0,0,0,0,]</P>
<P CLASS="Python">
<A NAME="pgfId-307387"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-306428"></A>Filling it your way</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-306441"></A>If we want to print the data with -1's where the elements are masked, we use filled.</P>
<P CLASS="Python">
<A NAME="pgfId-306433"></A>&gt;&gt;&gt; <EM CLASS="CodeInput">
print filled(z, -1)</EM>
     </P>
<P CLASS="Python">
<A NAME="pgfId-306434"></A>[ 1.,-1.,-1., 1.,-1.,-1.,]</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320020"></A>Ignoring extreme values</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320028"></A>Suppose we have an array d and we wish to compute the average of the values in d but ignore any data outside the range -100. to 100. </P>
<P CLASS="Python">
<A NAME="pgfId-320029"></A>v = masked_outside(d, -100., 100.)</P>
<P CLASS="Python">
<A NAME="pgfId-320030"></A>print average(v)</P>
</DIV>
<DIV>
<H6 CLASS="FM2Heading">
<A NAME="pgfId-320037"></A>Averaging an entire multidimensional array</H6>
<P CLASS="FirstBody">
<A NAME="pgfId-320069"></A>The problem with averaging over an entire array is that the average function only reduces one dimension at a time. So to average the entire array, ravel it first.</P>
<P CLASS="Python">
<A NAME="pgfId-320046"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; x</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320047"></A>*** Masked array, no mask ***</P>
<P CLASS="Python">
<A NAME="pgfId-320048"></A>Data:</P>
<P CLASS="Python">
<A NAME="pgfId-320049"></A>[[ 0, 1, 2,]</P>
<P CLASS="Python">
<A NAME="pgfId-320050"></A> [ 3, 4, 5,]</P>
<P CLASS="Python">
<A NAME="pgfId-320051"></A> [ 6, 7, 8,]</P>
<P CLASS="Python">
<A NAME="pgfId-320052"></A> [ 9,10,11,]]</P>
<P CLASS="Python">
<A NAME="pgfId-320053"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-320054"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; average(x)</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320055"></A>*** Masked array, no mask ***</P>
<P CLASS="Python">
<A NAME="pgfId-320056"></A>Data:</P>
<P CLASS="Python">
<A NAME="pgfId-320057"></A>[ 4.5, 5.5, 6.5,]</P>
<P CLASS="Python">
<A NAME="pgfId-320058"></A>&nbsp;</P>
<P CLASS="Python">
<A NAME="pgfId-320059"></A><EM CLASS="CodeInput">
&gt;&gt;&gt; average(ravel(x))</EM>
</P>
<P CLASS="Python">
<A NAME="pgfId-320060"></A>5.5</P>
<P CLASS="Python">
<A NAME="pgfId-320041"></A>&nbsp;</P>
<P CLASS="IndexTitle">
<A NAME="pgfId-862972"></A>Index</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875612"></A>Symbols<A NAME="Symbols"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875614"></A><A HREF="numdoc.html#marker-307929" CLASS="Index"> 98</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875616"></A><A HREF="numdoc.html#marker-59821" CLASS="Index">... 26</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875618"></A><A HREF="numdoc.html#marker-59830" CLASS="Index">: 25</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875620"></A><A HREF="numdoc.html#marker-59831" CLASS="Index"></a><A HREF="numdoc.html#marker-59857" CLASS="Index">:: 26, 53</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875623"></A><A HREF="numdoc.html#marker-59753" CLASS="Index">_PyArray_multiply_list 66</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875625"></A>A<A NAME="Numerics"></A><A NAME="A"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875628"></A><A HREF="numdoc.html#marker-59698" CLASS="Index">alltrue() 44</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875630"></A><A HREF="numdoc.html#marker-66025" CLASS="Index">argmax() 39</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875632"></A><A HREF="numdoc.html#marker-65840" CLASS="Index">argsort() 39</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875634"></A><A HREF="numdoc.html#marker-59794" CLASS="Index">array 73</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875636"></A><A HREF="numdoc.html#marker-59711" CLASS="Index">Array Attributes 47</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875638"></A><A HREF="numdoc.html#marker-59632" CLASS="Index">Array Functions 34</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875640"></A><A HREF="numdoc.html#marker-59710" CLASS="Index">Array Methods 45</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875642"></A><A HREF="numdoc.html#marker-59546" CLASS="Index">array() 12</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875644"></A><A HREF="numdoc.html#marker-59658" CLASS="Index">array_repr() 42</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875646"></A><A HREF="numdoc.html#marker-59659" CLASS="Index">array_str() 42</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875648"></A><A HREF="numdoc.html#marker-59729" CLASS="Index">array2string 55</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875650"></A><A HREF="numdoc.html#marker-59737" CLASS="Index">arrayobject.h 58</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875652"></A><A HREF="numdoc.html#marker-59594" CLASS="Index">arrayrange() 17</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875654"></A><A HREF="numdoc.html#marker-308206" CLASS="Index">arrays with missing values 89</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875656"></A><A HREF="numdoc.html#marker-59617" CLASS="Index">astype 22</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875658"></A><A HREF="numdoc.html#marker-59609" CLASS="Index">Automatic Coercions 20</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875660"></A><A HREF="numdoc.html#marker-59544" CLASS="Index">axes 12</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875662"></A>B<A NAME="B"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875664"></A><A HREF="numdoc.html#marker-59727" CLASS="Index">Broadcasting 54</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875666"></A><A HREF="numdoc.html#marker-68554" CLASS="Index">Bugs 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875668"></A><A HREF="numdoc.html#marker-59707" CLASS="Index">byteswapped() 45</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875670"></A>C<A NAME="C"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875672"></A><A HREF="numdoc.html#marker-59608" CLASS="Index">Casting 20</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875674"></A><A HREF="numdoc.html#marker-59548" CLASS="Index">Character 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875676"></A><A HREF="numdoc.html#marker-59484" CLASS="Index">choose 36</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875678"></A><A HREF="numdoc.html#marker-59647" CLASS="Index">clip() 40</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875680"></A><A HREF="numdoc.html#marker-67986" CLASS="Index">Code Organization 49</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875682"></A><A HREF="numdoc.html#marker-59607" CLASS="Index">Coercion 20</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875684"></A><A HREF="numdoc.html#marker-59576" CLASS="Index">Complex 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875686"></A><A HREF="numdoc.html#marker-84325" CLASS="Index">complex numbers 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875688"></A><A HREF="numdoc.html#marker-59577" CLASS="Index">Complex0 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875690"></A><A HREF="numdoc.html#marker-59582" CLASS="Index">Complex128 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875692"></A><A HREF="numdoc.html#marker-59579" CLASS="Index">Complex16 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875694"></A><A HREF="numdoc.html#marker-59580" CLASS="Index">Complex32 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875696"></A><A HREF="numdoc.html#marker-59581" CLASS="Index">Complex64 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875698"></A><A HREF="numdoc.html#marker-59578" CLASS="Index">Complex8 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875700"></A><A HREF="numdoc.html#marker-59638" CLASS="Index">compress() 37</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875702"></A><A HREF="numdoc.html#marker-59651" CLASS="Index">concatenate() 41</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875704"></A><A HREF="numdoc.html#marker-59740" CLASS="Index">Contiguous arrays 60</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875706"></A><A HREF="numdoc.html#marker-60951" CLASS="Index">Convenience 10</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875708"></A><A HREF="numdoc.html#marker-67940" CLASS="Index">convolve 43</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875710"></A><A HREF="numdoc.html#marker-67939" CLASS="Index">correlation 43</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875712"></A><A HREF="numdoc.html#marker-67939" CLASS="Index">cross_correlate 43</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875714"></A><A HREF="numdoc.html#marker-59697" CLASS="Index">cumproduct() 44</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875716"></A><A HREF="numdoc.html#marker-59695" CLASS="Index">cumsum() 44</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875718"></A><A HREF="numdoc.html#marker-68553" CLASS="Index">CVS 6</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875720"></A>D<A NAME="D"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875722"></A><A HREF="numdoc.html#marker-303081" CLASS="Index">determinant() 81</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875724"></A><A HREF="numdoc.html#marker-59639" CLASS="Index"></a><A HREF="numdoc.html#marker-59662" CLASS="Index">diagonal() 37, 42</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875727"></A><A HREF="numdoc.html#marker-59543" CLASS="Index">dimensions 12</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875729"></A><A HREF="numdoc.html#marker-68556" CLASS="Index">Discussion list 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875731"></A><A HREF="numdoc.html#marker-68604" CLASS="Index">Distutils 58</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875733"></A><A HREF="numdoc.html#marker-305509" CLASS="Index">Dubois, Paul F. 89</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875735"></A>E<A NAME="E"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875737"></A><A HREF="numdoc.html#marker-303046" CLASS="Index">eigenvalues() 80</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875739"></A><A HREF="numdoc.html#marker-303057" CLASS="Index">eigenvectors() 81</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875741"></A><A HREF="numdoc.html#marker-61094" CLASS="Index">element-wise 12</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875743"></A><A HREF="numdoc.html#marker-59725" CLASS="Index">Ellipses 54</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875745"></A>F<A NAME="F"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875747"></A><A HREF="numdoc.html#marker-302950" CLASS="Index">FFT 77</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875749"></A><A HREF="numdoc.html#marker-302957" CLASS="Index">fft() 77</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875751"></A><A HREF="numdoc.html#marker-59712" CLASS="Index">flat (attribute) 47</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875753"></A><A HREF="numdoc.html#marker-59566" CLASS="Index">Float 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875755"></A><A HREF="numdoc.html#marker-59570" CLASS="Index">Float0 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875757"></A><A HREF="numdoc.html#marker-59575" CLASS="Index">Float128 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875759"></A><A HREF="numdoc.html#marker-59572" CLASS="Index">Float16 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875761"></A><A HREF="numdoc.html#marker-59573" CLASS="Index">Float32 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875763"></A><A HREF="numdoc.html#marker-59574" CLASS="Index">Float64 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875765"></A><A HREF="numdoc.html#marker-59571" CLASS="Index">Float8 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875767"></A><A HREF="numdoc.html#marker-59732" CLASS="Index">floating point exceptions 57</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875769"></A><A HREF="numdoc.html#marker-59733" CLASS="Index">fpectl 57</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875771"></A><A HREF="numdoc.html#marker-59598" CLASS="Index">fromfunction() 19</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875773"></A><A HREF="numdoc.html#marker-59645" CLASS="Index"></a><A HREF="numdoc.html#marker-67905" CLASS="Index">fromstring() 39, 43</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875776"></A><A HREF="numdoc.html#marker-68557" CLASS="Index">FTP Site 6</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875778"></A>G<A NAME="G"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875780"></A>gather</LI>
<UL>
<LI CLASS="Level2IX">
<A NAME="pgfId-875781"></A><A HREF="numdoc.html#marker-78559" CLASS="Index">see put() 35</A></LI>
</UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875783"></A><A HREF="numdoc.html#marker-303078" CLASS="Index">generalized_inverse() 81</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875785"></A><A HREF="numdoc.html#marker-303098" CLASS="Index">get_seed() 82</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875787"></A><A HREF="numdoc.html#marker-59618" CLASS="Index">Getting array values 24</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875789"></A><A HREF="numdoc.html#marker-59531" CLASS="Index">greece 7</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875791"></A>H<A NAME="H"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875793"></A><A HREF="numdoc.html#marker-68605" CLASS="Index">header files 58</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875795"></A><A HREF="numdoc.html#marker-59541" CLASS="Index">homogeneous 12</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875797"></A>I<A NAME="I"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875799"></A><A HREF="numdoc.html#marker-59606" CLASS="Index"></a><A HREF="numdoc.html#marker-59693" CLASS="Index">identity() 20, 43</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875802"></A><A HREF="numdoc.html#marker-59534" CLASS="Index">IDLE 8</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875804"></A><A HREF="numdoc.html#marker-59714" CLASS="Index">imaginary (attribute) 47</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875806"></A><A HREF="numdoc.html#marker-84325" CLASS="Index">imaginary numbers 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875808"></A><A HREF="numdoc.html#marker-68605" CLASS="Index">import_array() 58</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875810"></A><A HREF="numdoc.html#marker-59724" CLASS="Index">Indexing 53</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875812"></A><A HREF="numdoc.html#marker-66266" CLASS="Index">indices() 40</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875814"></A><A HREF="numdoc.html#marker-59656" CLASS="Index">innerproduct() 42</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875816"></A><A HREF="numdoc.html#marker-59513" CLASS="Index">Installing NumPy 5</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875818"></A><A HREF="numdoc.html#marker-59558" CLASS="Index">Int 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875820"></A><A HREF="numdoc.html#marker-59559" CLASS="Index">Int0 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875822"></A><A HREF="numdoc.html#marker-59565" CLASS="Index">Int128 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875824"></A><A HREF="numdoc.html#marker-59561" CLASS="Index">Int16 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875826"></A><A HREF="numdoc.html#marker-59562" CLASS="Index">Int32 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875828"></A><A HREF="numdoc.html#marker-59563" CLASS="Index">Int64 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875830"></A><A HREF="numdoc.html#marker-59560" CLASS="Index">Int8 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875832"></A><A HREF="numdoc.html#marker-303022" CLASS="Index">inverse() 80</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875834"></A><A HREF="numdoc.html#marker-302969" CLASS="Index">inverse_fft() 77</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875836"></A><A HREF="numdoc.html#marker-302985" CLASS="Index">inverse_real_fft() 78</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875838"></A><A HREF="numdoc.html#marker-59705" CLASS="Index">iscontiguous() 45</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875840"></A><A HREF="numdoc.html#marker-59704" CLASS="Index">itemsize() 45</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875842"></A>L<A NAME="J"></A><A NAME="K"></A><A NAME="L"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875846"></A><A HREF="numdoc.html#marker-307934" CLASS="Index">limiting printing of large arrays 98</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875848"></A><A HREF="numdoc.html#marker-303084" CLASS="Index">linear_least_squares() 81</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-875850"></A><A HREF="numdoc.html#marker-59626" CLASS="Index">Logical Ufuncs 30</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-875852"></A>M<A NAME="M"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-875854"></A>MA</LI>
<UL>
<LI CLASS="Level2IX">
<A NAME="pgfId-875855"></A><A HREF="numdoc.html#marker-307875" CLASS="Index">absolute 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875857"></A><A HREF="numdoc.html#marker-307882" CLASS="Index">add 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875859"></A><A HREF="numdoc.html#marker-307920" CLASS="Index">allclose 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875861"></A><A HREF="numdoc.html#marker-307921" CLASS="Index">allequal 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875863"></A><A HREF="numdoc.html#marker-307904" CLASS="Index">alltrue 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875865"></A><A HREF="numdoc.html#marker-305810" CLASS="Index">arange 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875867"></A><A HREF="numdoc.html#marker-307870" CLASS="Index">arccos 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875869"></A><A HREF="numdoc.html#marker-307869" CLASS="Index">arcsin 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875871"></A><A HREF="numdoc.html#marker-307871" CLASS="Index">arctan 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875873"></A><A HREF="numdoc.html#marker-307890" CLASS="Index">arctan2 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875875"></A><A HREF="numdoc.html#marker-307932" CLASS="Index">argsort 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875877"></A><A HREF="numdoc.html#marker-307882" CLASS="Index">arithmetic operators 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875879"></A><A HREF="numdoc.html#marker-307879" CLASS="Index">around 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875881"></A><A HREF="numdoc.html#marker-308230" CLASS="Index">array (constructor) 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875883"></A><A HREF="numdoc.html#marker-305817" CLASS="Index">arrayrange 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875885"></A><A HREF="numdoc.html#marker-308029" CLASS="Index">average 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875887"></A><A HREF="numdoc.html#marker-307891" CLASS="Index">bitwise_and 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875889"></A><A HREF="numdoc.html#marker-307892" CLASS="Index">bitwise_or 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875891"></A><A HREF="numdoc.html#marker-307893" CLASS="Index">bitwise_xor 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875893"></A><A HREF="numdoc.html#marker-307939" CLASS="Index">choose 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875895"></A><A HREF="numdoc.html#marker-306622" CLASS="Index">class MA 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875897"></A><A HREF="numdoc.html#marker-307897" CLASS="Index">comparisons 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875899"></A><A HREF="numdoc.html#marker-307928" CLASS="Index">compress 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875901"></A><A HREF="numdoc.html#marker-307911" CLASS="Index">concatenate 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875903"></A><A HREF="numdoc.html#marker-307865" CLASS="Index">conjugate 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875905"></A><A HREF="numdoc.html#marker-307867" CLASS="Index">cos 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875907"></A><A HREF="numdoc.html#marker-307873" CLASS="Index">cosh 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875909"></A><A HREF="numdoc.html#marker-307916" CLASS="Index">count 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875911"></A><A HREF="numdoc.html#marker-305349" CLASS="Index">default_character_fill_value 93</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875913"></A><A HREF="numdoc.html#marker-305348" CLASS="Index">default_complex_fill_value 93</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875915"></A><A HREF="numdoc.html#marker-305350" CLASS="Index">default_integer_fill_value 93</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875917"></A><A HREF="numdoc.html#marker-305352" CLASS="Index">default_object_fill_value 93</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875919"></A><A HREF="numdoc.html#marker-305365" CLASS="Index">default_real_fill_value 93</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875921"></A><A HREF="numdoc.html#marker-307885" CLASS="Index">divide 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875923"></A><A HREF="numdoc.html#marker-307894" CLASS="Index">equal 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875925"></A><A HREF="numdoc.html#marker-307864" CLASS="Index">exp 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875927"></A><A HREF="numdoc.html#marker-307876" CLASS="Index">fabs 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875929"></A><A HREF="numdoc.html#marker-305346" CLASS="Index">fill_value 93</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875931"></A><A HREF="numdoc.html#marker-307880" CLASS="Index">floor 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875933"></A><A HREF="numdoc.html#marker-307888" CLASS="Index">fmod 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875935"></A><A HREF="numdoc.html#marker-304071" CLASS="Index">functions and operators 95</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875937"></A><A HREF="numdoc.html#marker-307933" CLASS="Index">get_print_limit 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875939"></A><A HREF="numdoc.html#marker-305356" CLASS="Index">getmask 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875941"></A><A HREF="numdoc.html#marker-305367" CLASS="Index">getmaskarray 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875943"></A><A HREF="numdoc.html#marker-307899" CLASS="Index">greater 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875945"></A><A HREF="numdoc.html#marker-307897" CLASS="Index">greater_equal 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875947"></A><A HREF="numdoc.html#marker-307889" CLASS="Index">hypot 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875949"></A><A HREF="numdoc.html#marker-307912" CLASS="Index">identity 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875951"></A><A HREF="numdoc.html#marker-307913" CLASS="Index">indices 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875953"></A><A HREF="numdoc.html#marker-307925" CLASS="Index">innerproduct 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875955"></A><A HREF="numdoc.html#marker-305507" CLASS="Index">installing 89</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875957"></A><A HREF="numdoc.html#marker-305508" CLASS="Index">invalid, defined 89</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875959"></A><A HREF="numdoc.html#marker-305354" CLASS="Index">is_mask 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875961"></A><A HREF="numdoc.html#marker-305831" CLASS="Index">isarray 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875963"></A><A HREF="numdoc.html#marker-305832" CLASS="Index">isMA 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875965"></A><A HREF="numdoc.html#marker-307914" CLASS="Index">len 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875967"></A><A HREF="numdoc.html#marker-307898" CLASS="Index">less 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875969"></A><A HREF="numdoc.html#marker-307896" CLASS="Index">less_equal 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875971"></A><A HREF="numdoc.html#marker-307862" CLASS="Index">log 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875973"></A><A HREF="numdoc.html#marker-307863" CLASS="Index">log10 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875975"></A><A HREF="numdoc.html#marker-307900" CLASS="Index">logical operators 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875977"></A><A HREF="numdoc.html#marker-307902" CLASS="Index">logical_and 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875979"></A><A HREF="numdoc.html#marker-308197" CLASS="Index">logical_not 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875981"></A><A HREF="numdoc.html#marker-307901" CLASS="Index">logical_or 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875983"></A><A HREF="numdoc.html#marker-307903" CLASS="Index">logical_xor 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875985"></A><A HREF="numdoc.html#marker-307935" CLASS="Index">MAError 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875987"></A><A HREF="numdoc.html#marker-305355" CLASS="Index">make_mask 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875989"></A><A HREF="numdoc.html#marker-305366" CLASS="Index">mask method 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875991"></A><A HREF="numdoc.html#marker-305802" CLASS="Index">mask_object (constructor) 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875993"></A><A HREF="numdoc.html#marker-305370" CLASS="Index">mask_or 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875995"></A><A HREF="numdoc.html#marker-305506" CLASS="Index">mask_values 89</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875997"></A><A HREF="numdoc.html#marker-307936" CLASS="Index">masked (constant) 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-875999"></A><A HREF="numdoc.html#marker-307957" CLASS="Index">masked (constant), role in printing 99</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876001"></A><A HREF="numdoc.html#marker-306591" CLASS="Index">masked (module constant) 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876003"></A><A HREF="numdoc.html#marker-306618" CLASS="Index">masked (special constant) 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876005"></A><A HREF="numdoc.html#marker-305508" CLASS="Index">masked, defined 89</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876007"></A><A HREF="numdoc.html#marker-304072" CLASS="Index">masked_array 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876009"></A><A HREF="numdoc.html#marker-308232" CLASS="Index">masked_array (constructor) 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876011"></A><A HREF="numdoc.html#marker-307797" CLASS="Index">masked_equal 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876013"></A><A HREF="numdoc.html#marker-307789" CLASS="Index">masked_greater 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876015"></A><A HREF="numdoc.html#marker-307793" CLASS="Index">masked_greater_equal 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876017"></A><A HREF="numdoc.html#marker-307805" CLASS="Index">masked_less 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876019"></A><A HREF="numdoc.html#marker-307809" CLASS="Index">masked_less_equal 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876021"></A><A HREF="numdoc.html#marker-307801" CLASS="Index">masked_not_equal 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876023"></A><A HREF="numdoc.html#marker-305745" CLASS="Index">masked_unary_function 99</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876025"></A><A HREF="numdoc.html#marker-307810" CLASS="Index">masked_values 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876027"></A><A HREF="numdoc.html#marker-307732" CLASS="Index">masked_where 92</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876029"></A><A HREF="numdoc.html#marker-320328" CLASS="Index">masks, and savespace attribute 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876031"></A><A HREF="numdoc.html#marker-320328" CLASS="Index">masks, description of 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876033"></A><A HREF="numdoc.html#marker-307929" CLASS="Index">maximum 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876035"></A><A HREF="numdoc.html#marker-307929" CLASS="Index">maximum with two arguments 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876037"></A><A HREF="numdoc.html#marker-307930" CLASS="Index">minimum 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876039"></A><A HREF="numdoc.html#marker-307884" CLASS="Index">multiply 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876041"></A><A HREF="numdoc.html#marker-307877" CLASS="Index">negative 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876043"></A><A HREF="numdoc.html#marker-307878" CLASS="Index">nonzero 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876045"></A><A HREF="numdoc.html#marker-307895" CLASS="Index">not_equal 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876047"></A><A HREF="numdoc.html#marker-305822" CLASS="Index">ones 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876049"></A><A HREF="numdoc.html#marker-307926" CLASS="Index">outerproduct 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876051"></A><A HREF="numdoc.html#marker-307886" CLASS="Index">power 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876053"></A><A HREF="numdoc.html#marker-307918" CLASS="Index">product 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876055"></A><A HREF="numdoc.html#marker-307924" CLASS="Index">put 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876057"></A><A HREF="numdoc.html#marker-307906" CLASS="Index">rank 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876059"></A><A HREF="numdoc.html#marker-307910" CLASS="Index">ravel 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876061"></A><A HREF="numdoc.html#marker-307887" CLASS="Index">remainder 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876063"></A><A HREF="numdoc.html#marker-307909" CLASS="Index">reshape 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876065"></A><A HREF="numdoc.html#marker-307908" CLASS="Index">resize 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876067"></A><A HREF="numdoc.html#marker-320343" CLASS="Index">set_fill_value 94</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876069"></A><A HREF="numdoc.html#marker-307934" CLASS="Index">set_print_limit 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876071"></A><A HREF="numdoc.html#marker-307907" CLASS="Index">shape 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876073"></A><A HREF="numdoc.html#marker-307866" CLASS="Index">sin 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876075"></A><A HREF="numdoc.html#marker-307872" CLASS="Index">sinh 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876077"></A><A HREF="numdoc.html#marker-307915" CLASS="Index">size 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876079"></A><A HREF="numdoc.html#marker-307905" CLASS="Index">sometrue 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876081"></A><A HREF="numdoc.html#marker-307931" CLASS="Index">sort 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876083"></A><A HREF="numdoc.html#marker-307861" CLASS="Index">sqrt 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876085"></A><A HREF="numdoc.html#marker-307883" CLASS="Index">subtract 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876087"></A><A HREF="numdoc.html#marker-307917" CLASS="Index">sum 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876089"></A><A HREF="numdoc.html#marker-307922" CLASS="Index">take 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876091"></A><A HREF="numdoc.html#marker-307868" CLASS="Index">tan 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876093"></A><A HREF="numdoc.html#marker-307874" CLASS="Index">tanh 96</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876095"></A><A HREF="numdoc.html#marker-307923" CLASS="Index">transpose 97</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876097"></A><A HREF="numdoc.html#marker-307860" CLASS="Index">where 98</A></LI>
<LI CLASS="Level2IX">
<A NAME="pgfId-876099"></A><A HREF="numdoc.html#marker-305826" CLASS="Index">zeros 97</A></LI>
</UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876101"></A><A HREF="numdoc.html#marker-68202" CLASS="Index">MA (masked arrays) 9</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876103"></A><A HREF="numdoc.html#marker-68556" CLASS="Index">mailing list 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876105"></A><A HREF="numdoc.html#marker-308206" CLASS="Index">masked arrays 89</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876107"></A><A HREF="numdoc.html#marker-59797" CLASS="Index">Matrix 73</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876109"></A><A HREF="numdoc.html#marker-59646" CLASS="Index">matrixmultiply() 40</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876111"></A><A HREF="numdoc.html#marker-68202" CLASS="Index"></a><A HREF="numdoc.html#marker-308206" CLASS="Index">missing values 9, 89</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876114"></A><A HREF="numdoc.html#marker-59537" CLASS="Index"></a><A HREF="numdoc.html#marker-59540" CLASS="Index"></a><A HREF="numdoc.html#marker-66810" CLASS="Index"></a><A HREF="numdoc.html#marker-59795" CLASS="Index">multiarray 9, 12, 52, 73</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876119"></A>N<A NAME="N"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876121"></A><A HREF="numdoc.html#marker-59733" CLASS="Index">NaNs 57</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876123"></A><A HREF="numdoc.html#marker-59833" CLASS="Index"></a><A HREF="numdoc.html#marker-59726" CLASS="Index">NewAxis 33, 54</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876126"></A><A HREF="numdoc.html#marker-59636" CLASS="Index">nonzero() 37</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876128"></A><A HREF="numdoc.html#marker-59536" CLASS="Index">Numeric.py 9</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876130"></A><A HREF="numdoc.html#marker-59530" CLASS="Index">NumTut 7</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876132"></A>O<A NAME="O"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876134"></A><A HREF="numdoc.html#marker-308207" CLASS="Index">observations, dealing with missing 89</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876136"></A><A HREF="numdoc.html#marker-60119" CLASS="Index">ones() 17</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876138"></A><A HREF="numdoc.html#marker-84312" CLASS="Index">outerproduct 42</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876140"></A>P<A NAME="P"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876142"></A><A HREF="numdoc.html#marker-68555" CLASS="Index">Patches 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876144"></A><A HREF="numdoc.html#marker-303110" CLASS="Index">permutation() 82</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876146"></A><A HREF="numdoc.html#marker-59730" CLASS="Index">Pickling 57</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876148"></A>printing</LI>
<UL>
<LI CLASS="Level2IX">
<A NAME="pgfId-876149"></A><A HREF="numdoc.html#marker-307934" CLASS="Index">using MA to limit printing of large arrays 98</A></LI>
</UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876151"></A><A HREF="numdoc.html#marker-59696" CLASS="Index">product() 44</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876153"></A><A HREF="numdoc.html#marker-59631" CLASS="Index">Pseudo Indices 32</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876155"></A><A HREF="numdoc.html#marker-78558" CLASS="Index">put() 35</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876157"></A><A HREF="numdoc.html#marker-59764" CLASS="Index">PyArray_As1D 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876159"></A><A HREF="numdoc.html#marker-59765" CLASS="Index">PyArray_As2D 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876161"></A><A HREF="numdoc.html#marker-59751" CLASS="Index">PyArray_CanCastSafely 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876163"></A><A HREF="numdoc.html#marker-59750" CLASS="Index">PyArray_Cast 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876165"></A><A HREF="numdoc.html#marker-59743" CLASS="Index">PyArray_Check 65</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876167"></A><A HREF="numdoc.html#marker-59757" CLASS="Index">PyArray_ContiguousFromObject 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876169"></A><A HREF="numdoc.html#marker-59762" CLASS="Index">PyArray_Copy 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876171"></A><A HREF="numdoc.html#marker-59758" CLASS="Index">PyArray_CopyFromObject 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876173"></A><A HREF="numdoc.html#marker-59749" CLASS="Index">PyArray_DescrFromType 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876175"></A><A HREF="numdoc.html#marker-59766" CLASS="Index">PyArray_Free 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876177"></A><A HREF="numdoc.html#marker-59755" CLASS="Index">PyArray_FromDims 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876179"></A><A HREF="numdoc.html#marker-59756" CLASS="Index">PyArray_FromDimsAndData 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876181"></A><A HREF="numdoc.html#marker-59759" CLASS="Index">PyArray_FromObject 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876183"></A><A HREF="numdoc.html#marker-59745" CLASS="Index">PyArray_INCREF 65</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876185"></A><A HREF="numdoc.html#marker-59752" CLASS="Index">PyArray_ObjectType 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876187"></A><A HREF="numdoc.html#marker-59761" CLASS="Index">PyArray_Reshape 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876189"></A><A HREF="numdoc.html#marker-59760" CLASS="Index">PyArray_Return 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876191"></A><A HREF="numdoc.html#marker-59744" CLASS="Index">PyArray_SetNumericOps 65</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876193"></A><A HREF="numdoc.html#marker-59748" CLASS="Index">PyArray_SetStringFunction 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876195"></A><A HREF="numdoc.html#marker-59754" CLASS="Index">PyArray_Size 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876197"></A><A HREF="numdoc.html#marker-59763" CLASS="Index">PyArray_Take 67</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876199"></A><A HREF="numdoc.html#marker-59746" CLASS="Index">PyArray_XDECREF 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876201"></A><A HREF="numdoc.html#marker-59747" CLASS="Index">PyArrayError 66</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876203"></A><A HREF="numdoc.html#marker-59739" CLASS="Index"></a><A HREF="numdoc.html#marker-59742" CLASS="Index">PyArrayObject 58, 64</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876206"></A><A HREF="numdoc.html#marker-59583" CLASS="Index">PyObject 14</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876208"></A><A HREF="numdoc.html#marker-59768" CLASS="Index">PyUFunc_Check 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876210"></A><A HREF="numdoc.html#marker-59769" CLASS="Index">PyUFunc_FromFuncAndData 70</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876212"></A><A HREF="numdoc.html#marker-59770" CLASS="Index">PyUFunc_GenericFunction 71</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876214"></A>R<A NAME="Q"></A><A NAME="R"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876217"></A><A HREF="numdoc.html#marker-303107" CLASS="Index">randint() 82</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876219"></A><A HREF="numdoc.html#marker-303101" CLASS="Index">random() 82</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876221"></A><A HREF="numdoc.html#marker-303092" CLASS="Index">RandomArray 82</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876223"></A><A HREF="numdoc.html#marker-59542" CLASS="Index"></a><A HREF="numdoc.html#marker-59798" CLASS="Index">rank 12, 73</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876226"></A><A HREF="numdoc.html#marker-59485" CLASS="Index">ravel 37</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876228"></A><A HREF="numdoc.html#marker-59713" CLASS="Index">real (attribute) 47</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876230"></A><A HREF="numdoc.html#marker-302972" CLASS="Index">real_fft() 77</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876232"></A><A HREF="numdoc.html#marker-59635" CLASS="Index"></a><A HREF="numdoc.html#marker-59666" CLASS="Index">repeat() 36, 42</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876235"></A><A HREF="numdoc.html#marker-59584" CLASS="Index">reshape 15</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876237"></A><A HREF="numdoc.html#marker-59585" CLASS="Index">resize 16</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876239"></A><A HREF="numdoc.html#marker-59660" CLASS="Index">resize() 42</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876241"></A>S<A NAME="S"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876243"></A><A HREF="numdoc.html#marker-303095" CLASS="Index">seed() 82</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876245"></A><A HREF="numdoc.html#marker-59619" CLASS="Index">Setting array values 24</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876247"></A><A HREF="numdoc.html#marker-59799" CLASS="Index">shape 73</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876249"></A><A HREF="numdoc.html#marker-303075" CLASS="Index">singular_value_decomposition() 81</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876251"></A><A HREF="numdoc.html#marker-59620" CLASS="Index">Slicing Arrays 25</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876253"></A><A HREF="numdoc.html#marker-303018" CLASS="Index">solve_linear_equations() 80</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876255"></A><A HREF="numdoc.html#marker-59699" CLASS="Index">sometrue() 44</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876257"></A><A HREF="numdoc.html#marker-66635" CLASS="Index">sort() 38</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876259"></A><A HREF="numdoc.html#marker-68558" CLASS="Index">SourceForge 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876261"></A><A HREF="numdoc.html#marker-59694" CLASS="Index">sum() 44</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876263"></A><A HREF="numdoc.html#marker-59650" CLASS="Index">swapaxes() 41</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876265"></A>T<A NAME="T"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876267"></A><A HREF="numdoc.html#marker-59633" CLASS="Index">take() 34</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876269"></A><A HREF="numdoc.html#marker-59728" CLASS="Index">Textual representations 55</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876271"></A><A HREF="numdoc.html#marker-59533" CLASS="Index">thread 8</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876273"></A><A HREF="numdoc.html#marker-59532" CLASS="Index">Tk 8</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876275"></A><A HREF="numdoc.html#marker-59709" CLASS="Index">tolist() 46</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876277"></A><A HREF="numdoc.html#marker-59708" CLASS="Index">tostring() 45</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876279"></A><A HREF="numdoc.html#marker-59640" CLASS="Index">trace() 38</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876281"></A><A HREF="numdoc.html#marker-59634" CLASS="Index">transpose() 36</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876283"></A><A HREF="numdoc.html#marker-59547" CLASS="Index"></a><A HREF="numdoc.html#marker-59613" CLASS="Index"></a><A HREF="numdoc.html#marker-59791" CLASS="Index">typecode 12, 21, 73</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876287"></A><A HREF="numdoc.html#marker-59706" CLASS="Index">typecode() 45</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876289"></A><A HREF="numdoc.html#marker-59717" CLASS="Index">Typecodes 52</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876291"></A>U<A NAME="U"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876293"></A><A HREF="numdoc.html#marker-59538" CLASS="Index"></a><A HREF="numdoc.html#marker-59792" CLASS="Index">ufunc 9, 73</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876296"></A><A HREF="numdoc.html#marker-59630" CLASS="Index">Ufunc shorthands 31</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876298"></A><A HREF="numdoc.html#marker-59767" CLASS="Index">UfuncObject 68</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876300"></A><A HREF="numdoc.html#marker-59738" CLASS="Index">ufuncobject.h 58</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876302"></A><A HREF="numdoc.html#marker-59621" CLASS="Index">Ufuncs 27</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876304"></A><A HREF="numdoc.html#marker-59625" CLASS="Index">Unary Mathematical Ufuncs 30</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876306"></A><A HREF="numdoc.html#marker-303104" CLASS="Index">uniform() 82</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876308"></A><A HREF="numdoc.html#marker-59793" CLASS="Index">universal function 73</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876310"></A><A HREF="numdoc.html#marker-59539" CLASS="Index">universal functions 9</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876312"></A><A HREF="numdoc.html#marker-59524" CLASS="Index">Unix 6</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876314"></A><A HREF="numdoc.html#marker-59731" CLASS="Index">Unpickling 57</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876316"></A><A HREF="numdoc.html#marker-59549" CLASS="Index">UnsignedInt8 13</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876318"></A><A HREF="numdoc.html#marker-59796" CLASS="Index">UserArray 73</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876320"></A>V<A NAME="V"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876322"></A><A HREF="numdoc.html#marker-59535" CLASS="Index">view 7</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876324"></A>W<A NAME="W"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876326"></A><A HREF="numdoc.html#marker-59637" CLASS="Index"></a><A HREF="numdoc.html#marker-67906" CLASS="Index">where() 37, 43</A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="GroupTitlesIX">
<A NAME="pgfId-876329"></A>Z<A NAME="X"></A><A NAME="Y"></A><A NAME="Z"></A></H6>
<UL>
<LI CLASS="Level1IX">
<A NAME="pgfId-876333"></A><A HREF="numdoc.html#marker-59741" CLASS="Index">Zero-dimensional arrays 60</A></LI>
<LI CLASS="Level1IX">
<A NAME="pgfId-876335"></A><A HREF="numdoc.html#marker-60118" CLASS="Index">zeros() 17</A></LI>
</UL>
</DIV>
</DIV>
</DIV>
<HR>
<DIV CLASS="footnotes">
<DIV CLASS="footnote">
<P CLASS="Footnote">
<SPAN CLASS="footnoteNumber">
1.</SPAN>
<A NAME="pgfId-59080"></A>This limit is modifiable in the source code if higher dimensionality is needed.</P>
</DIV>
<DIV CLASS="footnote">
<P CLASS="Footnote">
<SPAN CLASS="footnoteNumber">
2.</SPAN>
<A NAME="pgfId-59294"></A>The Python syntax can allow other Python datatypes to use both the stride notation and multidimensional indexing, and it is relatively simple to write Python classes which support these operations. See the Python Reference manual for details.</P>
</DIV>
</DIV>
</BODY>
</HTML>
