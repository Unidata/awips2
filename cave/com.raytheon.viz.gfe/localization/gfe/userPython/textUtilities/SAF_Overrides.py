##
# This software was developed and / or modified by Raytheon Company,
# pursuant to Contract DG133W-05-CQ-1067 with the US Government.
# 
# U.S. EXPORT CONTROLLED TECHNICAL DATA
# This software product contains export-restricted data whose
# export/transfer/disclosure is restricted by U.S. law. Dissemination
# to non-U.S. persons whether in the United States or abroad requires
# an export license or other authorization.
# 
# Contractor Name:        Raytheon Company
# Contractor Address:     6825 Pine Street, Suite 340
#                         Mail Stop B8
#                         Omaha, NE 68106
#                         402.291.0100
# 
# See the AWIPS II Master Rights File ("Master Rights File.pdf") for
# further licensing information.
##
# ---------------------------------------------------------------------
# This software is in the public domain, furnished "as is", without
# technical  support, and with no warranty, express or implied, as to
# its usefulness for any purpose.
#
# SOFTWARE HISTORY
#
# Date          Ticket#  Engineer  Description
# ------------- -------- --------- --------------------------------------------
# May 25, 2016  18594    ryu       Fix placing punctuation in the middle of a 
#                                  headline.
# Apr 10, 2018  7255     randerso  Fix missing label on first period. Fix case
#                                  of phrases.
# ----------------------------------------------------------------------------
# SAF_Overrides
#
#  This file provides any product specific overrides for the
#  SAF product.  This file is part of the baseline.
#
# Definition Section:
#   Overrides:
#   Additions:
#
# Methods:
#   Overrides:
#   Additions:
#
# ---------------------------------------------------------------------

##
# This is a base file that is not intended to be overridden.
##

import time, re
import TextRules
import TimeRange, AbsTime

# Define overrides of Product Definition settings and
# default values of additional Definition settings
#  ( This Definition section must be before the Class definition)

#***** THIS NEXT LINE IS REQUIRED *****
Definition = {}
#
# SAF Definitions:
# Definition statements must start in column 1

### SAF settings of baseline options: ###

#Definition['displayName'] = "SAF"
Definition["productName"] = "Zone Forecast Product"  # name of product
Definition["outputFile"] =  "{prddir}/TEXT/SAF.txt"
Definition["extendedLabel"] = 1          # To include extended label
Definition["includeEveningPeriod"] = 0   # To turn off evening period

# lacList - Listening area code(s).
# Must be a list of LACs to create forecasts for multiple towers.
Definition["lacList"] = []

# lacAreaDict - For each defaultEditArea, enter it's associated LAC
Definition["lacAreaDict"] = {}

# pilDict - Dictionary with keys of LAC and values of
# product pil used as CRS ID in the CRS header.

Definition["pilDict"] = {}

############################
# OPTIONAL SET-UP:

# Flag to repeat first period at the end. 1 or 0
Definition["repeat1stPeriod"] = 0

# summaryExtended - flag 0 or 1 to generate a summary extended
# forecast. If 1, you must define summaryAreaDict.
# Also turn off extendedLabel and includeExtended
Definition["summaryExtended"] = 0

# summaryAreaDict - dictionary with keys of the LAC ID
# and values of a tuple of (editAreaName, areaLabel) where
# areaLabel is a label string such as "Western Virginia"
# editAreaName must be the name of a GFE defined edit area
Definition["summaryAreaDict"] = {}

# summaryExtendedIntro is a string to introduce the extended
# such as "The extended forecast for"
Definition["summaryExtendedIntro"] = "The extended forecast for"

# lacFileDict - Dictionary with keys of LAC and values
# of full pathname of where to store the data on disk.
Definition["lacFileDict"] = {}

### New Definitions not in the baseline ###

# END  definitions
############################################################

#**********************************************************************
# MAKE NO CHANGES HERE
# The minimum contents of this file are the above Definition = {} line
# plus following class definition and the __init__ method with only
# the "pass" line in it.

class SAF_Overrides:
    """Class NNN_FILETYPE - Version: IFPS"""

    def __init__(self):
        pass

# End MAKE NO CHANGES HERE
#**********************************************************************
    # Add methods here making sure to indent inside the class statement
    # SAF Overrides ------------------------

    # It is helpful to put a debug statement at the beginning of each
    # method to help with trouble-shooting.
    #def _method(self):
        #self.debug_print("Debug: _method in SAF_Overrides")
           
    def generateForecast(self, argDict):
        """This allows for multiple towers to be generated by the formatter.
        Each tower will be a separate section in the output text.
        The forecast for each tower can be sent to a different PIL in
        the textdb and better yet, written directly to a file in the
        NWR pending or ready directory.
        This requires Definition["lacList"] to be specified as a list.
        """
        self.debug_print("")
        # Generate Text Phrases for a list of edit areas

        # Get variables
        error = self._getVariables(argDict)
        if error is not None:
            return error

        # Get the areaList -- derived from defaultEditAreas and
        # may be solicited at run-time from user if desired
        self._areaList = self.getAreaList(argDict)
        if len(self._areaList) == 0:
            return "WARNING -- No Edit Areas Specified to Generate Product."

        # Determine time ranges
        error = self._determineTimeRanges(argDict)
        if error is not None:
            return error

        # Sample the data
        error = self._sampleData(argDict)
        if error is not None:
            return error

        # Initialize the output string
        fcstDict = self._initializeFcst(argDict)
        
        # Generate the product for each edit area in the list
        fraction = 0
        fractionOne = 1.0/float(len(self._areaList))
        percent = 50.0
        self.setProgressPercentage(50)
        # All edit areas for all transmitters must be in _areaList
        # with each areaLabel prepended with the LAC
        for editArea, areaLabel in self._areaList:
            self.progressMessage(fraction, percent, "Making Product for " + areaLabel)
            areaLac = self._getAreaLac(editArea, areaLabel, fcstDict, argDict)
            fcst = fcstDict[areaLac]
            fcst = self._preProcessArea(fcst, editArea, areaLabel, argDict)
            fcst = self._makeProduct(fcst, editArea, areaLabel, argDict)
            fcst = self._postProcessArea(fcst, editArea, areaLabel, argDict)
            fcstDict[areaLac] = fcst
            fraction = fractionOne
          
        finalFcst = self._getFinalFcst(fcstDict, argDict)
        return finalFcst

    def _getAreaLac(self, editArea, areaLabel, fcstDict, argDict):
        self.debug_print("")
        eaName = editArea.getId().getName()
        if self._multiTower:
            try:
                areaLac = self._lacAreaDict[eaName]
            except:
                msg = "Edit Area Name " + eaName + " " + areaLabel + \
                  " not in lacAreaDict "
                raise ValueError(msg)
        else:
            areaLac = self._lac               
        return areaLac

    def _determineTimeRanges(self, argDict):
        self.debug_print("")
        # Set up the Narrative Definition and initial Time Range  
        self._issuanceInfo = self.getIssuanceInfo(
            self._productIssuance, self._issuance_list(argDict))
        self._timeRange = self._issuanceInfo.timeRange()
        argDict["productTimeRange"] = self._timeRange
        self._expireTime = self._issuanceInfo.expireTime()
        self._issueTime = self._issuanceInfo.issueTime()
        self._definition["narrativeDef"] = self._issuanceInfo.narrativeDef()
        if self._periodCombining:
            self._definition["methodList"] = \
               [self.combineComponentStats, self.assembleChildWords]
        else:
            self._definition["methodList"] = [self.assembleChildWords]

        # Calculate current times
        self._ddhhmmTime = self.getCurrentTime(
            argDict, "%d%H%M", shiftToLocal=0, stripLeading=0)
        self._timeLabel = self.getCurrentTime(
            argDict, "%l%M %p %Z %a %b %e %Y", stripLeading=1)
        expireTimeRange = TimeRange.TimeRange(self._expireTime, self._expireTime + 3600)
        self._expireTimeStr = self.timeDisplay(expireTimeRange, "", "", "%d%H%M", "")

        # This section determines when to start the extended forecast
        # for the summary extended.
        (currentLocalTime, self._shift) = self.determineTimeShift()
        day = currentLocalTime.day
        month = currentLocalTime.month
        year = currentLocalTime.year
        #print "_determineTimeRanges: p1 TR=",self._issuanceInfo.period1TimeRange()
        p1_endtime = self._issuanceInfo.period1TimeRange().endTime()

        # If the first period ends at the same time as self.NIGHT(), then
        # the product starts with a daytime issuance, otherwise a nighttime
        # issuance and the extended will start 24 hrs later
        nightTime = AbsTime.absTimeYMD(year,month,day,self.NIGHT()) - self._shift
        dayTime = AbsTime.absTimeYMD(year,month,day,self.DAY()) - self._shift
        #print "_determineTimeRanges: p1, day, night=",p1_endtime,dayTime,nightTime
        # Offset is hours from self.DAY()
        if p1_endtime == nightTime:
            # Daytime run - today, tonight, day2, night2
            offset = 48
        elif p1_endtime == dayTime:
            # PM run after midnight- rest of night, today, tonight, day2, night2
            offset = 48
        else:
            # Normal pm run - tonight, day1, night1, day2, night2
            offset = 72

        # Determine "issuanceHour"
        startTime = AbsTime.absTimeYMD(year,month,day,self.DAY())
        # Convert to GMT time before making time range
        startTime = startTime - self._shift + offset*3600
        #print "_determineTimeRanges: p1 TR=",self._issuanceInfo.period1TimeRange()
        self._extendedTimeRange = TimeRange.TimeRange(startTime, startTime + 3600)
        #print "_determineTimeRanges: extended TR=",self._extendedTimeRange

        return None

    def _initializeFcst(self, argDict):
        self.debug_print("")
        # For backward compatibility, if there are Definition entries
        # of "lac" and "pil", use them instead of lacList and pilList
        try:
            self._lacList = [self._lac]
            self._pilDict = {self._lac:self._pil}
            self._multiTower = 0
        except:
            self._multiTower = 1
            
        fcstDict = {}   
        for lac in self._lacList:
            fcst = ""
            # Make sure there is a crsID for each LAC
            if lac in self._pilDict:
                self._currentPil = self._pilDict[lac]
                self._currentLac = lac
                fcstDict[lac] = self._preProcessProduct(fcst, argDict)
            else:
                msg = "Setup Error!  Definition['pilDict']" + \
                    " has no entry for LAC ID=" + lac
                raise ValueError(msg)
        return fcstDict

    def _preProcessProduct(self, fcst, argDict):
        self.debug_print("")
        # SAF Heading:
        # aT_ENGOKCZFPLTS03053014120305301412        CD   OKZ036c0305310612
        language = argDict["language"]
        if language == "english":
            languageStr = "T_ENG"
        elif language == "spanish":
            languageStr = "T_SPA"
        elif language == "french":
            languageStr = "T_FRE"
        issueTimeStr = self.formatTimeString(
            self._issueTime.unixTime(), "%y%m%d%H%M", "GMT")
        expireTimeStr = self.formatTimeString(
            self._expireTime.unixTime(),"%y%m%d%H%M", "GMT")
        fcst = fcst + languageStr
        fcst = fcst + self._currentPil
        fcst = fcst + issueTimeStr + issueTimeStr
        fcst = fcst + "        CD   "
        fcst = fcst + self._currentLac
        fcst = fcst + expireTimeStr + "\n\n"
       
        # Get Synopsis from previous forecast
        #productID = "PDXCWFPQR"
        #synopsis = self.getPreviousProduct(productID, "SYNOPSIS")
        #SynopsisHeading = ".SYNOPSIS FOR SOUTHERN WASHINGTON AND NORTHERN OREGON COAST..."
        #synopsis = re.sub(r'\n', r' ', synopsis)
        #synopsis = self.endline(synopsis, linelength=self._lineLength)
        #fcst = fcst + "-\n" + SynopsisHeading + "\n" + synopsis + "\n$$\n\n"
        return fcst

    def _preProcessArea(self, fcst, editArea, areaLabel, argDict):
        self.debug_print("")
        # This is the header for an edit area combination
        #ERH fcst=fcst+"$$\nNow for the official National "
        fcst=fcst+"Now for the official National "
        fcst=fcst+"Weather Service forecast\nfor "+areaLabel+"\n\n"
        if self.allowedHazards() != []:
            self._hazards = argDict['hazards']
            self._combinations = argDict["combinations"]
            headlines = self.generateProduct("Hazards", argDict,
                                        area = editArea, areaLabel=areaLabel,
                                        timeRange = self._timeRange)
            if headlines != "":
                # Replace ellipsis at end of each headline with period
                headlines = headlines.replace("...\n", ".\n")

                # Remove other ellipses
                headlines = headlines.replace("...", "")

                # Remove multiple trailing new lines and replace
                # with a single one
                headlines = headlines.strip() + "\n"

                fcst = fcst + headlines + "\n"       
        return fcst
    
    def _postProcessArea(self, fcst, editArea, areaLabel, argDict):
        """Save first period text for repeating at the end of the SAF. """
        self.debug_print("")
        if self._repeat1stPeriod == 1:
            # Clean up the area label to avoid possibly
            # repeat "forecast for"
            e=re.compile('.*forecast for',re.IGNORECASE)
            intro = "Again, the forecast for " + \
                    e.sub("",areaLabel).strip()
            # Now strip off any punctuation on the area label
            # and add the period label, ie, today, tonight
            intro=intro.rstrip(",.") + " for " + \
                   self._1stPeriodLabel + ", "
            # Wrap it up!
            text = self.endline(intro + self._1stPeriodFcst)
            fcst = fcst + "\n" + text
        return fcst + "\n"
    
    def _postProcessProduct(self, fcst, argDict):
        self.debug_print("")
        if self._summaryExtended == 1:
            fcst = fcst + self._getSummaryExtended(argDict)

        fcst = fcst.replace("%expireTime", self._expireTimeStr)
        self.setProgressPercentage(100)
        self.progressMessage(0, 100, self._displayName + " Complete")
        
        fcst = fcst.replace("...", ", ")
        #This is to get rid of leading "." at the start of a fcst period.
        fcst = fcst.replace("\n.", "\n")
        #Get rid of $$
        fcst = fcst.replace("$$\n", "")

        escA="" + "a"
        escB="" + "b"
        fcst = escA + fcst + "\n" + escB
       
        #Now uncapitalize special characters
        fcst = self._lower_special_chars(fcst)
        return fcst

    def _getFinalFcst(self, fcstDict, argDict):
        self.debug_print("")
        # Assemble the entries from fcstDict into a fcst string
        finalFcst = ""
        for lac in self._lacList:
            fcst = fcstDict[lac]
            self._currentLac = lac
            fcst = self._postProcessProduct(fcst, argDict)
            finalFcst = finalFcst + fcst + "\n\n"
            # Write tower specific text to disk. Normally
            # this will be the /data/fxa/workFiles/nwr/pending
            # directory. Must be full pathname!
            if lac in self._lacFileDict:
                f=open(self._lacFileDict[lac],"w")
                f.write(fcst)
                f.close()
        return finalFcst
    
    def setLabel(self, tree, component):
        exLabel= "\n\nAnd now the extended forecast for the radio listening area.\n"
        component.set("words", exLabel)
        return self.DONE()

    def createLabel(self, tree, node, timeRange, issuanceInfo, currentLocalTime, shift, index=0):
        # Make a label given the timeRange in GMT and the shift to
        # convert it to local time. currentLocalTime can be used to
        # compare to current day.

        if timeRange.duration() < 3600:
                return ""
        if index == 0:
            try:
                label =  issuanceInfo.period1Label()
                if label != "":
                    return label
            except:
                pass
        try:
            today =  issuanceInfo.todayFlag()
        except:
            today = 1
        try:
            useHolidays = self._useHolidays
        except:
            useHolidays = 1
        nextDay24HourLabel = self.nextDay24HourLabel_flag(tree, node)
        splitDay24HourLabel = self.splitDay24HourLabel_flag(tree, node)
        label =  self.getWeekday(timeRange, holidays=1, shiftToLocal=1,
                                labelType="CapitalWithComma", today=today,
                                tomorrow=0, nextDay24HourLabel=nextDay24HourLabel,
                                splitDay24HourLabel=splitDay24HourLabel)       
        return label

    def Labels(self):
        labels = TextRules.TextRules.Labels(self)
        labels["CapitalWithComma"] = {
                "PrePunctuation": "",
                "PostPunctuation": ", ",
                "Weekday" : {
                    6 : "Sunday",
                    0 : "Monday",
                    1 : "Tuesday",
                    2 : "Wednesday",
                    3 : "Thursday",
                    4 : "Friday",
                    5 : "Saturday"
                },
                "Now": "Now",
                "Today":"Today",
                "Tonight": "Tonight",
                "Rest of Today":"Rest of Today",
                "Rest of Tonight": "Rest of Tonight",
                "Night": "Night",
                "Evening": "Evening",
                "Afternoon": "This Afternoon",
            }
        return labels
    
    def _issuance_list(self, argDict):
        """This shows how to add customized issuance lists via Definition
        settings. Supply the name of a different issuance_list method
        in Definition["directiveType"]. There must be a method with
        the name supplied or else the formatter will bomb out."""
        self.debug_print("")
        #  This method sets up configurable issuance times with associated
        #  narrative definitions.  See the Text Product User Guide for documentation.
        if self._definition["directiveType"] == "C11":
            return self._C11_issuance_list(argDict)
        elif self._definition["directiveType"] == "10-503":
            return self._10_503_issuance_list(argDict)
        else:
            # Warning! if self._definition["directiveType"] is not
            # a defined method, the formatter will error out.
            meth = getattr(self, self._definition["directiveType"])
            return meth(argDict)

    def _C11_issuance_list(self, argDict):
        try:
            if self._definition["includeEveningPeriod"] == 1:
                narrativeDefAM = [
                    ("FirstFcstPeriod", "period1"),
                    ("AreaFcstPeriod", 12), ("AreaFcstPeriod", 12),
                    ("LaterPeriod", 12), ("LaterPeriod", 12),
                    ("Evening", 6),
                    ]
                narrativeDefPM = [
                    ("FirstFcstPeriod", "period1"),
                    ("AreaFcstPeriod", 12), ("AreaFcstPeriod", 12),
                    ("LaterPeriod", 12), ("LaterPeriod", 12), ("LaterPeriod", 12),
                    ("Evening", 6),
                    ]
            else:
                narrativeDefAM = [
                    ("FirstFcstPeriod", "period1"),
                    ("AreaFcstPeriod", 12), ("AreaFcstPeriod", 12),
                    ("LaterPeriod", 12), ("LaterPeriodWithoutLows", 18),
                    ]           
                narrativeDefPM = [
                    ("FirstFcstPeriod", "period1"),
                    ("AreaFcstPeriod", 12), ("AreaFcstPeriod", 12),
                    ("LaterPeriod", 12), ("LaterPeriod", 12), ("LaterPeriodWithoutLows", 18),
                    ]
            extended = [("C11Extended", 24),("C11Extended", 24), ("C11Extended", 24),("C11Extended", 24)]
            if self._includeExtended == 1:
                if self._extendedLabel == 1:
                    narrativeDefAM.append(("ExtendedLabel",0))
                    narrativeDefPM.append(("ExtendedLabel",0))
                narrativeDefAM = narrativeDefAM + extended
                narrativeDefPM = narrativeDefPM + extended
        except:
            narrativeDefAM = None
            narrativeDefPM = None           
           
        try:
            if self._numPeriods != "All":
                numPeriods = int(self._numPeriods)
                narrativeDefAM = narrativeDefAM[0:numPeriods]
                narrativeDefPM = narrativeDefPM[0:numPeriods]
        except:
            pass

        narrativeDefAM.append(("Custom", ("ExtraSampling", (-24, 12))))
        narrativeDefPM.append(("Custom", ("ExtraSampling", (-24, 24))))

        #(description, startHour, endHour, period1 label, period1 lateNight lateDay phrase, todayFlag, series definition)
        return [
            ("Morning", self.DAY(), self.NIGHT(), self.NIGHT(),
             "Today, ", "early in the morning", "late in the afternoon",
             1, narrativeDefAM),
            ("Morning with Pre-1st Period", self.DAY()-2, self.NIGHT(), self.NIGHT(),
             "Today, ", "early in the morning", "late in the afternoon",
             1, narrativeDefAM),
            ("Morning Update", "issuanceHour", self.NIGHT(), self.NIGHT(),
             "Rest of Today, ", "early in the morning", "late in the afternoon",
             1, narrativeDefAM),
            ("Afternoon Update", "issuanceHour", self.NIGHT(), self.NIGHT(),
             "Rest of Today, ", "early in the morning","late in the afternoon",
             1, narrativeDefAM),
            #  End times are tomorrow:
            ("Afternoon", self.NIGHT(), 24 + self.DAY(), 24 + self.DAY(),
             "Tonight, ", "late in the night", "early in the evening",
             1, narrativeDefPM),
            ("Afternoon with Pre-1st Period", self.NIGHT()-2, 24 + self.DAY(), 24 + self.DAY(),
             "Tonight, ", "late in the night", "early in the evening",
             1, narrativeDefPM),
            ("Evening Update", "issuanceHour", 24 + self.DAY(), 24 + self.DAY(),
             "Rest of Tonight, ", "late in the night","early in the evening",
             1, narrativeDefPM),
            ("Early Morning Update", "issuanceHour", self.DAY(), self.DAY(),
             "Rest of Tonight, ", "early in the morning","late in the afternoon",
             0, narrativeDefPM),
            ]
   
    def _10_503_issuance_list(self, argDict):
        narrativeDefAM = [
            ("Period_1", "period1"),           
            ("Period_2_3", 12), ("Period_2_3", 12),
            ("Period_4_5", 12), ("Period_4_5", 12),
            ("Period_6_14", 12), ("Period_6_14", 12), ("Period_6_14", 12), ("Period_6_14", 12),
            ("Period_6_14", 12), ("Period_6_14", 12), ("Period_6_14", 12), ("Period_6_14", 12),
            ]
        narrativeDefPM = [
            ("Period_1", "period1"),
            ("Period_2_3", 12), ("Period_2_3", 12),
            ("Period_4_5", 12), ("Period_4_5", 12),
            ("Period_6_14", 12), ("Period_6_14", 12), ("Period_6_14", 12), ("Period_6_14", 12),
            ("Period_6_14", 12), ("Period_6_14", 12), ("Period_6_14", 12), ("Period_6_14", 12),
            ("Period_6_14", 12),
            ]
        try:
            if self._numPeriods != "All":
                numPeriods = int(self._numPeriods)
                narrativeDefAM = narrativeDefAM[0:numPeriods]
                narrativeDefPM = narrativeDefPM[0:numPeriods]
        except:
            pass
       
        narrativeDefAM.append(("Custom", ("ExtraSampling", (-24, 12))))
        narrativeDefPM.append(("Custom", ("ExtraSampling", (-24, 24))))

        return [
            ("Morning", self.DAY(), self.NIGHT(), self.NIGHT(),
             "Today, ", "early in the morning", "late in the afternoon",
             1, narrativeDefAM),
            ("Morning with Pre-1st Period", self.DAY()-2, self.NIGHT(), self.NIGHT(),
             "Today, ", "early in the morning", "late in the afternoon",
             1, narrativeDefAM),
            ("Morning Update", "issuanceHour", self.NIGHT(), self.NIGHT(),
             "Rest of Today, ", "early in the morning", "late in the afternoon",
             1, narrativeDefAM),
            ("Afternoon Update", "issuanceHour", self.NIGHT(), self.NIGHT(),
             "Rest of Today, ", "early in the morning","late in the afternoon",
             1, narrativeDefAM),
            #  End times are tomorrow:
            ("Afternoon", self.NIGHT(), 24 + self.DAY(), 24 + self.DAY(),
             "Tonight, ", "late in the night", "early in the evening",
             1, narrativeDefPM),
            ("Afternoon with Pre-1st Period", self.NIGHT()-2, 24 + self.DAY(), 24 + self.DAY(),
             "Tonight, ", "late in the night", "early in the evening",
             1, narrativeDefPM),
            ("Evening Update", "issuanceHour", 24 + self.DAY(), 24 + self.DAY(),
             "Rest of Tonight, ", "early in the morning","early in the evening",
             1, narrativeDefPM),
            # For the early morning update, this produces:
            # Rest of Tonight:
            # MONDAY
            # MONDAY NIGHT
            ("Early Morning Update", "issuanceHour", self.DAY(), self.DAY(),
             "Rest of Tonight, ", "early in the morning","late in the afternoon",
             0, narrativeDefPM),
            ]

    def range_threshold_dict(self, statDict, argDict):
        # Range for reporting temperature ranges in temp_range_phrase
        #   e.g HIGHS 80 TO 85
        return {
            "MaxT": 10,
            "MinT": 10,
            }

    def timePeriod_descriptor_list(self, tree, node):
        """SAFmulti_ER_Overrides version of timeDescriptor.timePeriod_descriptor_list.

        Added descriptors for 12 hour periods."""
        self.debug_print("")

        # Based on code from Dave Zaff
       
        # Contains definition for localtime start/end times and phrase
        # Tuples, 0=startHrLT, 1=endHrLT, 2=phrase
        day = self.DAY()
        return [
                (day, (day+3)%24, "early in the morning"),    # 6a-9a
                (day, (day+6)%24, "in the morning"),          # 6a-noon
                (day, (day+9)%24, "until late afternoon"),    # 6a-3p
                (day, (day+12)%24, "during the day"),         # 6a-6p
                #(day, (day+15)%24, "until early evening"),    # 6a-9p
                (day, (day+15)%24, "until evening"),          # 6a-9p
                (day, (day+18)%24, "through the evening"),    # 6a-midnite

                ((day+3)%24, (day+6)%24, "late in the morning"), # 9a-noon
                ((day+3)%24, (day+9)%24, "in the late morning and early afternoon"), # 9a-3p
                ((day+3)%24, (day+12)%24, "in the late morning and afternoon"),      # 9a-6p
                #((day+3)%24, (day+15)%24, "until early evening"),      # 9a-9p
                ((day+3)%24, (day+15)%24, "until evening"),            # 9a-9p
                ((day+3)%24, (day+18)%24, "through the evening"),      # 9a-midnite

                ((day+6)%24, (day+9)%24,  "early in the afternoon"),      # noon-3p
                ((day+6)%24, (day+12)%24, "in the afternoon"),            # noon-6p
                ((day+6)%24, (day+15)%24, "in the afternoon and evening"),# noon-9p
                ((day+6)%24, (day+18)%24, "in the afternoon and evening"),# noon-midnite

                ((day+9)%24, (day+12)%24, self.lateDay_descriptor),   # 3p-6p
                #((day+9)%24, (day+15)%24, "early in the evening"),    # 3p-9p
                ((day+9)%24, (day+15)%24, "in the evening"),          # 3p-9p
                #((day+9)%24, (day+18)%24, "in the evening"),          # 3p-midnite
                ((day+9)%24, (day+18)%24, "until midnight"),          # 3p-midnite
                ((day+9)%24, (day+21)%24, "this evening and overnight"),     # 3p-3a
                ((day+9)%24,  day, ""),                               # 3p-6a

                ((day+12)%24, (day+15)%24, "early in the evening"),   # 6p-9p
                #((day+12)%24, (day+18)%24, "in the evening"),         # 6p-midnite
                ((day+12)%24, (day+18)%24, "until midnight"),         # 6p-midnite
                ((day+12)%24, (day+21)%24, "this evening and overnight"),    # 6p-3a
                ((day+12)%24, day, "overnight"),                               # 6p-6a

                #((day+15)%24, (day+18)%24, "late in the evening"),                  # 9p-midnite
                ((day+15)%24, (day+18)%24, "until midnight"),                       # 9p-midnite

                #((day+15)%24, (day+21)%24, "in the late evening and early morning"),# 9p-3a
                ((day+15)%24, (day+21)%24, "overnight"),                            # 9p-3a
                #((day+15)%24, day, "in the late evening and overnight"),            # 9p-6a
                ((day+15)%24, day, "overnight"),                                    # 9p-6a

                ((day+18)%24, (day+21)%24, "after midnight"),               # midnite-3a
                ((day+18)%24, day, "after midnight"),                       # midnite-6a
                ((day+18)%24, (day+6)%24, ""),                              # midnite-noon

                ((day+21)%24, day, self.lateNight_descriptor),              # 3a-6a
                ((day+21)%24, (day+3)%24, "early in the morning"),          # 3a-9a
                ((day+21)%24, (day+6)%24, "early in the morning"),          # 3a-noon
                ((day+21)%24, (day+9)%24, "until afternoon"),               # 3a-3p
                ((day+21)%24, (day+12)%24, ""),                             # 3a-6p
                ]
            
    def assemblePhrases(self, tree, component):
        # Assemble component phrases and add Label
        # Qualify the phrases with local effect qualifiers
        #  if present.
        #   e.g. "near the coast"
        """Override to save first period text for repeating at the end
        of the SAF. From Steve Nelson. Coordinated with change to
        _postProcessArea. """
        self.debug_print("")
        phrases = []
        for phrase in component.get("childList"):
            words = phrase.get("words")
            if words is None:
                return
            if words != "":
                phrases.append(phrase)
        # Remove empty word phrases
        component.childList = phrases
        self.orderWxPhrases(tree, component)
        self.consolidateLocalEffectPhrases(tree, component)
        fcst = ""
        lastQualifier = None
        lastPhrase = None
        phraseList = []
        for phrase in component.get("childList"):
            words = phrase.get("words")
            if words is None:
                return
            words, lastQualifier = self.qualifyWords(
                phrase, words, "conjunctiveQualifier", lastQualifier, lastPhrase)
            lastPhrase = phrase
            if words not in phraseList:
                phraseList.append(words)
                fcst = fcst + words
        # Add label
        curLocalTime, shift = self.determineTimeShift()
        issuanceInfo = tree.get("issuanceInfo")
        index = component.getIndex()
        label = self.createLabel(tree, component, component.get("timeRange"),
                                issuanceInfo, curLocalTime, shift, index)
        fcst = self.combineSentences(fcst)
        if fcst:
            fcst = fcst[0].lower() + fcst[1:]

        # From Steve Nelson
        if index == 0:
            self._1stPeriodLabel = label.strip()
            # Strip off any leading dots...
            self._1stPeriodLabel = self._1stPeriodLabel.lstrip(".").lower()

            if self._1stPeriodLabel[0:4] == "rest":
                self._1stPeriodLabel = "the " + self._1stPeriodLabel
            #Now strip off any trailing punctuation on the label
            self._1stPeriodLabel = self._1stPeriodLabel.rstrip(",.")
            self._1stPeriodFcst = fcst
        # end
        return self.setWords(component, label + fcst)

    def _five12hr_24hrExtended_issuance_list(self, argDict):
        """This specifies a product with 5 (4 for AM) 12hr periods followed
        by five 24 hr periods for an extended forecast.  Requires
        new methods _a24hr_Period and _a24hr_Period_WithoutLows
        to define the extended periods. self._numPeriods is used to limit
        the number of 12 hr periods actually produced as in SAF_Overrides.
        """
        self.debug_print("")
        # Based on code from Dave Zaff

        # dz 031010 - from Brian Walawender
        # Code below sets the start time for the afternoon update
        # Local noon or the current hour (whichever is greater)

        currentTime = time.time()
        updateHour = self.DAY() + 6
        minute = time.strftime("%M", time.localtime(currentTime))
        minute = int(minute)
        if minute < 15:
            currentHour = time.strftime("%H", time.localtime(currentTime))
        else:
            seconds = currentTime
            seconds = seconds + 3600
            currentHour = time.strftime("%H", time.localtime(seconds))

        currentHour = int(currentHour)
        updateHour = int(updateHour)

        if currentHour > updateHour:
            updateHour = currentHour


        narrativeDefAM = [
            ("Period_1", "period1"),           
            ("Period_2_3", 12), ("Period_2_3", 12),
            ("Period_4_5", 12),
            ]
        narrativeDefPM = [
            ("Period_1", "period1"),
            ("Period_2_3", 12), ("Period_2_3", 12),
            ("Period_4_5", 12), ("Period_4_5", 12),
            ]
        # Set the extended to use 24 hour periods starting at 6 am.
        narrativeExtended=[
            ("_a24hr_Period_WithoutLows", 24), ("_a24hr_Period", 24),
            ("_a24hr_Period", 24), ("_a24hr_Period", 24),("_a24hr_Period", 24),
            ]
        try:
            if self._includeExtended == 1:
                if self._extendedLabel == 1:
                    narrativeDefAM.append(("ExtendedLabel",0))
                    narrativeDefPM.append(("ExtendedLabel",0))
                narrativeDefAM = narrativeDefAM + narrativeExtended
                narrativeDefPM = narrativeDefPM + narrativeExtended
        except:
            pass

        try:
            if self._numPeriods != "All":
                numPeriods = int(self._numPeriods)
                narrativeDefAM = narrativeDefAM[0:numPeriods]
                narrativeDefPM = narrativeDefPM[0:numPeriods]
        except:
            pass
        return [
            ("TODAY - beginning at 6AM", self.DAY(), self.NIGHT(), self.NIGHT(),
             ".Today...", "early in the morning", "late in the afternoon",
             1, narrativeDefAM),
            ("Early this morning/today - beginning at 4AM", self.DAY()-2, self.NIGHT(), self.NIGHT(),
             ".Today...", "early in the morning", "late in the afternoon",
             1, narrativeDefAM),
            ("Rest of Today - beginning now", "issuanceHour", self.NIGHT(), self.NIGHT(),
             ".Rest of Today...", "early in the morning", "late in the afternoon",
             1, narrativeDefAM),
            ("Afternoon Update - beginning at noon/afternoon", updateHour, self.NIGHT(), self.NIGHT(),
             ".This Afternoon...", "early in the afternoon","late in the afternoon",
             1, narrativeDefAM),
            #  End times are tomorrow:
            ("TONIGHT - beginning at 6PM", self.NIGHT(), 24 + self.DAY(), 24 + self.DAY(),
             ".Tonight...", "late in the night", "early in the evening",
             1, narrativeDefPM),
            ("Rest of tonight - beginning now", "issuanceHour", 24 + self.DAY(), 24 + self.DAY(),
             ".Rest of Tonight...", "early in the morning","early in the evening",
             1, narrativeDefPM),
            # For the early morning update, this produces:
            # Rest of Tonight:
            # MONDAY
            # MONDAY NIGHT
            ("Rest of tonight - use after midnight", "issuanceHour", self.DAY(), self.DAY(),
             ".Rest of Tonight...", "early in the morning","late in the afternoon",
             0, narrativeDefPM),
            # Alternative
            # For the early morning update, this produces:
            # Early this morning:
            # Today
            # Tonight
            #("Evening Update", "issuanceHour", 24 + self.DAY(), 24 + self.DAY(),
            # ".Rest of Tonight...", "late in the night", "early in the evening",
            # 1, narrativeDefPM),
            #("Early Morning Update", "issuanceHour", self.DAY(), self.DAY(),
            # ".Early this morning...", "early in the morning", "late in the afternoon",
            # 1, narrativeDefPM),
            ]
    
    def _a24hr_Period(self):
        """Defines a 24 hr long component for the extended forecast."""
        self.debug_print("")
        # Based on code from Dave Zaff

        HrSky=12
        HrPoP=12
        HrWind=12
        HrWx=12
       
        component =  {
            "type": "component",
            "methodList": [
                          self.assemblePhrases, 
                          self.wordWrap,        
                          ],
            "analysisList": [
                       ("MinT", self.stdDevFirstAvg),
                       ("MaxT", self.stdDevAvg),
                       ("T", self.hourlyTemp),
                       ("T", self.minMax),
                       ("Sky", self.median, [HrSky]),
                       ("PoP", self._PoP_analysisMethod("_a24hr_Period"),[HrPoP]),
                       ("PoP", self.binnedPercent, [HrPoP]),
                       ("Wind", self.vectorMedianRange, [HrWind]),
                       ("WindGust", self.moderatedMax, [HrWind]),
                       #("SnowAmt", self.minMax),
                       ("Wx", self.rankedWx, [HrWx]),
                       #("WindChill", self.minMax),
                       #("HeatIndex", self.minMax),
                      ],
            "phraseList":[
                   self.wind_summary,
                   self.reportTrends,
                   self.sky_phrase,
                   self.skyPopWx_phrase,
                   self.weather_phrase,
                   #self.severeWeather_phrase,
                   #self.descriptive_snow_phrase,
                   self.highs_phrase,
                   self.lows_phrase,
                   self.steady_temp_trends,
                   #self.highs_range_phrase,
                   #self.lows_range_phrase,
                   self.temp_trends,
                   self.popMax_phrase,
                   #self.windChill_phrase,
                   #self.heatIndex_phrase,
                  ],
            }
        if self._arealSkyAnalysis:
            component["analysisList"].append(("Sky", self.binnedPercent, [HrSky]))
        return component
    
    def _a24hr_Period_WithoutLows(self):
        """This should be the same as _a24hr_Period except no lows phrase in
        the phraseList."""
        self.debug_print("")
        # Based on code from Dave Zaff

        HrSky=12
        HrPoP=12
        HrWind=12
        HrWx=12

        component =  {
            "type": "component",
            "methodList": [
                          self.assemblePhrases, 
                          self.wordWrap,        
                          ],
            "analysisList": [
                       ("MinT", self.stdDevFirstAvg),
                       ("MaxT", self.stdDevAvg),
                       ("T", self.hourlyTemp),
                       ("T", self.minMax),
                       ("Sky", self.median, [HrSky]),
                       ("PoP", self._PoP_analysisMethod("_a24hr_Period"),[HrPoP]),
                       ("PoP", self.binnedPercent, [HrPoP]),
                       ("Wind", self.vectorMedianRange, [HrWind]),
                       ("WindGust", self.moderatedMax, [HrWind]),
                       #("SnowAmt", self.minMax),
                       ("Wx", self.rankedWx, [HrWx]),
                       #("WindChill", self.minMax),
                       #("HeatIndex", self.minMax),
                      ],
            "phraseList":[
                   self.wind_summary,
                   self.reportTrends,
                   self.sky_phrase,
                   self.skyPopWx_phrase,
                   self.weather_phrase,
                   #self.severeWeather_phrase,
                   #self.descriptive_snow_phrase,
                   self.highs_phrase,
                   self.steady_temp_trends,
                   #self.highs_range_phrase,
                   self.temp_trends,
                   self.popMax_phrase,
                   #self.windChill_phrase,
                   #self.heatIndex_phrase,
                  ],
            }
        if self._arealSkyAnalysis:
            component["analysisList"].append(("Sky", self.binnedPercent, [6]))
        return component
    
    def _ExtendedNarrative(self):
        """This defines a component product for a summary extended forecast
        which uses a different edit area from the short term forecasts.
        This is so there can be several areas for the short term forecasts
        for a tower, and just one summary extended forecast for the entire
        listening area. """
        self.debug_print("")

        # check for period combining first
        # Set the extended to use 24 hour periods.
        narrativeExtended=[
            ("_a24hr_Period_WithoutLows", 24), ("_a24hr_Period", 24),
            ("_a24hr_Period", 24), ("_a24hr_Period", 24),("_a24hr_Period", 24),
            ]
        if self._periodCombining:
            methodList = [self.combineComponentStats, self.assembleChildWords]
        else:
            methodList = [self.assembleChildWords]

        return {
          "type": "narrative",
          "displayName": None,
          "timePeriodMethod ": self.timeRangeLabel,
         ## Components
          "methodList": methodList,
          "narrativeDef": narrativeExtended,
          }
    
    def _lower_special_chars(self, fcst):
        """Replaces special characters that need to be lower case."""
        self.debug_print("")
       
        escB="" + "b"
        escA="" + "a"
        # Make sure escape sequences are not capitalized
        fcst = fcst.replace("" +"A", escA)
        fcst = fcst.replace("" + "B", escB)
        # Also there may be a special char in the lac
        lacupper = self._currentLac.upper()
        fcst = fcst.replace(lacupper, self._currentLac)
               
        return fcst
    
    def _getSummaryExtended(self, argDict):
        """Creates a component product summary extended forecast."""
        self.debug_print("")

        # _summaryAreaDict is a dictionary with keys of the LAC ID
        # and values a tuple of (editAreaName, areaLabel)
        # _summaryExtendedIntro is a string to indroduce the extended
        # such as "The extended forecast for"
        # areaLabel is a label string such as "Western Virginia"
        # editAreaName must be the name of a GFE defined edit area
        fcst = ""
        if self._currentLac in self._summaryAreaDict:
            editAreaName, areaLabel = self._summaryAreaDict[self._currentLac]
            intro = self._summaryExtendedIntro
            intro = intro + " " + areaLabel
            # Note endline appends a newline
            intro = self.endline(intro)
            extended = self.generateProduct("_ExtendedNarrative", argDict,
                    area = editAreaName, timeRange=self._extendedTimeRange)
            fcst = intro + extended

        return fcst

    def allowedHazards(self):
        return []
