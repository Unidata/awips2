/**
 * This software was developed and / or modified by Raytheon Company,
 * pursuant to Contract DG133W-05-CQ-1067 with the US Government.
 *
 * U.S. EXPORT CONTROLLED TECHNICAL DATA
 * This software product contains export-restricted data whose
 * export/transfer/disclosure is restricted by U.S. law. Dissemination
 * to non-U.S. persons whether in the United States or abroad requires
 * an export license or other authorization.
 *
 * Contractor Name:        Raytheon Company
 * Contractor Address:     6825 Pine Street, Suite 340
 *                         Mail Stop B8
 *                         Omaha, NE 68106
 *                         402.291.0100
 *
 * See the AWIPS II Master Rights File ("Master Rights File.pdf") for
 * further licensing information.
 **/
package com.raytheon.viz.volumebrowser.vbui;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.jobs.IJobChangeEvent;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.core.runtime.jobs.JobChangeAdapter;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.ControlAdapter;
import org.eclipse.swt.events.ControlEvent;
import org.eclipse.swt.events.DisposeEvent;
import org.eclipse.swt.events.DisposeListener;
import org.eclipse.swt.events.MouseAdapter;
import org.eclipse.swt.events.MouseEvent;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.graphics.Rectangle;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Menu;
import org.eclipse.swt.widgets.MenuItem;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.TableColumn;
import org.eclipse.swt.widgets.TableItem;

import com.raytheon.uf.common.dataplugin.PluginDataObject;
import com.raytheon.uf.common.dataquery.requests.RequestConstraint;
import com.raytheon.uf.common.menus.vb.ViewMenu;
import com.raytheon.uf.viz.core.VizApp;
import com.raytheon.uf.viz.core.rsc.DisplayType;
import com.raytheon.uf.viz.core.rsc.ResourceType;
import com.raytheon.viz.ui.dialogs.ICloseCallback;
import com.raytheon.viz.volumebrowser.datacatalog.DataCatalogManager;
import com.raytheon.viz.volumebrowser.datacatalog.IDataCatalog;
import com.raytheon.viz.volumebrowser.datacatalog.IDataCatalogEntry;
import com.raytheon.viz.volumebrowser.loader.ProductCreator;
import com.raytheon.viz.volumebrowser.loader.ProductCreatorManager;
import com.raytheon.viz.volumebrowser.loader.ProductLoader;

/**
 *
 * This class manages the Product Table that will be loaded onto the display.
 *
 * <pre>
 *
 * SOFTWARE HISTORY
 * Date          Ticket#  Engineer  Description
 * ------------- -------- --------- --------------------------
 * Jun 08, 2009  2161     lvenable  Initial creation
 * Mar 27, 2012  14506    qlin      For cross section plot along a line of
 *                                  latitude, swap xStart and xEnd.
 * Jan 16, 2013  1492     rferrel   Changes for non-blocking InventoryDlg.
 * Jan 25, 2013  15529    kshresth  Fixed cross section "Unhandled event loop
 *                                  exception"  when loading contours and Image
 *                                  combo
 * Aug 20, 2013  2259     bsteffen  Delete old skewt plugin.
 * Feb 12, 2015  4105     rferrel   Remove duplicate update of table item in
 *                                  addProduct.
 * Aug 03, 2015  3861     bsteffen  Move product loading to ProductLoader
 * Jan 12, 2016  5055     randerso  Moved resize listener into this class.
 *                                  Set column widths at creation
 * Apr 02, 2018  6765     bsteffen  Preserve order of products
 * Apr 10, 2018  6577     dgilling  Highlight items in product selection list
 *                                  on middle-click.
 *
 * </pre>
 *
 * @author lvenable
 */
public class ProductTableComp extends Composite {

    /**
     * Set the number of columns in the table.
     */
    private static final int prodSelTableColumnCount = 3;

    /**
     * Width of the "Times" table column.
     */
    private static final int timesColWidth = 100;

    /**
     * Width of the "Inventory" column.
     */
    private static final int inventoryColWidth = 150;

    /**
     * Product selection table containing the product generated by the Source,
     * Fields, and Planes menu selections.
     */
    private Table prodSelTable;

    /**
     * Product selection index array used to keep track of the indexes of the
     * selected products.
     */
    private boolean[] prodSelIdxArray = new boolean[0];

    /**
     * Popup menu that appears when right-clicking on a table item.
     */
    private Menu popupMenu;

    /**
     * Label displaying the total product available.
     */
    private Label totalProductsLbl;

    /**
     * Label displaying the number of selected products.
     */
    private Label selectedProductsLbl;

    /**
     * Difference button.
     */
    private Button diffBtn;

    /**
     * Load button.
     */
    private Button loadBtn;

    /**
     * Table item font.
     */
    private Font tiFont;

    /**
     * Array of Product Table Data.
     */
    protected List<LoadProductJob> loadProductJobs;

    /**
     * Open Inventory dialogs.
     */
    private Map<String, InventoryDlg> inventoryDlgMap = new HashMap<>();

    /**
     * Constructor.
     *
     * @param parentComp
     *            Parent composite.
     */
    public ProductTableComp(Composite parentComp) {
        super(parentComp, 0);

        initializeComponents();
    }

    /**
     * Initialize the components on the display.
     */
    private void initializeComponents() {
        initializeData();

        GridLayout gl = new GridLayout(1, false);
        gl.marginHeight = 0;
        gl.marginWidth = 0;
        this.setLayout(gl);
        this.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));

        // Create the product table
        createTable();

        // Create the product and selection labels.
        createProductLabels();

        // Create the Diff and Load buttons.
        initializeDiffButton();
        initializeLoadButton();
        createBottomButtons(new Button[] { diffBtn, loadBtn });

        // Update the product labels with the current product
        // and selection counts.
        updateLoadButtonAndProductLabels();

        // Add a dispose listener to this class so we can
        // clean up objects we have created.
        this.addDisposeListener(new DisposeListener() {
            @Override
            public void widgetDisposed(DisposeEvent e) {
                tiFont.dispose();
            }
        });
    }

    /**
     * Initializes the load button
     */
    private void initializeLoadButton() {

        GridData gd = new GridData(SWT.FILL, SWT.DEFAULT, true, false);
        gd.widthHint = 200;
        loadBtn = new Button(getParent(), SWT.PUSH);
        loadBtn.setText("Load");
        loadBtn.setEnabled(false);
        loadBtn.setLayoutData(gd);
        loadBtn.addSelectionListener(new SelectionAdapter() {
            @Override
            public void widgetSelected(SelectionEvent event) {
                loadProducts(false);
            }
        });
    }

    /**
     * Initializes the diff button
     */
    private void initializeDiffButton() {
        GridData gd = new GridData(80, SWT.DEFAULT);
        diffBtn = new Button(getParent(), SWT.PUSH);
        diffBtn.setText("Diff");
        diffBtn.setEnabled(false);
        diffBtn.setLayoutData(gd);
        diffBtn.addSelectionListener(new SelectionAdapter() {
            @Override
            public void widgetSelected(SelectionEvent event) {
                loadProducts(true);
            }

        });
    }

    /**
     * Initialize the data map and array. Create table item font.
     */
    private void initializeData() {
        tiFont = new Font(this.getDisplay(), "Fixed", 10, SWT.BOLD);

        this.loadProductJobs = Collections.emptyList();
    }

    /**
     * Create the Product Selection Table.
     */
    private void createTable() {
        GridData gd = new GridData(SWT.FILL, SWT.FILL, true, true);
        gd.heightHint = 200;
        gd.widthHint = 200;
        gd.verticalIndent = 10;

        prodSelTable = new Table(this, SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL
                | SWT.MULTI | SWT.FULL_SELECTION);
        prodSelTable.setLayoutData(gd);
        prodSelTable.setHeaderVisible(true);
        prodSelTable.setLinesVisible(true);

        prodSelTable.addControlListener(new ControlAdapter() {
            @Override
            public void controlResized(ControlEvent e) {
                resizeTableColumns();
            }

        });

        // Add a selection listener so the indexes can be updated.
        prodSelTable.addSelectionListener(new SelectionAdapter() {
            @Override
            public void widgetSelected(SelectionEvent event) {
                int index = prodSelTable.getSelectionIndex();
                prodSelIdxArray[index] = !prodSelIdxArray[index];
                applySavedSelection();
            }
        });

        /*
         * Add a mouse listener to the table.
         */
        prodSelTable.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseDown(MouseEvent me) {
                if (me.button == 3) {
                    // Set the data to false because we are not
                    // selecting/de-selecting
                    // rows from the table.

                    // The the table item associated with the mouse position
                    // when the mouse
                    // is right clicked.
                    TableItem item = prodSelTable
                            .getItem(new Point(me.x, me.y));

                    // Check if there is a table item where the mouse button was
                    // clicked.
                    if (item == null) {
                        /*
                         * Dispose of the popup menu so the previous created
                         * popup menu does not popup when right-clicking on the
                         * table where a table item does not exist.
                         */
                        if (popupMenu != null) {
                            popupMenu.dispose();
                        }

                        return;
                    }

                    // Create the popup menu and then display it.
                    createPopupMenu(prodSelTable, item);
                    popupMenu.setVisible(true);
                }
                // we are toggling between an image or contour
                else if (me.button == 2) {
                    /*
                     * The the table item associated with the mouse position
                     * when the mouse is right clicked.
                     */
                    TableItem item = prodSelTable
                            .getItem(new Point(me.x, me.y));

                    /*
                     * Check if there is a table item where the mouse button was
                     * clicked.
                     */
                    if (item != null) {
                        /*
                         * To match A1, we want the item clicked on to become
                         * selected. Because in SWT (with GTK, at least) a
                         * middle-click also triggers a SelectionEvent and there
                         * is no way to filter out middle-clicks in the
                         * SelectionEvent handler, we force the item's selection
                         * state to false. When the SelectionEvent handler
                         * triggers it will flip to true and become selected.
                         */
                        int index = prodSelTable.indexOf(item);
                        prodSelIdxArray[index] = false;

                        // toggle the item between DisplayTypes
                        toggleDisplayTypes(prodSelTable, item);
                    }
                }
            }

        });

        // Add the table columns to the table.
        addTableColumns();
    }

    private void toggleDisplayTypes(Table prodSelTable, TableItem item) {

        int itemIndex = prodSelTable.indexOf(item);
        ProductTableData productTableData = getProductData(itemIndex);

        if (!isMultiDisplayTypeCapable(productTableData.getCatalogEntry()
                .getDialogSettings().getViewSelection())) {
            return;
        }

        DisplayType currentDisplayType = productTableData.getDisplayTypeSet()
                .iterator().next();
        List<DisplayType> displayTypes = productTableData.getSelectedData()
                .getDisplayTypes();

        for (int i = 0; i < displayTypes.size(); i++) {
            if (displayTypes.get(i).equals(currentDisplayType)) {
                changeProductDisplayType(itemIndex,
                        displayTypes.get((i + 1) % displayTypes.size()));
            }
        }

    }

    /**
     * Add the Times, Product Selection List, and Inventory column to the table.
     */
    private void addTableColumns() {
        TableColumn column1 = new TableColumn(prodSelTable, SWT.NONE);
        column1.setText("Times");
        column1.setWidth(timesColWidth);
        column1.setResizable(false);

        TableColumn column2 = new TableColumn(prodSelTable, SWT.NONE);
        column2.setText("Product Selection List");

        TableColumn column3 = new TableColumn(prodSelTable, SWT.NONE);
        column3.setText("Inventory");
        column3.setWidth(inventoryColWidth);
        column3.setResizable(false);

        // Pack the columns
        for (int i = 0; i < prodSelTableColumnCount; i++) {
            prodSelTable.getColumn(i).pack();
        }
    }

    /**
     * Copy the selection information from {@link #prodSelIdxArray} into the
     * {@link #prodSelTable}. This is what allows multiselect behavior without a
     * modifier key.
     */
    private void applySavedSelection() {

        for (int i = 0; i < prodSelIdxArray.length; i++) {
            if (prodSelIdxArray[i]) {
                prodSelTable.select(i);
            } else {
                prodSelTable.deselect(i);
            }
        }
        updateLoadButtonAndProductLabels();
    }

    /**
     * Copy the selection information from {@link #prodSelTable} into the
     * {@link #prodSelIdxArray}. This should be called any time the selection is
     * modified to ensure that the multiselection behavior works as expected.
     */
    private void saveSelectedIndexes() {
        // Create a new re-sized product selection array.
        prodSelIdxArray = new boolean[prodSelTable.getItemCount()];

        Arrays.fill(prodSelIdxArray, false);

        int[] selectedIdx = prodSelTable.getSelectionIndices();

        for (int i = 0; i < selectedIdx.length; i++) {
            prodSelIdxArray[selectedIdx[i]] = true;
        }
    }

    /**
     * Create the products and product selection labels.
     */
    private void createProductLabels() {
        Composite prodLabelComp = new Composite(this, SWT.NONE);
        GridLayout gl = new GridLayout(4, false);
        gl.marginHeight = 2;
        gl.marginWidth = 2;
        prodLabelComp.setLayout(gl);
        prodLabelComp.setLayoutData(
                new GridData(SWT.FILL, SWT.DEFAULT, true, false));

        // Label that displays the number of products in the table.
        Label prodLbl = new Label(prodLabelComp, SWT.NONE);
        prodLbl.setText("Products: ");

        totalProductsLbl = new Label(prodLabelComp, SWT.NONE);
        totalProductsLbl.setText("0");
        totalProductsLbl.setLayoutData(new GridData(80, SWT.DEFAULT));

        // Label that displays the number of products that are selected.
        Label selLoadingLbl = new Label(prodLabelComp, SWT.NONE);
        selLoadingLbl.setText("Selected for loading: ");

        selectedProductsLbl = new Label(prodLabelComp, SWT.NONE);
        selectedProductsLbl.setText("0");
        selectedProductsLbl.setLayoutData(new GridData(80, SWT.DEFAULT));
    }

    /**
     * Create the Bottom Buttons
     */
    protected void createBottomButtons(Button[] buttons) {

        Composite buttonComp = new Composite(this, SWT.NONE);
        GridLayout gl = new GridLayout(buttons.length, false);
        gl.marginHeight = 2;
        gl.marginWidth = 2;
        buttonComp.setLayout(gl);
        buttonComp.setLayoutData(
                new GridData(SWT.FILL, SWT.DEFAULT, true, false));

        for (Button button : buttons) {
            button.setParent(buttonComp);

        }
    }

    /**
     * Create a popup menu for the table item that was right-clicked.
     *
     * @param parent
     *            Parent control.
     * @param tableItem
     *            Table item that was right-clicked.
     */
    private void createPopupMenu(Control parent, final TableItem tableItem) {
        // Need to create menu on the fly...
        if (popupMenu != null) {
            popupMenu.dispose();
        }

        popupMenu = new Menu(parent);

        ProductTableData productData = (ProductTableData) tableItem.getData();

        MenuItem productTitleItem = new MenuItem(popupMenu, SWT.NONE);
        productTitleItem.setText("Product: " + productData.getName());

        // Separator bar.
        new MenuItem(popupMenu, SWT.SEPARATOR);

        if (isMultiDisplayTypeCapable(productData.getCatalogEntry()
                .getDialogSettings().getViewSelection())) {

            for (final DisplayType displayType : productData.getSelectedData()
                    .getDisplayTypes()) {

                if (displayType.equals(
                        productData.getDisplayTypeSet().iterator().next())) {
                    continue;
                }

                MenuItem changeDisplayTypeMenuItem = new MenuItem(popupMenu,
                        SWT.NONE);
                changeDisplayTypeMenuItem.setText(
                        "Change to " + productData.getName(displayType));
                changeDisplayTypeMenuItem
                        .addSelectionListener(new SelectionAdapter() {
                            @Override
                            public void widgetSelected(SelectionEvent e) {
                                changeProductDisplayType(
                                        prodSelTable.indexOf(tableItem),
                                        displayType);
                            }
                        });
            }

        }

        MenuItem loadItem = new MenuItem(popupMenu, SWT.NONE);
        loadItem.setText("Load this product now");
        loadItem.addSelectionListener(new SelectionAdapter() {
            @Override
            public void widgetSelected(SelectionEvent e) {
                loadSingleProduct(prodSelTable.indexOf(tableItem));
            }
        });

        if (isMultiDisplayTypeCapable(productData.getCatalogEntry()
                .getDialogSettings().getViewSelection())) {

            MenuItem loadAllDisplayTypesMenuItem = new MenuItem(popupMenu,
                    SWT.NONE);

            StringBuilder menuName = new StringBuilder();

            for (DisplayType displayType : productData.getSelectedData()
                    .getDisplayTypes()) {

                if (menuName.length() == 0) {
                    menuName.append("Load as ");
                } else {
                    menuName.append(" + ");
                }

                menuName.append(productData.getName(displayType));

            }

            loadAllDisplayTypesMenuItem.setText(menuName.toString());

            loadAllDisplayTypesMenuItem
                    .addSelectionListener(new SelectionAdapter() {

                        @Override
                        public void widgetSelected(SelectionEvent e) {
                            loadAllDisplayTypes(
                                    prodSelTable.indexOf(tableItem));
                        }

                        private void loadAllDisplayTypes(int indexOf) {

                            ProductTableData productTableData = getProductData(
                                    indexOf);

                            ProductLoader loader = new ProductLoader();
                            for (DisplayType displayType : productTableData
                                    .getSelectedData().getDisplayTypes()) {
                                loader.addProduct(
                                        productTableData.getCatalogEntry(),
                                        displayType);

                            }
                            loader.load();

                            unselectProduct(indexOf);
                        }

                    });

        }

        MenuItem inventoryItem = new MenuItem(popupMenu, SWT.NONE);
        inventoryItem.setText("Show detailed inventory...");

        inventoryItem.addSelectionListener(new SelectionAdapter() {
            @Override
            public void widgetSelected(SelectionEvent e) {
                displayInventotyForProduct(tableItem);
            }
        });

        // Set the pop-up menu as the pop-up for the shell
        parent.setMenu(popupMenu);
    }

    /**
     * @param indexOf
     * @param displayType
     */
    protected void changeProductDisplayType(int index,
            DisplayType displayType) {
        TableItem ti = prodSelTable.getItem(index);
        ProductTableData productData = getProductData(index);

        // don't go about doing this if we already set the type to the given
        // type
        if (productData.getDisplayTypeSet().contains(displayType)) {
            return;
        }

        productData.getDisplayTypeSet()
                .remove(productData.getDisplayTypeSet().iterator().next());
        productData.getDisplayTypeSet().add(displayType);

        ti.setText(1, productData.getName());
    }

    protected void changeProductDisplayType(int index,
            String displayTypeString) {
        DisplayType displayType = DisplayType.valueOf(displayTypeString);
        changeProductDisplayType(index, displayType);
    }

    private void displayInventotyForProduct(TableItem tableItem) {
        ProductTableData tableData = getProductData(tableItem);
        String name = tableData.getName();
        InventoryDlg inventoryDlg = inventoryDlgMap.get(name);
        if (inventoryDlg == null) {
            inventoryDlg = new InventoryDlg(getShell(), tableData);
            inventoryDlgMap.put(name, inventoryDlg);
            inventoryDlg.addCloseCallback(new ICloseCallback() {

                @Override
                public void dialogClosed(Object returnValue) {
                    if (returnValue instanceof String) {
                        inventoryDlgMap.remove(returnValue.toString());
                    }
                }
            });
        }
        inventoryDlg.open();
    }

    private ProductTableData getProductData(TableItem ti) {
        return (ProductTableData) ti.getData();
    }

    protected ProductTableData getProductData(int index) {
        return getProductData(prodSelTable.getItem(index));
    }

    /**
     *
     * @return a list of all selected data, an empty list if nothing is selected
     */
    public List<ProductTableData> getSelectedData() {

        List<ProductTableData> selectedData = new ArrayList<>();

        for (int selectedIndex : prodSelTable.getSelectionIndices()) {
            ProductTableData productData = getProductData(selectedIndex);
            selectedData.add(productData);
        }

        return selectedData;
    }

    /**
     * Update the Load and Diff button state to be enabled/disabled.
     */
    private void updateLoadButtonAndProductLabels() {
        // enable the load button only if products are selected
        loadBtn.setEnabled(prodSelTable.getSelectionCount() != 0);

        // enable the diff button if there are two products and they are of the
        // same display type
        diffBtn.setEnabled(
                isDifferenceProduct(prodSelTable.getSelectionIndices()));

        totalProductsLbl.setText(String.valueOf(prodSelTable.getItemCount()));
        selectedProductsLbl
                .setText(String.valueOf(prodSelTable.getSelectionCount()));
    }

    /**
     * Unselect the product at the specified index.
     *
     * @param index
     *            The index or indices of the product(s) to be unselected.
     * @param secondProductIndex
     */
    private void unselectProduct(int... index) {
        for (int i : index) {
            prodSelIdxArray[i] = false;
            prodSelTable.deselect(i);
        }
        updateLoadButtonAndProductLabels();
    }

    /**
     * Unselect all products
     */
    protected void selectNone() {
        prodSelTable.deselectAll();
        Arrays.fill(prodSelIdxArray, false);
        updateLoadButtonAndProductLabels();
    }

    /**
     * Select all products
     */
    protected void selectAll() {
        prodSelTable.selectAll();
        Arrays.fill(prodSelIdxArray, true);
        updateLoadButtonAndProductLabels();
    }

    /**
     * Load all of the selected products.
     *
     * @param difference
     *            if true load the a difference of the selected products.
     */
    private void loadProducts(boolean difference) {
        int[] prodIndexes = prodSelTable.getSelectionIndices();
        ProductLoader loader = new ProductLoader();

        for (int i = 0; i < prodIndexes.length; i++) {
            ProductTableData productData = getProductData(prodIndexes[i]);
            for (DisplayType displayType : productData.getDisplayTypeSet()) {
                loader.addProduct(productData.getCatalogEntry(), displayType);
            }
        }
        if (difference) {
            loader.loadDifference();
        } else {
            loader.load();
        }

        unselectProduct(prodIndexes);
    }

    /**
     * @param prodIndexes
     * @return
     */
    private boolean isDifferenceProduct(int... prodIndexes) {

        return (prodIndexes.length == 2
                && getProductData(prodIndexes[0]).getCatalogEntry()
                        .getDialogSettings()
                        .getViewSelection() != ViewMenu.SOUNDING
                && getProductData(prodIndexes[0]).getDisplayTypeSet().equals(
                        getProductData(prodIndexes[1]).getDisplayTypeSet()));
    }

    /**
     * Load the product at the specified index.
     *
     * @param selectedItemIndex
     *            Index of the selected product.
     */
    private void loadSingleProduct(int selectedItemIndex) {
        ProductTableData productData = getProductData(selectedItemIndex);
        ProductLoader loader = new ProductLoader();
        for (DisplayType displayType : productData.getDisplayTypeSet()) {
            loader.addProduct(productData.getCatalogEntry(), displayType);
        }
        loader.load();
        unselectProduct(selectedItemIndex);
    }

    /**
     * Resize the table columns. This will maintain sizes for the Times and
     * Inventory columns. The products column will adjust in size.
     */
    private void resizeTableColumns() {
        Rectangle tableBounds = prodSelTable.getBounds();

        prodSelTable.getColumn(0).setWidth(timesColWidth);
        prodSelTable.getColumn(1).setWidth(
                tableBounds.width - (timesColWidth + inventoryColWidth) - 20);
        // prodSelTable.getColumn(2).setWidth(inventoryColWidth);
    }

    /**
     * Clear the products table.
     */
    public void clearProductTable() {
        setProducts(Collections.emptyList());
    }

    /**
     * Pack the table. This will resize the table to fit as the display changes
     * size due to menu changes.
     */
    public void packTable() {
        prodSelTable.pack();
    }

    protected boolean hasProductCreator(IDataCatalogEntry entry) {
        IDataCatalog catalog = DataCatalogManager.getDataCatalogManager()
                .getDataCatalog(entry.getSelectedData());
        ResourceType resourceType = VBMenuBarItemsMgr
                .getResourceType(entry.getDialogSettings().getViewSelection());
        HashMap<String, RequestConstraint> metadataMap = catalog
                .getProductParameters(entry);
        String pluginName = metadataMap.get(PluginDataObject.PLUGIN_NAME_ID)
                .getConstraintValue();
        ProductCreator creator = ProductCreatorManager.getInstance()
                .getCreator(pluginName, resourceType);
        return creator != null;
    }

    protected void addProduct(ProductTableData tblData) {
        addProduct(tblData, prodSelTable.getItemCount());
        saveSelectedIndexes();
        updateLoadButtonAndProductLabels();
    }

    protected void addProduct(ProductTableData tblData, int index) {
        final TableItem ti = new TableItem(prodSelTable, SWT.NONE, index);

        ti.addDisposeListener(new DisposeListener() {

            @Override
            public void widgetDisposed(DisposeEvent e) {
                tblData.getProductInventory().cancelUpdateJob();
            }

        });

        final Runnable updateInventoryStrings = new Runnable() {
            @Override
            public void run() {
                if (ti.isDisposed()) {
                    return;
                }
                ti.setText(0,
                        tblData.getProductInventory().getLatestForecastTime());
                ti.setText(1, tblData.getName());
                ti.setFont(2, tiFont);
                ti.setText(2, tblData.getProductInventory()
                        .getInventoryStatusString());
                updateScrollBar();

            }
        };

        tblData.getProductInventory()
                .addJobChangeListener(new JobChangeAdapter() {
                    @Override
                    public void done(IJobChangeEvent event) {
                        getDisplay().asyncExec(updateInventoryStrings);
                    }
                });

        updateInventoryStrings.run();

        ti.setData(tblData);

        prodSelTable.select(index);
    }

    /**
     * Add a product to the product table.
     *
     * @param productParms
     *            Product parameters.
     * @param selectedData
     *            Data that contains Sources, Fields, and Planes information.
     */
    public void setProducts(List<SelectedData> selectedData) {
        Map<String, LoadProductJob> oldJobs = new HashMap<>();
        for (LoadProductJob job : this.loadProductJobs) {
            oldJobs.put(job.getSelectedData().getUniqueKey(), job);
        }
        Set<String> newKeys = new HashSet<>();
        this.loadProductJobs = new ArrayList<>(selectedData.size());
        for (SelectedData data : selectedData) {
            String key = data.getUniqueKey();
            newKeys.add(key);
            LoadProductJob job = oldJobs.get(key);
            if (job == null) {
                job = new LoadProductJob(data);
                job.schedule();
            }
            this.loadProductJobs.add(job);
        }
        /* Iterate backwards so removal doesn't interfere with iteration. */
        for (int i = prodSelTable.getItemCount() - 1; i >= 0; i -= 1) {
            String key = getProductData(i).getSelectedData().getUniqueKey();
            if (!newKeys.contains(key)) {
                prodSelTable.remove(i);
            }
        }
        saveSelectedIndexes();
        updateLoadButtonAndProductLabels();
    }

    /**
     * Update the {@link #prodSelTable} with any {@link LoadProductJob}s that
     * have finished.
     */
    protected void addLoadedProducts() {
        if (prodSelTable.isDisposed()) {
            return;
        }
        int tableIndex = 0;
        String tableKey = null;
        if (prodSelTable.getItemCount() > 0) {
            tableKey = getProductData(0).getSelectedData().getUniqueKey();
        }
        for (int jobIndex = 0; jobIndex < loadProductJobs
                .size(); jobIndex += 1) {
            LoadProductJob job = loadProductJobs.get(jobIndex);
            String jobKey = job.getSelectedData().getUniqueKey();
            if (jobKey.equals(tableKey)) {
                tableIndex += 1;
                if (prodSelTable.getItemCount() > tableIndex) {
                    tableKey = getProductData(tableIndex).getSelectedData()
                            .getUniqueKey();
                } else {
                    tableKey = null;
                }
            } else if (job.getTableData() != null) {
                addProduct(job.getTableData(), tableIndex);
                tableIndex += 1;
            }
        }
        saveSelectedIndexes();
        updateLoadButtonAndProductLabels();
    }

    protected void updateScrollBar() {
        prodSelTable.getColumn(2).pack();
    }

    /**
     *
     * @param currentSetting
     * @return return true if the current view is capable of selecting and
     *         displaying multiple display types, false otherwise
     */
    private boolean isMultiDisplayTypeCapable(ViewMenu currentSetting) {

        switch (currentSetting) {
        case VARVSHGT:
        case SOUNDING:
        case TIMESERIES:
            return false;
        }

        return true;
    }

    /**
     * Provides asyncronous generatiopn of {@link IDataCatalogEntry} from
     * {@link SelectedData}. This operation is usually quick but since the
     * performance can be variable and it is possible to load many products at
     * once it is best to do it off of the UI thread.
     */
    private class LoadProductJob extends Job {

        private final SelectedData selectedData;

        private ProductTableData tableData;

        public LoadProductJob(SelectedData selectedData) {
            super("Loading Product...");
            this.selectedData = selectedData;
        }

        @Override
        protected IStatus run(IProgressMonitor monitor) {
            IDataCatalogEntry entry = DataCatalogManager.getDataCatalogManager()
                    .getDataCatalogEntry(selectedData);
            if (entry != null && hasProductCreator(entry)) {
                this.tableData = new ProductTableData(entry);
                VizApp.runAsync(ProductTableComp.this::addLoadedProducts);
            }
            return Status.OK_STATUS;
        }

        public ProductTableData getTableData() {
            return tableData;
        }

        public SelectedData getSelectedData() {
            return selectedData;
        }

    }
}
