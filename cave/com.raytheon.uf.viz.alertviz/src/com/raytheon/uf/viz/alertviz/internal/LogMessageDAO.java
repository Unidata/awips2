/**
 * This software was developed and / or modified by Raytheon Company,
 * pursuant to Contract DG133W-05-CQ-1067 with the US Government.
 *
 * U.S. EXPORT CONTROLLED TECHNICAL DATA
 * This software product contains export-restricted data whose
 * export/transfer/disclosure is restricted by U.S. law. Dissemination
 * to non-U.S. persons whether in the United States or abroad requires
 * an export license or other authorization.
 *
 * Contractor Name:        Raytheon Company
 * Contractor Address:     6825 Pine Street, Suite 340
 *                         Mail Stop B8
 *                         Omaha, NE 68106
 *                         402.291.0100
 *
 * See the AWIPS II Master Rights File ("Master Rights File.pdf") for
 * further licensing information.
 **/
package com.raytheon.uf.viz.alertviz.internal;

import java.io.File;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;

import org.apache.derby.jdbc.EmbeddedDriver;

import com.raytheon.uf.common.message.StatusMessage;
import com.raytheon.uf.common.status.UFStatus.Priority;
import com.raytheon.uf.viz.alertviz.AlertvizException;
import com.raytheon.uf.viz.alertviz.Container;
import com.raytheon.uf.viz.alertviz.config.Category;
import com.raytheon.uf.viz.core.VizApp;
import com.raytheon.uf.viz.core.localization.LocalizationManager;

/**
 * Stores the log messages in an internal derby database
 *
 * <pre>
 * SOFTWARE HISTORY
 *
 * Date          Ticket#  Engineer  Description
 * ------------- -------- --------- --------------------------------------------
 * Sep 11, 2008  1433     chammack  Initial creation
 * Feb 11, 2016  5314     dgilling  Add loadByRowOffset.
 * Jul 11, 2016  5746     dgilling  Better control multi-threaded access to
 *                                  Connection.
 * Oct 01, 2018  7455     randerso  Removed unused queries. Added JavaDoc.
 *                                  Cleaned up SQL query for loading most recent
 *                                  by categories.
 *
 * </pre>
 *
 * @author chammack
 */

public class LogMessageDAO {

    private static final String SELECT_ALL_QUERY = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log ORDER BY event_time";

    private static final String SELECT_ALL_QUERY_BY_PK = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log WHERE pk = ?";

    private static final String SELECT_ALL_QUERY_BY_ROW_OFFSET = "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log ORDER BY pk OFFSET ? ROWS FETCH NEXT ROW ONLY";

    private static final String MESSAGE_COUNT_QUERY = "SELECT COUNT(pk) FROM log";

    private static final String SELECT_LAST_INSERT_ID = "SELECT IDENTITY_VAL_LOCAL() FROM log";

    private static final String INSERT_PREPARED_STATEMENT = "INSERT INTO log(event_time, category, priority, message, details, source) values (?, ?, ?, ?, ?, ?)";

    private static final String DB_CREATE = "CREATE TABLE log(pk INT NOT NULL GENERATED BY DEFAULT AS IDENTITY, event_time TIMESTAMP, category VARCHAR(64), source VARCHAR(64), priority INT, message VARCHAR(32672), details VARCHAR(32672), acknowledgedBy VARCHAR(32), acknowledgedAt TIMESTAMP)";

    private static final String PURGE_SELECT_STATEMENT = "SELECT pk FROM log WHERE event_time < ?";

    private static final String ACKNOWLEDGE = "UPDATE log SET acknowledgedAt = ? , acknowledgedBy = ? WHERE pk = ?";

    private Connection connection;

    private PreparedStatement saveStatement;

    private PreparedStatement getLastStatement;

    private static final String databaseDir = LocalizationManager.getUserDir()
            + File.separator + "logs" + File.separator + VizApp.getHostName();

    private static final String startDatabase = "jdbc:derby:directory:"
            + databaseDir + ";create=true";

    private static final String stopDatabase = "jdbc:derby:directory:"
            + databaseDir + ";shutdown=true";

    private static final SimpleDateFormat sdf = new SimpleDateFormat(
            "yyyyMMdd");

    private static LogMessageDAO instance = new LogMessageDAO();

    /**
     * @return the LogMessageDAO singleton instance
     */
    public static LogMessageDAO getInstance() {
        return instance;
    }

    private LogMessageDAO() {
    }

    private synchronized Connection getConnection() throws AlertvizException {
        if (connection != null) {
            try {
                if (connection.isClosed()) {
                    closeConnection();
                }
            } catch (SQLException e) {
                Container.logInternal(Priority.ERROR,
                        "Failed to connect to the AlertViz internal logging DB",
                        e);
                closeConnection();
            }
        }
        if (connection == null) {
            try {
                createConnection();
            } catch (Exception e) {
                // unable to create a connection, move alertViz log dir and
                // recreate
                Container.logInternal(Priority.ERROR,
                        "Unable to create connection to database, moving database dir to bad, and recreating from scratch",
                        e);
                moveLogDirToBackup();
                createConnection();
            }
        }

        return connection;
    }

    private void createConnection() throws AlertvizException {
        Statement statement = null;
        try {
            new EmbeddedDriver();
            connection = DriverManager.getConnection(startDatabase);
            DatabaseMetaData dmd = connection.getMetaData();
            ResultSet tables = dmd.getTables(null, null, null,
                    new String[] { "TABLE" });
            boolean needCreation = true;

            while (tables.next()) {
                String tableName = tables.getString("TABLE_NAME");
                if ("log".equalsIgnoreCase(tableName)) {
                    needCreation = false;
                    break;
                }
            }

            if (needCreation) {
                statement = connection.createStatement();
                statement.execute(DB_CREATE);
            }
            connection.commit();
        } catch (Exception e1) {
            closeConnection();
            throw new AlertvizException("Error setting up logging system", e1);
        } finally {
            closeStatement(statement);
        }
    }

    private void closeConnection() {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                // ignore
            }
            connection = null;
        }

        try {
            DriverManager.getConnection(stopDatabase);
        } catch (SQLException e) {
            // ignore as stop database will always throw an exception
        }
    }

    private void closeStatement(Statement statement) {
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    private void closeResultSet(ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    private void moveLogDirToBackup() {
        File oldDir = new File(databaseDir);
        File newDir = null;
        synchronized (sdf) {
            boolean notFound = true;
            int count = 0;
            String basePath = databaseDir + "_bad_" + sdf.format(new Date())
                    + "_";
            while (notFound) {
                newDir = new File(basePath + count);
                count++;
                if (!newDir.exists()) {
                    notFound = false;
                }
            }
        }
        oldDir.renameTo(newDir);
    }

    /**
     * Save a statusMessage to the log
     *
     * @param sm
     *            the statusMessage to be saved
     * @throws AlertvizException
     */
    public synchronized void save(StatusMessage sm) throws AlertvizException {
        Container.logInternal(sm);

        boolean errorOccurred = false;
        ResultSet rs = null;
        try {
            Connection conn = getConnection();
            if (saveStatement == null) {
                saveStatement = conn
                        .prepareStatement(INSERT_PREPARED_STATEMENT);
            }

            saveStatement.setTimestamp(1,
                    new Timestamp(sm.getEventTime().getTime()));
            saveStatement.setString(2, sm.getCategory());
            saveStatement.setInt(3, sm.getPriority().ordinal());
            saveStatement.setString(4, sm.getMessage());
            saveStatement.setString(5, sm.getDetails());
            saveStatement.setString(6, sm.getSourceKey());
            saveStatement.executeUpdate();

            if (getLastStatement == null) {
                getLastStatement = conn.prepareStatement(SELECT_LAST_INSERT_ID);
            }

            rs = getLastStatement.executeQuery();
            if (rs.next()) {
                int id = rs.getInt(1);
                sm.setPk(id);
            }
            conn.commit();
        } catch (Exception e) {
            errorOccurred = true;
            throw new AlertvizException("Save failed", e);
        } finally {
            if (errorOccurred) {
                closeStatement(saveStatement);
                saveStatement = null;
                closeStatement(getLastStatement);
                getLastStatement = null;
                closeConnection();
            }
        }
    }

    /**
     * Acknowledge a statusMessage
     *
     * @param sm
     *            the statusMessage to be acknowledged
     * @param username
     *            the user who acknowledged the message
     * @throws AlertvizException
     */
    public synchronized void acknowledge(StatusMessage sm, String username)
            throws AlertvizException {
        PreparedStatement updateStatement = null;
        try {
            Connection conn = getConnection();
            updateStatement = conn.prepareStatement(ACKNOWLEDGE);

            long ackTime = System.currentTimeMillis();
            updateStatement.setTimestamp(1, new Timestamp(ackTime));
            updateStatement.setString(2, username);
            updateStatement.setInt(3, sm.getPk());
            updateStatement.executeUpdate();
            sm.setAcknowledgedBy(username);
            sm.setAcknowledgedAt(new Date(ackTime));
            conn.commit();
        } catch (SQLException e) {
            closeConnection();
            throw new AlertvizException("Acknowledge Failed", e);
        } finally {
            closeStatement(updateStatement);
        }
    }

    /**
     * Load a statusMessage by primary key
     *
     * @param pk
     *            the primary key to load
     * @return the selected statusMessage
     * @throws AlertvizException
     */
    public synchronized StatusMessage loadByPk(int pk)
            throws AlertvizException {
        ResultSet rs = null;
        PreparedStatement statement = null;
        try {
            Connection conn = getConnection();
            statement = conn.prepareStatement(SELECT_ALL_QUERY_BY_PK);
            statement.setInt(1, pk);

            rs = statement.executeQuery();

            conn.commit();
            return reconstituteResults(rs).get(0);
        } catch (SQLException | RuntimeException e) {
            closeConnection();
            throw new AlertvizException("Error loading " + pk, e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
        }
    }

    /**
     * Retrieves the specified status message from the message store using the
     * specified index as a row offset.
     *
     * @param index
     *            The index of the message to retrieve
     * @return The status message
     * @throws AlertvizException
     *             If an error occurred retrieving the message from the message
     *             store.
     */
    public synchronized StatusMessage loadByRowOffset(int index)
            throws AlertvizException {
        ResultSet rs = null;
        PreparedStatement statement = null;
        try {
            Connection conn = getConnection();
            statement = conn.prepareStatement(SELECT_ALL_QUERY_BY_ROW_OFFSET);
            statement.setInt(1, index);

            rs = statement.executeQuery();

            conn.commit();
            return reconstituteResults(rs).get(0);
        } catch (SQLException | RuntimeException e) {
            closeConnection();
            throw new AlertvizException("Error loading " + index, e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
        }
    }

    /**
     * Load all messages in the log
     *
     * @return the messages
     * @throws AlertvizException
     */
    public synchronized List<StatusMessage> load() throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            statement.setMaxFieldSize(0);
            rs = statement.executeQuery(SELECT_ALL_QUERY);
            conn.commit();
            return reconstituteResults(rs);
        } catch (SQLException e) {
            closeConnection();
            throw new AlertvizException("Error loading ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
        }
    }

    /**
     * Load the count most recent message by categories
     *
     * @param count
     *            the number of messages to return
     * @param filter
     *            the desired categories
     * @return the selected messages
     * @throws AlertvizException
     */
    public synchronized List<StatusMessage> load(int count, Category[] filter)
            throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            StringBuilder sb = new StringBuilder();
            sb.append(
                    "SELECT event_time, category, priority, message, details, source, pk, acknowledgedBy, acknowledgedAt FROM log  ");

            boolean first = true;
            if (filter.length > 0) {
                sb.append("WHERE category IN (");
                for (Category cat : filter) {
                    if (!first) {
                        sb.append(",");
                    }
                    first = false;

                    sb.append("'").append(cat.getCategoryName()).append("'");
                }
                sb.append(")");
            }

            sb.append(" ORDER BY event_time DESC");

            if (count > 0) {
                sb.append(" FETCH FIRST ").append(count).append(" ROWS ONLY");
            }
            rs = statement.executeQuery(sb.toString());
            conn.commit();
            List<StatusMessage> results = reconstituteResults(rs);
            Collections.reverse(results);
            return results;
        } catch (SQLException e) {
            closeConnection();
            throw new AlertvizException("Error loading ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
        }
    }

    /**
     * Purge all records with event time prior to purgeTime
     *
     * @param purgeTime
     * @return the primary keys of the deleted records
     * @throws AlertvizException
     */
    public synchronized Collection<Integer> purge(Timestamp purgeTime)
            throws AlertvizException {
        Connection conn = getConnection();

        try (PreparedStatement purgeSelect = conn.prepareStatement(
                PURGE_SELECT_STATEMENT, ResultSet.TYPE_FORWARD_ONLY,
                ResultSet.CONCUR_UPDATABLE)) {
            purgeSelect.setTimestamp(1, purgeTime);

            try (ResultSet rs = purgeSelect.executeQuery()) {
                Collection<Integer> deletedKeys = new HashSet<>(512, 1f);
                while (rs.next()) {
                    deletedKeys.add(Integer.valueOf(rs.getInt(1)));
                    rs.deleteRow();
                }

                conn.commit();
                return Collections.unmodifiableCollection(deletedKeys);
            }
        } catch (SQLException e) {
            closeConnection();
            throw new AlertvizException("Error purging ", e);
        }
    }

    /**
     * Retrieves the number of status messages in the message store.
     *
     * @return Total number of messages.
     * @throws AlertvizException
     */
    public synchronized int getMessageCount() throws AlertvizException {
        ResultSet rs = null;
        Statement statement = null;
        try {
            Connection conn = getConnection();
            statement = conn.createStatement();
            statement.setMaxFieldSize(1);
            rs = statement.executeQuery(MESSAGE_COUNT_QUERY);
            if (rs.next()) {
                int count = rs.getInt(1);
                return count;
            }
            conn.commit();
        } catch (SQLException e) {
            closeConnection();
            throw new AlertvizException("Error getting message count ", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
        }

        return 0;
    }

    private List<StatusMessage> reconstituteResults(ResultSet rs)
            throws SQLException {
        List<StatusMessage> retVal = new ArrayList<>();
        while (rs.next()) {
            StatusMessage sm = new StatusMessage();
            sm.setEventTime(rs.getTimestamp(1));
            sm.setCategory(rs.getString(2));
            sm.setPriority(Priority.values()[rs.getInt(3)]);
            sm.setMessage(rs.getString(4));
            sm.setDetails(rs.getString(5));
            sm.setSourceKey(rs.getString(6));
            sm.setPk(rs.getInt(7));
            sm.setAcknowledgedBy(rs.getString(8));

            Timestamp ts = rs.getTimestamp(9);
            if (ts != null) {
                sm.setAcknowledgedAt(new Date(ts.getTime()));
            }

            retVal.add(sm);
        }

        return retVal;
    }
}
